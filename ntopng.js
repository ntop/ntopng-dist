(function () {
	'use strict';

	// 2014-20 - ntop.org
	Date.prototype.format = function (format) { //author: meizz
		var o = {
			"M+": this.getMonth() + 1, //month
			"d+": this.getDate(),    //day
			"h+": this.getHours(),   //hour
			"m+": this.getMinutes(), //minute
			"s+": this.getSeconds(), //second
			"q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
			"S": this.getMilliseconds() //millisecond
		};

		if (/(y+)/.test(format)) format = format.replace(RegExp.$1,
			(this.getFullYear() + "").substr(4 - RegExp.$1.length));
		for (var k in o) if (new RegExp("(" + k + ")").test(format))
			format = format.replace(RegExp.$1,
				RegExp.$1.length == 1 ? o[k] :
					("00" + o[k]).substr(("" + o[k]).length));
		return format;
	};

	// Extended disable function 
	jQuery.fn.extend({
		disable: function (state) {
			return this.each(function () {
				var $this = $(this);
				if ($this.is('input, button, textarea, select'))
					this.disabled = state;
				else
					$this.toggleClass('disabled', state);
			});
		}
	});

	const NTOPNG_MIN_VISUAL_VALUE = 0.005;

	const REGEXES = {
		ipv4: "^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
		ipv6: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\:){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$",
		domainName: "^(([a-zA-Z]{1})|([a-zA-Z]{1}[a-zA-Z]{1})|([a-zA-Z]{1}[0-9]{1})|([0-9]{1}[a-zA-Z]{1})|([a-zA-Z0-9][-_\.a-zA-Z0-9]{1,61}[a-zA-Z0-9]))\.([a-zA-Z]{2,13}|[a-zA-Z0-9-]{2,30}\.[a-zA-Z]{2,3})",
	  port: "^([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$",
	  latency: "^([0-9]*[.])?[0-9]+$",
		url: "^(https?\:\/\/[^\/\\s]+(\/.*)?)$",
		emailUrl: "^smtps?:\/\/[-a-zA-Z0-9:.]{1,256}+$",
		macAddress: "^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$",
	  hostname: "^[a-zA-Z0-9._:\-]{3,250}|^[a-zA-Z0-9._:\-]{3,250}@[0-9]{0,5}",
		username: "^[a-zA-Z0-9._@!-?]{3,30}$",
		singleword: "^(?=[a-zA-Z0-9._:\-]{3,253}$)(?!.*[_.:\-]{2})[^_.:\-].*[^_.:\-]$",
		email: "^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*)$",
		https: "^https?://.+$",
		token: "^[0-9a-f]{32}",
	  score: "^[0-9]{1,5}",
	  telegram_channel: "^[0-9\-]{1,15}",
	  password: "^[\w\/$!\/()=?^*@_-]{5,31}$",
	  tls_certificate: String.raw`^[^=,]+=[^=,]+(,\s[^=,]+=[^=,]+)*$`,
	  domain_name_not_strict: String.raw`^[a-zA-Z0-9\-_~]+((\.[a-zA-Z0-9\-_~]+)+)$`,
		non_quoted_text: "^[a-zA-Z0-9.-_]+$",
	};

	class NtopUtils$1 {

	  /* Show an overlay to hide loading */
	  static toggleOverlays(time = 500) {
	    $(`.overlay`).toggle(time);
	  }
	  
	  static showOverlays(time = 500) {
	    $(`.overlay`).fadeIn(time);
	  }
	  
	  static hideOverlays(time = 500) {
	    $(`.overlay`).fadeOut(time);
	  }

		static get REGEXES() {
			return REGEXES;
		}

		static getIPv4RegexWithCIDR() {
			const length = REGEXES.ipv4.length;
			return `${REGEXES.ipv4.substring(0, length - 1)}(\\/?)(\\b([0-9]|[12][0-9]|3[0-2])?\\b)$`;
		}

		static getIPv6RegexWithCIDR() {
			const length = REGEXES.ipv6.length;
			return `${REGEXES.ipv6.substring(0, length - 1)}(\\/?)\\b([0-9]|[1-9][0-9]|1[01][0-9]|12[0-8])?\\b$`;
		}

		/**
		 * Resolve a hostname by doing a DNS Resolve.
		 * @param {string} hostname The hostname to resolve
		 */
		static async resolveDNS(hostname = "ntop.org") {

			// resolve the hostname by doing a fetch request to the backend
			try {
				const request = await fetch(`${http_prefix}/lua/rest/v2/get/dns/resolve.lua?hostname=${hostname}`);
				const response = await request.json();
				return response;
			}
			catch (err) {
				// prints out the error if the request fails
				console.error(`Something went wrong when resolving hostname: ${err}`);
			}

			// if the request has failed return a placeholder response
			// indicating the failure
			return { rc: -1, rc_str: "FAILED_HTTP_REQUEST" };
		}

		/**
		 * Replace the inputs which contain the [data-pattern] attribute
		 * with the [pattern] attribute.
		 */
		static initDataPatterns() {
			// for each input with the data-pattern attribute
			// substitute the data-pattern with the right regexes
			$(`input[data-pattern]`).each(function () {

				// if the pattern is empty then print a warn inside the console
				const dataPattern = $(this).data('pattern');
				if (!dataPattern) {
					console.warn(`An empty data-pattern on an input was found!`, this);
					return;
				}

				// build the regexp pattern for the input
				const pattern = dataPattern.split('|').map(p => REGEXES[p].toString()).join('|');
				// load the pattern
				$(this).attr('pattern', pattern);
				// remove the data-pattern from the input
				$(this).removeAttr('data-pattern');
			});
		}

		static is_good_ipv4(ipv4) {
			return new RegExp(REGEXES.ipv4).test(ipv4);
		}

		static is_good_ipv6(ipv6) {
			return new RegExp(REGEXES.ipv6).test(ipv6);
		}

		static is_mac_address(mac) {
			return new RegExp(REGEXES.macAddress).test(mac);
		}

		static isNumeric(value) {
			return /^\d+$/.test(value);
		}

		static is_network_mask(what, optional_mask) {
			var elems = what.split("/");
			var mask = null;
			var ip_addr;

			if (elems.length != 2) {
				if (!optional_mask)
					return null;
				else
					ip_addr = what;
			} else {
				ip_addr = elems[0];

				if (!NtopUtils$1.isNumeric(elems[1]))
					return null;

				mask = parseInt(elems[1]);

				if (mask < 0)
					return null;
			}

			if (NtopUtils$1.is_good_ipv4(ip_addr)) {
				if (mask === null)
					mask = 32;
				else if (mask > 32)
					return null;

				return {
					type: "ipv4",
					address: ip_addr,
					mask: mask
				};
			} else if (NtopUtils$1.is_good_ipv6(elems[0])) {
				if (mask === null)
					mask = 128;
				else if (mask > 128)
					return (false);

				return {
					type: "ipv6",
					address: ip_addr,
					mask: mask
				};
			}

			return null;
		}

		static fbits(bits) {
			const sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'];

			if (typeof (bits) === "undefined")
				return "-";

			if (bits == 0) return '0';
			if ((bits > 0) && (bits < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' bps');
			var bits_log1000 = Math.log(bits) / Math.log(1000);
			var i = parseInt(Math.floor(bits_log1000));
			if (i < 0 || isNaN(i)) {
				i = 0;
			} else if (i >= sizes.length) { // prevents overflows
				return "> " + sizes[sizes.length - 1]
			}

			if (i <= 1) {
				return Math.round(bits / Math.pow(1000, i) * 100) / 100 + ' ' + sizes[i]
			} 
			else {
				var ret = parseFloat(bits / Math.pow(1000, i)).toFixed(2);
				if (ret % 1 == 0)
					ret = Math.round(ret);
				return ret + ' ' + sizes[i]
			}
		}

		static export_rate(eps) {
			if (typeof (eps) === "undefined")
				return "-";

			var sizes = ['exp/s', 'Kexp/s'];
			if (eps == 0) return '0';
			if ((eps > 0) && (eps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' exps/s');
			var res = NtopUtils$1.scaleValue(eps, sizes, 1000);

			// Round to two decimal digits
			return Math.round(res[0] * 100) / 100 + ' ' + res[1];
		}

		static exports_format(exports) {
			if (typeof (exports) === "undefined")
				return "-";

			var exports_label = i18n_ext.exports.toLowerCase();

			var sizes = [exports_label, 'K ' + exports_label];
			if (exports == 0) return '0';
			if ((exports > 0) && (exports < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' exps/s');
			var res = NtopUtils$1.scaleValue(exports, sizes, 1000);

			// Round to two decimal digits
			return Math.round(res[0] * 100) / 100 + ' ' + res[1];
		}

		static fbits_from_bytes(bytes) {
			if (typeof (bytes) === "undefined")
				return "-";
			return (NtopUtils$1.fbits(bytes * 8));
		}

		static fpackets(pps) {
			if (typeof (pps) === "undefined")
				return "-";

			var sizes = ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];
			if (pps == 0) return '0';
			if ((pps > 0) && (pps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' pps');
			var res = NtopUtils$1.scaleValue(pps, sizes, 1000);

			// Round to two decimal digits
			return Math.round(res[0] * 100) / 100 + ' ' + res[1];
		}

		static fpoints(pps) {
			if (typeof (pps) === "undefined")
				return "-";

			var sizes = ['pt/s', 'Kpt/s', 'Mpt/s', 'Gpt/s', 'Tpt/s'];
			if (pps == 0) return '0';
			if ((pps > 0) && (pps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' pt/s');
			var res = NtopUtils$1.scaleValue(pps, sizes, 1000);

			// Round to two decimal digits
			return Math.round(res[0] * 100) / 100 + ' ' + res[1];
		}

		static fflows(fps) {
			if (typeof (fps) === "undefined")
				return "-";

			var sizes = ['fps', 'Kfps', 'Mfps', 'Gfps', 'Tfps'];
			if (fps == 0) return '0';
			if ((fps > 0) && (fps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' fps');
			var res = NtopUtils$1.scaleValue(fps, sizes, 1000);

			// Round to two decimal digits
			return Math.round(res[0] * 100) / 100 + ' ' + res[1];
		}

		static fmsgs(mps) {
			if (typeof (mps) === "undefined")
				return "-";

			var sizes = ['msg/s', 'Kmsg/s', 'Msg/s', 'Gmsg/s', 'Tmsg/s'];
			if (mps == 0) return '0';
			if ((mps > 0) && (mps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' mps');
			var res = NtopUtils$1.scaleValue(mps, sizes, 1000);

			// Round to two decimal digits
			return Math.round(res[0] * 100) / 100 + ' ' + res[1];
		}

		static fmillis(ms) {

			if (ms === undefined) return '-';
			const sizes = ['ms'];
			const res = NtopUtils$1.scaleValue(ms, sizes, 1000);
			return Math.round(res[0] * 100) / 100 + ' ' + res[1];
		}

		static fnone(val) {

			if (val === undefined) return '-';
			return Math.round(val * 100) / 100;
		}

		static falerts(aps) {
			if (typeof (aps) === "undefined")
				return "-";

			// Round to two decimal digits
			return Math.round(aps * 100) / 100 + ' alerts/s';
		}

		static fint(value) {
			if (typeof (value) === "undefined")
				return "-";

			var x = Math.round(value);
			return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
		}

		static ffloat(value) {
			if (typeof (value) === "undefined")
				return "-";

			var x = Math.round(value * 100) / 100.;
			return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
		}

		static fpercent(value) {
			if (typeof (value) === "undefined")
				return "-";

			return Math.round(value * 100) / 100 + "%";
		}

		static fdate(when) {
			var epoch = when * 1000;
			var d = new Date(epoch);

			return (d);
		}

		static capitaliseFirstLetter(string) {
			return string.charAt(0).toUpperCase() + string.slice(1);
		}

		static get_trend(actual, before) {
			if ((actual === undefined) || (before === undefined) || (actual == before)) {
				return ("<i class=\"fas fa-minus\"></i>");
			} else if (actual > before) {
				return ("<i class=\"fas fa-arrow-up\"></i>");
			} else {
				return ("<i class=\"fas fa-arrow-down\"></i>");
			}
		}

		static abbreviateString(str, len) {
			if (!str)
				return "";
			if (str.length < len)
				return str;
			return str.substring(0, len) + "...";
		}

		static toFixed2(num) {
			if (!num) return "";
			return num.toFixed(2);
		}

		// Convert bytes to human readable format
		static bytesToSize(bytes) {
			if (typeof (bytes) === "undefined")
				return "-";

			var precision = 2;
			var kilobyte = 1024;
			var megabyte = kilobyte * 1024;
			var gigabyte = megabyte * 1024;
			var terabyte = gigabyte * 1024;

			if ((bytes >= 0) && (bytes < kilobyte))
				return parseFloat(bytes.toFixed(precision)) + " Bytes";
			else if ((bytes >= kilobyte) && (bytes < megabyte))
				return parseFloat((bytes / kilobyte).toFixed(precision)) + ' KB';
			else if ((bytes >= megabyte) && (bytes < gigabyte))
				return parseFloat((bytes / megabyte).toFixed(precision)) + ' MB';
			else if ((bytes >= gigabyte) && (bytes < terabyte))
				return parseFloat((bytes / gigabyte).toFixed(precision)) + ' GB';
			else if (bytes >= terabyte)
				return parseFloat((bytes / terabyte).toFixed(precision)) + ' TB';
			else
				return parseFloat(bytes.toFixed(precision)) + ' Bytes';
		}

		static drawTrend(current, last, withColor) {
			if (current == last) {
				return ("<i class=\"fas fa-minus\"></i>");
			} else if (current > last) {
				return ("<i class=\"fas fa-arrow-up\"" + withColor + "></i>");
			} else {
				return ("<i class=\"fas fa-arrow-down\"></i>");
			}
		}

		static toggleAllTabs(enabled) {
			if (enabled === true)
				$("#historical-tabs-container").find("li").removeClass("disabled").find("a").attr("data-toggle", "tab");
			else
				$("#historical-tabs-container").find("li").addClass("disabled").find("a").removeAttr("data-toggle");
		}

		static disableAllDropdownsAndTabs() {
			$("select").each(function () {
				$(this).prop("disabled", true);
			});
			NtopUtils$1.toggleAllTabs(false);
		}

		static enableAllDropdownsAndTabs() {
			$("select").each(function () {
				$(this).prop("disabled", false);
			});
			NtopUtils$1.toggleAllTabs(true);
		}

		static capitalize(s) {
			return s && s[0].toUpperCase() + s.slice(1);
		}

		static addCommas(nStr) {
			nStr += '';
			var x = nStr.split('.');
			var x1 = x[0];
			var x2 = x.length > 1 ? '.' + x[1] : '';
			var rgx = /(\d+)(\d{3})/;
			while (rgx.test(x1)) {
				x1 = x1.replace(rgx, '$1' + ',' + '$2');
			}
			return x1 + x2;
		}

		static scaleValue(val, sizes, scale, decimals) {
			if (val == 0) return [0, sizes[0]];
			let factor = decimals ? (10 * decimals) : 10;

			var i = parseInt(Math.floor(Math.log(val) / Math.log(scale)));
			if (i < 0 || isNaN(i)) {
				i = 0;
			} else if (i >= sizes.length) {
				i = sizes.length - 1;
			}

			return [Math.round((val / Math.pow(scale, i)) * factor) / factor, sizes[i]];
		}

		static formatValue(val, decimals) {
			var sizes = ['', 'K', 'M', 'G', 'T'];
			if (val == 0) return '0';
			if ((val > 0) && (val < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE);
			if (decimals == undefined) decimals = 0;
			var res = NtopUtils$1.scaleValue(val, sizes, 1000, decimals);

			return res[0] + res[1];
		}

		static formatPackets(n) {
			return (NtopUtils$1.addCommas(n.toFixed(0)) + " Pkts");
		}

		static bytesToVolume(bytes) {
			var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
			if (bytes == 0) return '0 Bytes';
			if ((bytes > 0) && (bytes < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + " Bytes");
			var res = NtopUtils$1.scaleValue(bytes, sizes, 1024);

			return parseFloat(res[0]) + " " + res[1];
		};

		static bytesToVolumeAndLabel(bytes) {
			var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
			if (bytes == 0) return '0 Bytes';
			var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
			return [(bytes / Math.pow(1024, i)).toFixed(2), sizes[i]];
		};

		static bitsToSize(bits, factor) {
			factor = factor || 1000;
			var sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'];
			if (bits == 0) return '0 bps';
			if ((bits > 0) && (bits < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + " bps");
			var res = NtopUtils$1.scaleValue(bits, sizes, factor);

			return res[0].toFixed(2) + " " + res[1];
		};

		static secondsToTime(seconds) {

			if (seconds < 1) {
				return ("< 1 sec")
			}

			let days = Math.floor(seconds / 86400);
			let hours = Math.floor((seconds / 3600) - (days * 24));
			let minutes = Math.floor((seconds / 60) - (days * 1440) - (hours * 60));
			let sec = seconds % 60;
			let msg = "", msg_array = [];

			if (days > 0) {
				let years = Math.floor(days / 365);

				if (years > 0) {
					days = days % 365;

					msg = years + " year";
					if (years > 1) {
						msg += "s";
					}

					msg_array.push(msg);
					msg = "";
				}
				msg = days + " day";
				if (days > 1) { msg += "s"; }
				msg_array.push(msg);
				msg = "";
			}

			if (hours > 0) {
				if (hours < 10) { msg = "0"; }
				msg += hours + ":";
			}

			if (minutes < 10) { msg += "0"; }
			msg += minutes + ":";
			if (sec < 10) { msg += "0"; }
			msg += sec;
			msg_array.push(msg);

			return msg_array.join(", ")
		}

		static msecToTime(msec) {
			if (msec >= 1000) {
				return NtopUtils$1.secondsToTime(msec/1000);
			} else {
			        var x = Math.round(msec * 1000) / 1000.;
			        return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",") + " ms";
			}
		}

		static epoch2Seen(epoch) {
			/* 08/01/13 15:12:37 [18 min, 13 sec ago] */
			var d = new Date(epoch * 1000);
			var tdiff = Math.floor(((new Date()).getTime() / 1000) - epoch);

			return (d.format("dd/MM/yyyy hh:mm:ss") + " [" + NtopUtils$1.secondsToTime(tdiff) + " ago]");
		}

		/* ticks for graph x axis */
		static graphGetXAxisTicksFormat(diff_epoch) {
			var tickFormat;

			if (diff_epoch <= 86400) {
				tickFormat = "%H:%M:%S";
			} else if (diff_epoch <= 2 * 86400) {
				tickFormat = "%b %e, %H:%M:%S";
			} else {
				tickFormat = "%b %e";
			}

			return (tickFormat);
		}

		static paramsExtend(defaults, override) {
			return $.extend({}, defaults, override);
		}

		static paramsToForm(form, params) {
			form = $(form);

			for (var k in params) {
				if (params.hasOwnProperty(k)) {
					var input = $('<input type="hidden" name="' + k + '" value="' + params[k] + '">');
					input.appendTo(form);
				}
			}

			return form;
		}

		/*
		 * This function creates a javascript object where each k->v pair of the input object
		 * translates into two pairs in the output object: a key_[i]->k and a val_[i]->v, where
		 * i is an incremental index.
		 *
		 * The output object can then be serialized to an URL. This conversion is required for
		 * handling special characters: since ntopng strips special characters in _GET keys,
		 * _GET values must be used.
		 *
		 * This function performs the inverse conversion of lua paramsPairsDecode.
		 *
		 */
		static paramsPairsEncode(params) {
			var i = 0;
			var res = {};

			for (var k in params) {
				res["key_" + i] = k;
				res["val_" + i] = params[k];
				i = i + 1;
			}

			return res;
		}

		static hostkey2hostInfo(host_key) {
			var info;

			host_key = host_key.replace(/____/g, ":");
			host_key = host_key.replace(/___/g, "/");
			host_key = host_key.replace(/__/g, ".");

			info = host_key.split("@");
			return (info);
		}

		static handle_tab_state(nav_object, default_tab) {
			$('a', nav_object).click(function (e) {
				e.preventDefault();
			});

			// store the currently selected tab in the hash value
			$(" > li > a", nav_object).on("shown.bs.tab", function (e) {
				var id = $(e.target).attr("href").substr(1);
				if (history.replaceState) {
					// this will prevent the 'jump' to the hash
					history.replaceState(null, null, "#" + id);
				} else {
					// fallback
					window.location.hash = id;
				}
			});

			// on load of the page: switch to the currently selected tab
			var hash = window.location.hash;
			if (!hash) hash = "#" + default_tab;
			$('a[href="' + hash + '"]', nav_object).tab('show');
		}

		static _add_find_host_link(form, name, data) {
			$('<input>').attr({
				type: 'hidden',
				id: name,
				name: name,
				value: data,
			}).appendTo(form);
		}

		/* Used while searching hosts a and macs with typeahead */
		static makeFindHostBeforeSubmitCallback(http_prefix) {
			return function (form, data) {
				if (data.context && data.context == "historical") {
					form.attr("action", http_prefix + "/lua/pro/db_search.lua");
					if (data.type == "ip") {
						NtopUtils$1._add_find_host_link(form, "ip", data.ip);
					} else if (data.type == "mac") {
						NtopUtils$1._add_find_host_link(form, "mac", data.mac);
					} else /* "hostname" */ {
						NtopUtils$1._add_find_host_link(form, "name", data.hostname ? data.hostname : data.name);
					}
				} else {
					if (data.type == "mac") {
						form.attr("action", http_prefix + "/lua/mac_details.lua");
					} else if (data.type == "network") {
						form.attr("action", http_prefix + "/lua/hosts_stats.lua");
						NtopUtils$1._add_find_host_link(form, "network", data.network);
					} else if (data.type == "snmp") {
						form.attr("action", http_prefix + "/lua/pro/enterprise/snmp_interface_details.lua");
						NtopUtils$1._add_find_host_link(form, "snmp_port_idx", data.snmp_port_idx);
					} else if (data.type == "snmp_device") {
						form.attr("action", http_prefix + "/lua/pro/enterprise/snmp_device_details.lua");
					} else if (data.type == "asn") {
						form.attr("action", http_prefix + "/lua/hosts_stats.lua");
						NtopUtils$1._add_find_host_link(form, "asn", data.asn);
					} else {
						form.attr("action", http_prefix + "/lua/host_details.lua");
						NtopUtils$1._add_find_host_link(form, "mode", "restore");
					}
				}

				return true;
			}
		}

		static tstampToDateString(html_tag, format, tdiff) {
			tdiff = tdiff || 0;
			var timestamp = parseInt(html_tag.html()) + tdiff;
			var localized = d3.time.format(format)(new Date(timestamp * 1000));
			html_tag.html(localized).removeClass("hidden");
			return localized;
		}

		static noHtml(s) {
			return s.replace(/<[^>]+>/g, '');
		}

		static cleanCustomHostUrl(host) {
			/* Remove starting http(s). */
			return host
				.replace(/^http:\/\//gi, '')
				.replace(/^https:\/\//gi, '')
				/* Remove starting www. */
				.replace(/^www\./gi, '')
				/* Remove non-allowed characters */
				.replace(/[^0-9a-zA-Z\.:\/_-]/gi, '');
		}

		/* https://stackoverflow.com/questions/2090551/parse-query-string-in-javascript */
		static parseQuery(queryString) {
			var query = {};
			var pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
			for (var i = 0; i < pairs.length; i++) {
				var pair = pairs[i].split('=');
				query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
			}
			return query;
		}

		static getHistoryParameters(params) {
			var cur_params = NtopUtils$1.parseQuery(window.location.search);
			var new_params = $.extend(cur_params, params);
			var new_query = "?" + $.param(new_params, true);
			var baseUrl = [location.protocol, '//', location.host, location.pathname].join('');

			return baseUrl + new_query;
		}

		// return true if the status code is different from 200
		static check_status_code(status_code, status_text, $error_label) {

			const is_different = status_code != 200;

			if (is_different && $error_label != null) {

				let message = i18n_ext.request_failed_message;
				if (status_code && status_text) {
					message += `: ${status_code} - ${status_text}`;
				}

				$error_label.text(message).show();
			}
			else if (is_different && $error_label == null) {
				alert(`${i18n_ext.request_failed_message}: ${status_code} - ${status_text}`);
			}

			return is_different;
		}

		// To be used in conjunction with httpdocs/templates/config_list_components/import_modal.html
		static importModalHelper(params) {

			if (!params.loadConfigXHR) { throw ("importModalHelper:: Missing 'loadConfigXHR' param"); }

			$(`input#import-input`).on('change', function () {
				$(this).val().replace("C:\\fakepath\\", "");
				$(`#btn-confirm-import`).removeAttr("disabled");
			});

			$(`#import-modal`).on('hidden.bs.modal', function () {
				$(`#import-input`).val('');
				$("#import-error").hide().removeClass('text-warning').addClass('invalid-feedback');
				$(`#btn-confirm-import`).attr("disabled", "disabled");
			});

			$("#import-modal").on("submit", "form", function (e) {

				e.preventDefault();

				const $button = $('#btn-confirm-import');
				$button.attr("disabled", "");

				// read configuration file
				const file = $('#import-input')[0].files[0];

				if (!file) {
					$("#import-error").text(`${i18n_ext.no_file}`).show();
					$button.removeAttr("disabled");
					return;
				}

				const reader = new FileReader();
				reader.readAsText(file, "UTF-8");

				reader.onload = function () {
					// Client-side configuration file format check
					let jsonConfiguration = null;
					try { jsonConfiguration = JSON.parse(reader.result); } catch (e) { }

					if (!jsonConfiguration) {
						$("#import-error").text(i18n_ext.rest_consts[responseJSON.rc_str] || 'Not Implemented Yet').show();
						$button.removeAttr("disabled");
						return;
					}

					// Submit configuration file
					params.loadConfigXHR(reader.result)
						.done((response, status, xhr) => {

							if (response.rc < 0) {
								$("#import-error").text(response.rc_str).show();
								return;
							}

							// if the operation was successful call the successCallback
							if (params.successCallback) {
								params.successCallback(response);
							}

						        const key = $(`input[name='configuration']:checked`).val();

						        const body = (key == 'all')
						                ? i18n_ext.manage_configurations.messagges.import_all_success
								: i18n_ext.manage_configurations.messagges.import_success;

							// show a success alert message
							ToastUtils.showToast({
								id: 'import-configuration-alert',
								level: 'success',
								title: i18n_ext.success,
								body: body,
								delay: 2000
							});

							$("#import-modal").modal('hide');

						})
						.fail(({ responseJSON }) => {

							const PARTIAL_IMPORT_RC = -28;

							if (params.failureCallback) {
								params.failureCallback(responseJSON);
							}

							if (responseJSON && responseJSON.rc > 0) return;
							if (responseJSON.rc == PARTIAL_IMPORT_RC)
								$(`#import-error`).removeClass('invalid-feedback').addClass('text-warning');

							$("#import-error").text(i18n_ext.rest_consts[responseJSON.rc_str] || i18n_ext.FAILED_HTTP_REQUEST).show();

						})
						.always(() => {
							$button.removeAttr("disabled");
						});
				};
			});
		}

		static serializeFormArray(serializedArray) {
			const serialized = {};
			serializedArray.forEach((obj) => {
				/* if the object is an array  */
				if (obj.name.includes('[]')) {
					return;
				}
				else {

					// clean the string
					if (typeof obj.value === "string") {
						obj.value = obj.value.trim();
					}
					serialized[obj.name] = obj.value;
				}
			});
			return serialized;
		}

		static cleanForm(formSelector) {
			/* remove validation fields and tracks */
			$(formSelector).find('input,select,textarea').each(function (i, input) {
				$(this).removeClass(`is-valid`).removeClass(`is-invalid`);
			});
			/* reset all the values */
			$(formSelector)[0].reset();
		}

		/**
		 * Make a fetch call with a timeout option
		 */
		static fetchWithTimeout(uri, options = {}, time = 5000) {

			const controller = new AbortController();
			const config = { ...options, signal: controller.signal };
			setTimeout(() => {
				controller.abort();
			}, time);

			return fetch(uri, config)
				.then((response) => {
					if (!response.ok) {
						throw new Error(`${response.status}: ${response.statusText}`)
					}
					return response
				})
				.catch((error) => {
					if (error.name === 'AbortError') {
						throw new Error('Response timed out')
					}
				})
		}

		static setPref(action, csrf, success, failure) {

			if (action == undefined) {
				console.warn("An action key must be defined to set a preference!");
				return;
			}

			const empty = () => { };
			const request = $.post(`${http_prefix}/lua/update_prefs.lua`, { action: action, csrf: csrf });
			request.done(success || empty);
			request.fail(failure || empty);
		}

		/**
		 * Glue strings contained in array separated by a comma.
		 * @param {array} array The array of strings. I.e. ["Hello", "World"]
		 * @param {number} limit How many words the string contains
		 *
		 * @return {string} A string built by array's elements. i.e: "Hello, World"
		 */
		static arrayToListString(array, limit) {

			if (array == undefined) return "";

			if (array.length > limit) {
				return array.slice(0, limit).join(", ") + ` ${i18n_ext.and_x_more.replace('$num', array.length - limit)}`;
			}

			return array.slice(0, limit).join(", ");
		}

		static buildURL(location, params = {}, hasReferer = false, refererParams = {}) {

			const url = new URL(location, window.location);

			for (const [name, value] of Object.entries(params)) {
	      if (value || value === 0)
				  url.searchParams.set(name, value);
				continue;
			}

			if (hasReferer) {

				const refUrl = new URL(window.location.href);
				for (const [name, value] of Object.entries(refererParams)) {
					if (!value) continue;
					refUrl.searchParams.set(name, value);
				}

				url.searchParams.set('referer', refUrl.toString());
			}

			return url.toString();
		}

		static getEditPoolLink(href, poolId) {
			const url = new URL(href, window.location);
			url.searchParams.set('pool_id', poolId);
			return url.toString();
		}

		static getPoolLink(poolType, poolId = 0) {
			return `${http_prefix}/lua/rest/v2/get/${poolType}/pools.lua?pool=${poolId}`;
		}

		static async getPool(poolType, id = 0) {

			if (poolType === null) throw 'A pool type must be defined!';

			try {

				const request = await fetch(NtopUtils$1.getPoolLink(poolType, id));
				const pool = await request.json();

				if (pool.rc < 0) {
					return [false, {}];
				}

				return [true, pool.rsp[0]];
			}
			catch (err) {
				return [false, {}];
			}
		}

		/**
		 * Save the scale of element inside the local storage
		 * @param {object} $element 
		 * @param {object} scale
		 */
		static saveElementScale($element, scale = {width: 0, height: 0}) {
			
			const key = NtopUtils$1.generateScaleElementKey($element);
			localStorage.setItem(key, JSON.stringify(scale));
		}

		static generateScaleElementKey($element) {
			let identificator;
			const page = location.pathname;
			const elementId = $element.attr('id');

			if (elementId !== "") {
				identificator = elementId;
			}
			else {
				const className = $element.attr('class');
				identificator = className;
			}

			const key = `${identificator}-${page}-scale`;
			return key;
		}

		/**
		 * Load the old scale value ofx element from the local storage
		 * @param {object} $element 
		 */
		static loadElementScale($element) {

			const key = NtopUtils$1.generateScaleElementKey($element);
			const currentValue = localStorage.getItem(key);
			if (currentValue == null) return undefined;

			return JSON.parse(currentValue);
		}

		static fillFieldIfValid($field, value) {

			if (value === undefined) {
				$field.val('');
			}
			else {
				$field.val(value);
			}

		}

		static copyToClipboard(text, item) {
	    const el = document.createElement('textarea');
	    el.value = text;
	    el.setAttribute('readonly', '');
	    el.style.position = 'absolute';
	    el.style.left = '-9999px';
	    document.body.appendChild(el);
	    el.select();
	    document.execCommand('copy');
	    document.body.removeChild(el);
	    $(item).attr("title", "Copied!").tooltip("dispose").tooltip().tooltip("show");
	    $(item).removeAttr("data-bs-original-title");
	    $(item).attr("title", text);
		}

		static stripTags(html) {
	        	let t = document.createElement("div");
			t.innerHTML = html;
			return t.textContent || t.innerText || "";
		}

	  static shortenLabel(label, len, last_char) {
	    let shortened_label = label;
	    if(label.length > len + 5) {
	      let last_index = len;
	      if(last_char) {
	        last_index = label.lastIndexOf(last_char);
	        const requested_label = label.slice(last_index);
	        if(len > last_index) 
	          len = last_index;
	        shortened_label = label.slice(0, len) + "... " + requested_label;
	      } else {
	        shortened_label = label.slice(0, len) + "...";
	      }
	    }

	    return shortened_label
	  }
		
	  static sortAlphabetically(a, b) {
	    const nameA = a.label.toUpperCase(); // ignore upper and lowercase
	    const nameB = b.label.toUpperCase(); // ignore upper and lowercase
	    if (nameA < nameB) { return -1; }
	    if (nameA > nameB) { return 1; }
	    return 0;
	  }

	  static createProgressBar(percentage) {
	    return `<div class="d-flex flex-row">
              <div class="col-9 progress">
                <div class="progress-bar bg-warning" aria-valuenow="${percentage}" aria-valuemin="0" aria-valuemax="100" style="width: ${percentage}%;">
                </div>
              </div>
              <div class="col ms-3"> ${percentage} %</div>
            </div>`
	  }

	  static createBreakdown(percentage_1, percentage_2, label_1, label_2) {
	    return `<div class="d-flex flex-row">
              <div class="col-12 progress">
                <div class="progress-bar bg-warning" aria-valuenow="${percentage_1}" aria-valuemin="0" aria-valuemax="100" style="width: ${percentage_1}%;">${label_1}</div>
                <div class="progress-bar bg-success" aria-valuenow="${percentage_2}" aria-valuemin="0" aria-valuemax="100" style="width: ${percentage_2}%;">${label_2}</div>
              </div>
            </div>`
	  }
	}

	$(function () {
		// if there are inputs with 'pattern' data attribute
		// then initialize them
		NtopUtils$1.initDataPatterns();
	});

	// 2016-19 - ntop.org

	function datatableRemoveEmptyRow(table) {
	  $("tbody tr.emptyRow", $(table)).remove();
	}

	function datatableAddEmptyRow(table, empty_str) {
	  var columns = $("thead th", $(table)).filter(function() {
	   return $(this).css('display') != 'none';
	  }).length;
	  $("tbody", $(table)).html('<tr class="emptyRow"><td colspan="' + columns + '"><i>' + empty_str + '</i></td></tr>');
	}

	function datatableGetNumDisplayedItems(table) {
	   return $("tr:not(.emptyRow)", $(table)).length - 1;
	}

	function datatableIsEmpty(table) {
	  return datatableGetNumDisplayedItems(table) == 0;
	}

	function datatableGetByForm(form) {
	  return $("table", $("#dt-top-details", $(form)).parent())
	}

	function datatableUndoAddRow(new_row, empty_str, bt_to_enable, callback_str) {
	  if (bt_to_enable)
	     $(bt_to_enable).removeAttr("disabled").removeClass("disabled");

	  var form = $(new_row).closest("form");
	  $(new_row).remove();
	  aysUpdateForm(form);
	  var dt = datatableGetByForm(form);

	  if (datatableIsEmpty(dt))
	     datatableAddEmptyRow(dt, empty_str);

	   if (callback_str)
	      // invoke
	      window[callback_str](new_row);
	}

	function datatableForEachRow(table, callbacks) {
	   $("tr:not(:first)", table).each(function(row_i) {
	      if(typeof callbacks === 'function') {
	         callbacks.bind(this)(row_i);
	      } else {
	         var i;
	         for (i=0; i<callbacks.length; i++)
	            callbacks[i].bind(this)(row_i);
	      }
	   });
	}

	function datatableAddButtonCallback(td_idx, label, bs_class, callback_str, link, visible = true, title = '') {
	   if ($("td:nth-child("+td_idx+")", $(this)).find('div.d-flex').length == 0) {
	      $("td:nth-child("+td_idx+")", $(this)).empty();
	      $("td:nth-child("+td_idx+")", $(this)).append($("<div class='d-flex justify-content-center'></div>"));
	   }
	   $("td:nth-child("+td_idx+")", $(this)).find('.d-flex').append('<a href="' + link + `" title='${title}' data-placement="bottom" class="btn btn-sm mx-1 ${bs_class} ${!visible ? 'disabled' : ''}" onclick="` + callback_str + '" role="button">' + label + '</a>');
	}

	function datatableAddDeleteButtonCallback(td_idx, callback_str, label) {
	    datatableAddButtonCallback.bind(this)(td_idx, label, "btn-danger", callback_str, "javascript:void(0)", true, 'Delete');
	}

	function datatableAddActionButtonCallback(td_idx, callback_str, label, visible = true, title = '') {
	    datatableAddButtonCallback.bind(this)(td_idx, label, "btn-info", callback_str, "javascript:void(0)", visible, title);
	}
	    
	function datatableAddFilterButtonCallback(td_idx, callback_str, label, title = '', visible = true) {
	    datatableAddButtonCallback.bind(this)(td_idx, label, "btn-warning", callback_str, "javascript:void(0)", visible, title);
	}

	function datatableAddLinkButtonCallback(td_idx, link, label, title = '') {
	   datatableAddButtonCallback.bind(this)(td_idx, label, "btn-info", "", link, true, title);
	}

	function datatableMakeSelectUnique(tr_obj, added_rows_prefix, options) {
	   options = NtopUtils.paramsExtend({
	      on_change: $.noop,                     /* A callback to be called when the select input changes */
	      selector_fn: function(obj) {           /* A callback which receives a tr object and returns a single select input */
	         return obj.find("select").first();
	      },
	   }, options);

	   function datatableForeachSelectOtherThan(this_select, added_rows_prefix, selector_fn, callback) {
	      $("[id^=" + added_rows_prefix + "]").each(function(){
	         var other = selector_fn($(this));
	         if (other[0] != this_select[0])
	            callback(other);
	      });
	   }

	   function datatableOptionChangeStatus(option_obj, enable) {
	      if (enable) {
	         option_obj.removeAttr("disabled");
	      } else {
	         var select_obj = option_obj.closest("select");
	         var should_reset = (select_obj.val() == option_obj.val());
	         option_obj.attr("disabled", "disabled");

	         if(should_reset) {
	            var new_val = select_obj.find("option:not([disabled])").first().val();
	            select_obj.val(new_val);
	            select_obj.attr("data-old-val", new_val);
	         }
	      }
	   }

	   function datatableOnSelectEntryChange(added_rows_prefix, selector_fn, change_callback) {
	      var old_value = $(this).attr("data-old-val") || "";
	      var new_value = $(this).val() || "";
	      var others = [];

	      if (old_value == new_value)
	         old_value = "";

	      datatableForeachSelectOtherThan($(this), added_rows_prefix, selector_fn, function(other) {
	         datatableOptionChangeStatus(other.find("option[value='" + old_value + "']"), true);
	         datatableOptionChangeStatus(other.find("option[value='" + new_value + "']"), false);
	         others.push(other);
	      });

	      change_callback($(this), old_value, new_value, others, datatableOptionChangeStatus);

	      $(this).attr("data-old-val", new_value);
	   }

	   function datatableOnAddSelectEntry(select_obj, added_rows_prefix, selector_fn) {
	      select_obj.val("");

	      // Trigger an update on other inputs in order to disable entries on the select_obj
	      datatableForeachSelectOtherThan(select_obj, added_rows_prefix, selector_fn, function(other) {
	         //datatableOptionChangeStatus(select_obj.find("option[value='" + other.val() + "']"), false);
	         other.trigger("change");
	      });

	      // select first available entry
	      var new_sel = select_obj.find("option:not([disabled])").first();
	      var new_val = new_sel.val();

	      // trigger change event to update other entries
	      select_obj.val(new_val);
	      select_obj.trigger("change");
	   }

	   var select = options.selector_fn(tr_obj);
	   select.on("change", function() { datatableOnSelectEntryChange.bind(this)(added_rows_prefix, options.selector_fn, options.on_change); });
	   select.on("remove", function() {$(this).val("").trigger("change");});
	   datatableOnAddSelectEntry(select, added_rows_prefix, options.selector_fn);
	}

	function datatableIsLastPage(table) {
	   var lastpage = $("#dt-bottom-details .pagination li:nth-last-child(3)", $(table));
	   return !((lastpage.length == 1) && (lastpage.hasClass("active") == false));
	}

	function datatableGetColumn(table, id_key, id_value) {
	   var res = table.data("datatable").resultset.data.filter(function(item) {
	      return item[id_key] === id_value;
	   });

	   if(res) return res[0];
	}

	function datatableGetColumnIndex(table, column_key) {
	   var index = table.data("datatable").options.columns.findIndex(function(item) {
	      return item.field === column_key;
	   });

	   return(index);
	}

	/*
	 * Helper function to add refreshable datatables rows.
	 *
	 * table: the datatable div jquery object
	 * column_id: the field key used to indentify the rows
	 * refresh_interval: milliseconds refresh interval for this table
	 * trend_columns: (optional) a map <field -> formatter_fn> which indicates the numeric columns
	 * which should be shown with up/down arrows upon refresh.
	 *
	 * Returns true on success, false otherwise.
	 *
	 * Example usage:
	 *   $("#table-redis-stats").datatable({
	 *     ...
	 *     tableCallback: function() {
	 *       // The table rows will be identified by the "column_key",
	 *       // refreshed every 5 seconds, with up/down arrows on the "column_hits"
	 *       datatableInitRefreshRows($("#table-redis-stats"), "column_key", 5000, {"column_hits": addCommas});
	 *     }
	 *   });
	 */
	function datatableInitRefreshRows(table, column_id, refresh_interval, trend_columns) {
	  var $dt = table.data("datatable");
	  var rows = $dt.resultset.data;
	  var old_timer = table.data("dt-rr-timer");
	  var old_req = table.data("dt-rr-ajax");
	  trend_columns = trend_columns || {};

	  if(old_timer) {
	    // Remove the previously set timer to avoid double scheduling
	    clearInterval(old_timer);
	    table.removeData("dt-rr-timer");
	  }

	  if(old_req) {
	    // Abort the previous request if any
	    old_req.abort();
	    table.removeData("dt-rr-ajax");
	  }

	  var ids = [];
	  var id_to_row = {};

	  for(var row in rows) {
	    var data = rows[row];

	    if(data[column_id]) {
	      var data_id = data[column_id];
	      id_to_row[data_id] = row;
	      ids.push(data_id);
	    }
	  }

	  if(!ids)
	    return(false);

	  // These parameters will be passed to the refresh endpoint
	  // the custom_hosts parameter will be passed in the AJAX request and
	  // will contain the IDs to refresh. It should be used by the receiving
	  // Lua script as a filter
	  var params = {
	    "custom_hosts": ids.join(",")
	  };
	  var url = $dt.options.url;
	  var first_load = true;

	  var _process_result = function(result) {
	    if(typeof(result) === "string")
	      result = JSON.parse(result);

	    if(!result) {
	      console.error("Bad JSON result");
	      return;
	    }

	    for(var row in result.data) {
	       var data = result.data[row];
	       var data_id = data[column_id];

	       if(data_id && id_to_row[data_id]) {
	          var row_idx = id_to_row[data_id];
	          var row_html = $dt.rows[row_idx];
	          var row_tds = $("td", row_html);

	          /* Try to update all the fields for the current row (row_html) */
	          for(var key in data) {
	             var col_idx = datatableGetColumnIndex(table, key);
	             var cell = row_tds[col_idx];
	             var $cell = $(cell);

	             var old_val = $cell.data("dt-rr-cur-val") || $(cell).html();
	             var trend_value_formatter = trend_columns[key];
	             var new_val = data[key];
	             var arrows = "";

	             if(trend_value_formatter) {
	              if(parseFloat(new_val) != new_val)
	                console.warn("Invalid number: " + new_val);

	              if(!first_load)
	                arrows = " " + NtopUtils.drawTrend(parseFloat(new_val), parseFloat(old_val));

	              // This value will be neede in the next refresh
	              $cell.data("dt-rr-cur-val", new_val);

	              new_val = trend_value_formatter(new_val);
	            }

	             $(cell).html((new_val != 0) ? (new_val + arrows) : "");
	          }
	       }
	    }

	    first_load = false;
	    table.removeData("dt-rr-ajax");
	 };

	  // Save the timer into "dt-rr-timer" to be able to stop it if
	  // datatableInitRefreshRows is called again
	  table.data("dt-rr-timer", setInterval(function() {
	    // Double check that a request is not pending
	    var old_req = table.data("dt-rr-ajax");

	    if(old_req)
	      return;

	    // Save the ajax request to possibly abort it if
	    // datatableInitRefreshRows is called again
	    table.data("dt-rr-ajax", $.ajax({
	       type: 'GET',
	       url: url,
	       data: params,
	       cache: false,
	       success: _process_result,
	    }));
	  }, refresh_interval));

	  // First update
	  _process_result($dt.resultset);
	}

	function draw_processes_graph(http_prefix, graph_div_id, host) {
	    var links;
	    var nodes = {};

	    var url = http_prefix + '/lua/get_processes_graph_data.lua?host=' + host;

	    d3.json(url, function(error, json) {
		if(error)
		    return console.warn(error);

		links = json;
		var _link;

		// Compute the distinct nodes from the links.
		links.forEach(function(link) {
		    if(link.source_pid == -1) {
			/* IP Address -> PID */
			_link = http_prefix + "/lua/host_details.lua?host=" + link.source;
		    } else {
			/* PID -> IP Address */
			_link = http_prefix + "/lua/process_details.lua?pid=" + link.source_pid + "&pid_name=" + link.source_name + "&host=" + host + "&page=flows";
		    }

		    link.source = nodes[link.source]
			|| (nodes[link.source] = {
			    name: link.source_name, num:link.source,
			    link: _link, type: link.source_type, pid: link.source_pid
			});

		    if(link.target_pid == -1) {
			/* IP Address -> PID */
			_link = http_prefix + "/lua/host_details.lua?host=" + link.target;
		    } else {
			/* PID -> IP Address */
			_link = http_prefix + "/lua/process_details.lua?pid=" + link.target_pid + "&pid_name=" + link.target_name + "&host=" + host + "&page=flows";
		    }

		    link.target = nodes[link.target]
			|| (nodes[link.target] = {
			    name: link.target_name, num: link.target,
			    link: _link, type: link.target_type, pid: link.target_pid
			});
		});

		var width = 960, height = 500, arrow_size = 6;
		var color = d3.scale.category10();

		/* Same colors as those used in the flow_details.lua page to represent hosts and processes */
		color["proc"] = "red";
		color["host"] = "lightsteelblue";

		var force = d3.layout.force()
		    .nodes(d3.values(nodes))
		    .links(links)
		    .size([width, height])
		    .linkDistance(120) // Arc length
		    .charge(-400)
		    .on("tick", tick)
		    .start();

		var svg = d3.select("#" + graph_div_id).append("svg")
		    .attr("id", "ebpf_graph")
		    .attr("width", width)
		    .attr("height", height);

		// Per-type markers, as they don't inherit styles.
		svg.append("defs").selectAll("marker")
		    .data(["proc2proc", "proc2host", "host2proc", "host2host"])
		    .enter().append("marker")
		    .attr("id", function(d) { return d; })
		    .attr("viewBox", "0 -5 20 20")
		    .attr("refX", 15)
		    .attr("refY", -1.5)
		    .attr("markerWidth", arrow_size).attr("markerHeight", arrow_size)
		    .attr("orient", "auto")
		    .append("path")
		    .attr("d", "M0,-5L10,0L0,5");

		var path = svg.append("g").selectAll("path")
		    .data(force.links())
		    .enter().append("path")
		    .attr("class", function(d) { return "link " + d.type; })
		    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });


		var circle = svg.append("g").selectAll("circle")
		    .data(force.nodes())
		    .enter().append("circle")
		    .attr("class", "ebpf_circle")
		    .attr("r", 15) /* Radius */
		    .style("fill", function(d) { return color[d.type]; })
		    .call(force.drag)
		    .on("dblclick", function(d) {
			window.location.href = d.link;
		    } );

		// Circle label
		var text = svg.append("g").selectAll("text")
		    .data(force.nodes())
		    .enter().append("text")
		    .attr("class", "ebpf_text")
		    .attr("x", 12)
		    .attr("y", "0.5rem")
	      .style("font-size", "1rem")
		    .text(function(d) {
			if(d.pid >= 0) // Process
			    return(d.name + " [pid: "+d.pid+"]");
			else { // Host
			    return(d.name);
			}
		    });

		// Use elliptical arc path segments to doubly-encode directionality.
		function tick() {
		    path.attr("d", linkArc);
		    circle.attr("transform", transform);
		    text.attr("transform", transform);
		}

		function linkArc(d) {
		    var dx = d.target.x - d.source.x,
			dy = d.target.y - d.source.y,
			dr = Math.sqrt(dx * dx + dy * dy);
		    return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
		}

		function transform(d) {
		    return "translate(" + d.x + "," + d.y + ")";
		}
	    });
	}

	var ebpfUtils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		draw_processes_graph: draw_processes_graph
	});

	// 2019 - ntop.org

	(history.state) ? (history.state.zoom_level) : 0;

	/* Use with:
	  *
	  * $('#edit-recipient-modal form').modalHandler({ ... })
	  */
	class ModalHandler {

	    constructor(form, options) {

	        if (typeof options.csrf === "undefined") {
	            throw new Error("ModalHandler::Missing CSRF token!");
	        }

	        this.element = form;
	        this.dialog = $(form).closest(".modal");

	        this.options = options;
	        this.csrf = options.csrf;
	        this.dontDisableSubmit = options.dontDisableSubmit;

	        this.observer = new MutationObserver((list) => {
	            this.bindFormValidation();
	            this.toggleFormSubmission();
	            this.initDataPatterns();
	        });

	        this.observer.observe(this.element[0], {
	            childList: true,
	            subtree: true
	        });

	        this.initialState = null;
	        this.currentState = null;
	        this.firstCloseAttempt = false;
	        this.isSubmitting = false;

	        const submitButton = $(this.element).find(`[type='submit']`);
	        if (submitButton.length == 0) {
	            throw new Error("ModalHandler::The submit button was not found inside the form!");
	        }

	        this.toggleFormSubmission();

	    }

	    initDataPatterns() {
	        NtopUtils.initDataPatterns();
	    }

	    /**
	     * Create a form's snapshot to save a form state
	     */
	    createFormSnapshot() {

	        const snapshot = {
	            inputs: {},
	            hidden: []
	        };

	        $(this.element).find('textarea,select,input[type!="radio"]').each(function () {

	            const type = $(this).prop('nodeName').toLowerCase();
	            const name = $(this).attr('name');
	            snapshot.inputs[`${type}[name='${name}']`] = $(this).val();
	        });

	        $(this.element).find(`[style='display: none;'], span.invalid-feedback`).each(function () {
	            snapshot.hidden.push($(this));
	        });

	        return snapshot;
	    }

	    compareFormSnaphsot(s1, s2) {

	        if (s1 == null || s2 == null) return true;

	        for (let [key, value] of Object.entries(s1.inputs)) {
	            if (s2.inputs[key] != value) return false;
	        }

	        return true;
	    }

	    delegateModalClosing() {

	        const self = this;

	        $(this.dialog).find('button.cancel').off('click').click(function () {

	            self.firstCloseAttempt = false;
	            $(self.element)[0].reportValidity();
	            $(self.dialog).find('.confirm-closing').fadeOut(100, function () {
	                $(self.dialog).find('button.btn-close').fadeIn(100);
	            });
	        });

	        $(this.dialog).off('hide.bs.modal').on('hide.bs.modal', function (event) {
	            
	            if (self.isSubmitting) {
	                event.preventDefault();
	                return;
	            }

	            // if the form state hasn't changed then don't show the message
	            if (self.compareFormSnaphsot(self.currentState, self.initialState)) {
	                return;
	            }

	            if (self.firstCloseAttempt) return;
	            // abort the modal closing event
	            event.preventDefault();

	            // flag a close attempt has been invoked
	            self.firstCloseAttempt = true;
	            
	            // show an alert to inform the user
	            $(self.dialog).find('button.btn-close').fadeOut(100, function () {
	                $(self.dialog).find('.confirm-closing').fadeIn(100);
	            });

	            return;

	        });

	        $(this.dialog).off('hidden.bs.modal').on('hidden.bs.modal', function (event) {

	            // for each input inside the form restore the initial value
	            // from the snapshot taken at init
	            for (const [selector, value] of Object.entries(self.initialState.inputs)) {
	                $(self.dialog).find(selector).val(value);
	                $(self.dialog).find(selector).removeClass('is-invalid');
	            }

	            // hide the shwon elements
	            self.initialState.hidden.forEach(($hidden) => {
	                $hidden.hide();
	            });

	            self.element.find(`[type='submit']`).attr("disabled", "disabled");
	            self.currentState = null;
	            self.firstCloseAttempt = false;

	            $(self.dialog).find('.confirm-closing').fadeOut(100, function () {
	                $(self.dialog).find('button.btn-close').fadeIn(100);
	            });

	            // clean the form when the modal is closed
	            // to prevent the fields flickering
	            self.cleanForm();
	        });
	    }

	    fillFormModal() {
	        return this.options.loadFormData();
	    }

	    invokeModalInit(data = {}) {

	        const self = this;

	        // reset form values when the modal closes
	        this.delegateModalClosing();
	        this.data = data || this.fillFormModal();
	        this.options.onModalInit(this.data, this);

	        $(this.element).parents('.modal').on('show.bs.modal', function () {
	            self.options.onModalShow();
	        });

	        // create a initial form snapshot to restore elements on closing
	        this.initialState = this.createFormSnapshot();
	        this.currentState = null;

	        this.delegateResetButton();   
	    }

	    delegateSubmit() {

	        this.bindFormValidation();

	        const self = this;

	        this.submitHandler = function (e) {
	            if (!self.options.isSyncRequest) {
	                e.preventDefault();
	                e.stopPropagation();
	                self.makeRequest();
	            }
	        };

	        $(this.element).on('submit', this.submitHandler);
	    }

	    bindFormValidation() {

	        const self = this;

	        // handle input validation
	        $(this.element).find(`input,select,textarea`).each(async function (i, input) {

	            // jQuery object of the current input
	            const $input = $(this);
	            // id to handle the current timeout set to show errors
	            let timeoutId = -1;

	            const validHostname = async () => {

	                // show the spinner to the user and set the input to readonly
	                const $spinner = $input.parent().find('.spinner-border');
	                $input.attr("readonly", true);
	                $spinner.show();

	                const response = await NtopUtils.resolveDNS($(input).val());

	                // hide the spinner and renable write to the input
	                $input.removeAttr("readonly");
	                $spinner.hide();

	                // if the response was negative then alert the user
	                if (response.rc < 0) {
	                    input.setCustomValidity(response.rc_str);
	                    return [false, response.rc_str_hr];
	                }

	                // return success for valid resolved hostnmae
	                input.setCustomValidity("");

	                return [true, "Success"];
	            };

	            const validInput = async (validation) => {

	                // if the input require to validate host name then perform a DNS resolve
	                if (validation.data.resolveDNS && $input.val().match(NtopUtils.REGEXES.domainName)) {
	                    return await validHostname();
	                }

	                if (validation.data.cannotBeEmpty && validation.isInputEmpty) {
	                    // trigger input validation flag
	                    input.setCustomValidity("Please fill the input.");
	                    return [false, validation.data.validationEmptyMessage || i18n_ext.missing_field];
	                }

	                if (input.validity.patternMismatch) {
	                    input.setCustomValidity("Pattern mismatch.");
	                    return [false, validation.data.validationMessage || i18n_ext.invalid_field];
	                }

	                if (input.validity.rangeOverflow) {
	                    input.setCustomValidity("Value exceed the maximum value.");
	                    return [false, validation.data.rangeOverflowMessage || i18n_ext.invalid_field];
	                }

	                if (input.validity.rangeUnderflow) {
	                    input.setCustomValidity("Value is under the minimum value.");
	                    return [false, validation.data.rangeUnderflowMessage || i18n_ext.invalid_field];
	                }

	                // set validation to true
	                input.setCustomValidity("");
	                return [true, "Success"];
	            };

	            const checkValidation = async () => {

	                const validation = {
	                    data: {
	                        validationMessage: $input.data('validationMessage'),
	                        validationEmptyMessage: $input.data('validationEmptyMessage'),
	                        cannotBeEmpty: ($input.attr('required') === "required") || ($input.data("validationNotEmpty") == true),
	                        resolveDNS: $input.data('validationResolvedns'),
	                        rangeOverflowMessage: $input.data('validationRangeOverflowMessage'),
	                        rangeUnderflowMessage: $input.data('validationUnderflowOverflowMessage'),
	                    },
	                    isInputEmpty: (typeof($input.val()) === "string" ? $input.val().trim() == "" : false)
	                };

	                const [isValid, messageToShow] = await validInput(validation);
	                let $error = $input.parent().find(`.invalid-feedback`);

	                // if the error element doesn't exist then create a new one
	                if ($error.length == 0) {
	                    $error = $(`<span class='invalid-feedback'></span>`);
	                }

	                // display the errors and color the input box
	                if (!isValid) {
	                    $input.addClass('is-invalid');
	                    $input.parent().append($error);
	                    $error.text(messageToShow);
	                }
	                else {
	                    // clean the validation message and remove the error
	                    $input.removeClass('is-invalid');
	                    $error.fadeOut(500, function () { $(this).remove(); });
	                }
	            };

	            $(this).off('input').on('input', function (e) {

	                self.currentState = self.createFormSnapshot();

	                // if exists already a Timeout then clear it
	                if (timeoutId != -1) clearTimeout(timeoutId);

	                if (!$input.attr("formnovalidate")) {
	                    // trigger input validation after 300msec
	                    timeoutId = setTimeout(() => {
	                        checkValidation();
	                        // trigger form validation to enable the submit button
	                        self.toggleFormSubmission();
	                    }, 300);
	                    // the user has changed the input, we can abort the first close attempt
	                    self.firstCloseAttempt = false;
	                }
	            });

	            $(this).off('invalid').on('invalid', function (e) {
	                e.preventDefault();
	                if (!$input.attr("formnovalidate")) {
	                    checkValidation();
	                }
	            });
	        });

	    }

	    getModalID() {
	        return $(this.element).parents('.modal').attr('id');
	    }

	    toggleFormSubmission() {

	        let isValid = true;

	        // if each input is marked as valid then enable the form submit button
	        $(this.element).find('input:not(:disabled),select:not(:disabled),textarea:not(:disabled)').each(function (idx, input) {
	            // make a concatenate & between valid flags
	            isValid &= input.validity.valid;
	        });

	        isValid
	            ? $(this.element).find(`[type='submit'],[type='test']`).removeAttr("disabled")
	            : $(this.element).find(`[type='submit'],[type='test']`).attr("disabled", "disabled");
	    }

	    cleanForm() {
	        /* remove validation class from fields */
	        $(this.element).find('input,textarea,select').each(function (i, input) {
	            $(this).removeClass(`is-valid`).removeClass(`is-invalid`);
	        });
	        /* reset all the values */
	        $(this.element)[0].reset();
	    }

	    makeRequest() {

	        const $feedbackLabel = $(this.element).find(`.invalid-feedback`);
	        const submitButton = $(this.element).find(`[type='submit']`);
	        let dataToSend = this.options.beforeSumbit(this.data);

	        dataToSend.csrf = this.csrf;
	        dataToSend = $.extend(dataToSend, this.options.submitOptions);

	        /* clean previous state and disable button */
	        submitButton.attr("disabled", "disabled");

	        const self = this;

	        if (this.options.endpoint) {
	            let request;

	            if (self.options.method == "post") {
	                request = $.ajax({
	                    url: this.options.endpoint,
	                    data: JSON.stringify(dataToSend),
	                    method: self.options.method,
	                    dataType: "json",
	                    contentType: "application/json; charset=utf-8"
	                });
	            }
	            else {
	                request = $.get(this.options.endpoint, dataToSend);
	            }

	            this.isSubmitting = true;

	            request.done(function (response, textStatus) {

	                // clear submitting state
	                self.isSubmitting = false;
	                // clear the current form state
	                self.currentState = null;

	                if (self.options.resetAfterSubmit) self.cleanForm();
	                $feedbackLabel.hide();

	                const success = self.options.onSubmitSuccess(response, dataToSend, self);
	                // if the submit return a true boolean then close the modal
	                if (success) {
	                  if(self.dialog.modal)
	                    self.dialog.modal('hide');
	                  else {
	                    self.dialog[0].hidden = true;
	                    $(`.modal-backdrop.fade.show`).remove();
	                  }
	                }

	                /* unbind the old closure on submit event and bind a new one */
	                $(self.element).off('submit', self.submitHandler);
	                self.delegateSubmit();
	            })
	            .fail(function (jqxhr, textStatus, errorThrown) {

	                self.isSubmitting = false;
	                const response = jqxhr.responseJSON;
	                if (response.rc !== undefined && response.rc < 0) {
	                    $feedbackLabel.html(response.rc_str_hr).show();
	                }

	                self.options.onSubmitError(response, dataToSend, textStatus, errorThrown);
	            })
	            .always(function (d) {
	                submitButton.removeAttr("disabled");
	            });

	        } else { // no endpoint

	                // clear the current form state
	                self.currentState = null;

	                //if (self.options.resetAfterSubmit) self.cleanForm();
	                $feedbackLabel.hide();

	                const success = self.options.onSubmitSuccess({}, dataToSend, self);
	                // if the submit return a true boolean then close the modal
	                if (success) {
	                  if(self.dialog.modal)
	                    self.dialog.modal('hide');
	                  else
	                    self.dialog[0].hidden = true;
	                }

	                /* unbind the old closure on submit event and bind a new one */
	                $(self.element).off('submit', self.submitHandler);
	                self.delegateSubmit();

	                submitButton.removeAttr("disabled");
	        }
	    }

	    delegateResetButton() {

	        const self = this;
	        const resetButton = $(this.element).find(`[type='reset']`);
	        if (resetButton.length == 0) return;

	        const defaultValues = NtopUtils.serializeFormArray($(this.element).serializeArray());

	        resetButton.click(function (e) {

	            e.preventDefault();

	            // reset the previous values
	            $(self.element).find('input:visible,select').each(function (i, input) {
	                const key = $(input).attr('name');
	                $(input).val(defaultValues[key])
	                    .removeClass('is-invalid').removeClass('is-valid');
	            });
	        });
	    }
	}

	const modalHandler = function (args) {

	    if (this.length != 1) throw new Error("Only a form element can by initialized!");

	    const options = $.extend({
	        csrf: '',
	        endpoint: '',
	        resetAfterSubmit: true,
	        /* True to skip the are-you-sure check on the dialog */
	        dontDisableSubmit: false,
	        /* True if the request isn't done by AJAX request */
	        isSyncRequest: false,
	        method: 'get',
	        /**
	         * Fetch data asynchronusly from the server or
	         * loads data directly from the current page.
	         * The function must returns the fetched data.
	         *
	         * @returns Returns the fetched data.
	         * @example Below there is an example showing
	         * how to use the function when fetching data from the server
	         * ```
	         * loadFormData: async function() {
	         *      const data = await fetch(`endpoint/to/data`);
	         *      const user = await data.json();
	         *      return user;
	         * }
	         * ```
	         */
	        loadFormData: function () { },

	        /**
	         * onModalInit() is invoked when the plugin has been initialized.
	         * This function is used to load the fetched data from `loadFormData()`
	         * inside the form modal inputs.
	         *
	         * @param {object} loadedData This argument contains the fetched data obtained
	         * from `loadFormData()`
	         * @example Below there is an example showing how to use
	         * the function (we suppose that loadFormData() returns the following
	         * object: `loadedUser = {firstname: 'Foo', lastname: 'Bar', id: 1428103}`)
	         * ```
	         * onModalInit: function(loadedUser) {
	         *      $(`#userModal form input#firstname`).val(loadedUser.firstname);
	         *      $(`#userModal form input#lastname`).val(loadedUser.lastname);
	         *      $(`#userModal form input#id`).val(loadedUser.id);
	         * }
	         * ```
	         */
	        onModalInit: function (loadedData) { },

	        onModalShow: function () { },

	        /**
	         * The function beforeSubmit() is invoked after the user
	         * submit the form. The function must return the data to
	         * send to the endpoint. If the chosen method is `post`
	         * a csrf will be add to the returned object.
	         *
	         * @example We show below a simple example how to use the function:
	         * ```
	         * beforeSubmit: function() {
	         *      const body = {
	         *          action: 'edit',
	         *          JSON: JSON.stringify(serializeArrayForm($(`form`).serializeArray()))
	         *      };
	         *      return body;
	         * }
	         * ```
	         */
	        beforeSumbit: function () { return {} },

	        /**
	         * This function is invoked when the request to the endpoint
	         * terminates successfully (200). Before the call of this function
	         * a new csrf retrived from the server will be set for
	         * future calls.
	         *
	         * @param {object} response This object contains the response
	         * from the server
	         *
	         * @example Below there is an example showing a simple user case:
	         * ```
	         * onSubmitSuccess: function(response) {
	         *      if (response.success) {
	         *          console.log(`The user info has been edit with success!`);
	         *      }
	         * }
	         * ```
	         */
	        onSubmitSuccess: function (response) { },

	        /**
	         * This function is invoked when the request to the endpoint
	         * terminates with failure (!= 200). Before the call of this function
	         * a new csrf retrived from the server will be set for
	         * future calls.
	         *
	         * @param {object} sent This object contains the sent data to the endpoint
	         * @param {string} textStatus It contains the error text status obtained
	         * @param {object} errorThrown This object contains info about the error
	         *
	         * @example Below there is an example showing a simple user case:
	         * ```
	         * onSubmitError: function(sent, textStatus, errorThrown) {
	         *      if (errorThrown) {
	         *          console.error(`Ops, something went wrong!`);
	         *          console.error(errorThrown);
	         *      }
	         * }
	         * ```
	         */
	        onSubmitError: function (sent, textStatus, errorThrown) { },

	        /**
	         * This function is invoked when the user click the reset input
	         * inside the form.
	         *
	         * @param {object} defaultData It contains the fetched data from
	         * `loadFormData()`.
	         *
	         * @example Below there is an example how to use the function:
	         * ```
	         * onModalReset: function(defaultData) {
	         *      $(`input#id`).val(defaultData.id);
	         *      $(`input#name`).val(defaultData.name);
	         *      $(`input#address`).val(defaultData.address);
	         * }
	         * ```
	         */
	        onModalReset: function (defaultData) { },
	    }, args);

	    const mh = new ModalHandler(this, options);
	    mh.delegateSubmit();

	    return mh;
	};

	/**
	    (C) 2022 - ntop.org
	*/
	const types = {
	    no_formatting: {
		id: "no_formatting",
		um: null,
		step: null,
		decimal: null,
		scale_values: null,
	    },
	    number: {
		id: "number",
		um: ["", "K", "M", "G", "T"],
		step: 1000,
		decimal: null,
		scale_values: null,
	    },
	    bytes: {
		id: "bytes",
		um: ["B", "KB", "MB", "GB", "TB"],
		step: 1024,
		decimal: 2,
		scale_values: null,
	    },
	    bytes_network: {
		id: "bytes_network",
		um: ["B", "KB", "MB", "GB", "TB"],
		step: 1000,
		decimal: 2,
		scale_values: null,
	    },
	    bps: {
		id: "bps",
		um: ["bps", "Kbps", "Mbps", "Gbps", "Tbps"],
		step: 1000,
		decimal: 2,
		scale_values: 8,	
	    },
	    fps: {
		id: "fps",
		um: ["flows/s", "Kflows/s", "Mflows/s", "Gflows/s"],
		step: 1000,
		decimal: 2,
		scale_values: null,	
	    },
	    pps: {
		id: "pps",
		um: ["pps", "Kpps", "Mpps", "Gpps", "Tpps"],
		step: 1000,
		decimal: 2,
		scale_values: null,	
	    },
	    ms: {
		id: "ms",
		um: ["ms", "Kms", "Mms", "Gms", "Tms"],
		step: 1000,
		decimal: 2,
		scale_values: null,	
	    },
	};

	function getUnitMeasureLen(type) {
	    // 000.00
	    let t = types[type];
	    let spaceValue = 3;
	    if (t.decimal != null && t.decimal > 0) {	
		spaceValue = 6;
	    }
	    let spaceUm = 0;
	    if (t.um != null) {
		spaceUm = Math.max(...t.um.map((um) => um.length));
	    }
	    return (spaceValue + 1 + spaceUm);
	}

	function getFormatter(type, absoluteValue) {
	    let typeOptions = types[type];
	    let formatter = function(value) {
		if (value == null) {
		    return '';
		}
		if (type == types.no_formatting.id) {
		    return value;
		}
		if (typeOptions.scale_values != null) {
		    value *= typeOptions.scale_values;
		}
		let negativeValue = value < 0;
		if (negativeValue) { value *= -1; }
		
		let step = typeOptions.step;
		let decimal = typeOptions.decimal;
		let measures = typeOptions.um;
		let i = 0;
		while (value >= step && i < measures.length) {
		    value = value / step;
		    i += 1;
		}
		if (decimal != null && decimal > 0) {	    
		    value = value * Math.pow(10, decimal);
		    value = Math.round(value);
		    value = value / Math.pow(10, decimal);
		    value = value.toFixed(decimal);
		} else {
		    value = Math.round(value);
		}
		
		if (negativeValue && !absoluteValue) { value *= -1; }
		let valString = `${value}`;
		// if (valString.length < maxLenValue) {
		//     valString = valString.padEnd(maxLenValue - valString.length, " ");
		// }
		let mString = `${measures[i]}`;
		// if (mString.length < maxLenUm) {
		//     mString = mString.padStart(maxLenUm - mString.length, "_");
		// }
		let text = `${valString} ${mString}`;
		return text;
	    };
	    return formatter;
	}

	const formatterUtils = function() {
	    return {
		types,
		getUnitMeasureLen,
		getFormatter,
	    };
	}();

	window.NtopUtils = NtopUtils$1;

	window.datatableInitRefreshRows = datatableInitRefreshRows;
	window.datatableForEachRow = datatableForEachRow;
	window.datatableIsEmpty = datatableIsEmpty;
	window.datatableRemoveEmptyRow = datatableRemoveEmptyRow;
	window.datatableAddEmptyRow = datatableAddEmptyRow;
	window.datatableGetNumDisplayedItems = datatableGetNumDisplayedItems;
	window.datatableGetByForm = datatableGetByForm;
	window.datatableUndoAddRow = datatableUndoAddRow;
	window.datatableAddButtonCallback = datatableAddButtonCallback;
	window.datatableAddDeleteButtonCallback = datatableAddDeleteButtonCallback;
	window.datatableAddActionButtonCallback = datatableAddActionButtonCallback;
	window.datatableAddFilterButtonCallback = datatableAddFilterButtonCallback;
	window.datatableAddLinkButtonCallback = datatableAddLinkButtonCallback;
	window.datatableMakeSelectUnique = datatableMakeSelectUnique;
	window.datatableIsLastPage = datatableIsLastPage;
	window.datatableGetColumn = datatableGetColumn;
	window.datatableGetColumnIndex = datatableGetColumnIndex;

	window.$.fn.modalHandler = modalHandler;

	window.ebpfUtils = ebpfUtils;
	window.ntopFormatterUtils = formatterUtils;

	function makeUniqueValidator(items_function) {
	  return function(field) {
	    var cmp_name = field.val();
	    var count = 0;

	    // this will be checked separately, with 'required' argument
	    if(! cmp_name)
	      return true;

	    items_function(field).each(function() {
	      var name = $(this).val();
	      if (name == cmp_name)
	        count = count + 1;
	    });

	    return count == 1;
	  }
	}

	function memberValueValidator(input) {
	  var member = input.val();
	  if (member === "") return true;

	  return NtopUtils.is_mac_address(member) || NtopUtils.is_network_mask(member, true);
	}

	function makePasswordPatternValidator(pattern) {
	  return function passwordPatternValidator(input) {
	    // required is checked separately
	    if(!input.val()) return true;
	    return $(input).val().match(pattern);
	  }
	}

	function passwordMatchValidator(input) {
	  var other_input = $(input).closest("form").find("[data-passwordmatch]").not(input);
	  if(!input.val() || !other_input.val()) return true;
	  return other_input.val() === input.val();
	}

	function poolnameValidator(input) {
	  // required is checked separately
	  if(!input.val()) return true;
	  return $(input).val().match(/^[a-z0-9_]*$/);
	}

	function passwordMatchRecheck(form) {
	  var items = $(form).find("[data-passwordmatch]");
	  var not_empty = 0;

	  items.each(function() {
	    if($(this).val() != "") not_empty++;
	  });

	  if(not_empty == items.length) items.trigger('input');
	}

	function hostOrMacValidator(input) {
	  var host = input.val();

	  /* Handled separately */
	  if (host === "") return true;

	  return NtopUtils.is_mac_address(host) || NtopUtils.is_good_ipv4(host) || NtopUtils.is_good_ipv6(host);
	}

	function ipAddressValidator(input) {
	  var host = input.val();

	  /* Handled separately */
	  if (host === "") return true;

	  return NtopUtils.is_good_ipv4(host) || NtopUtils.is_good_ipv6(host);
	}

	var filters_to_validate = {};

	function bpfValidator(filter_field, sync = false) {
	  var filter = filter_field.val();

	  if (filter.trim() === "") {
	    return true;
	  }

	  var key = filter_field.attr("name");
	  var timeout = 250;

	  if (!filters_to_validate[key])
	     filters_to_validate[key] = {ajax_obj:null, valid:true, timer:null, submit_remind:false, last_val:null};
	  var status = filters_to_validate[key];

	  var sendAjax = function () {
	    status.timer = null;

	    var finally_check = function (valid) {
	      status.ajax_obj = null;
	      status.valid = valid;
	      status.last_val = filter;
	    };

	    if (status.last_val !== filter) {
	      if (status.ajax_obj)
	        status.ajax_obj.abort();

	      status.ajax_obj = $.ajax({
	        type: "GET",
	        url: `${http_prefix}/lua/pro/rest/v2/check/filter.lua`,
	        async: !sync,
	        data: {
	          query: filter,
	        }, error: function() {
	          finally_check(status.valid);
	        }, success: function(data) {
	          var valid = data.response ? true : false;
	          finally_check(valid);
	        }
	      });
	    } else {
	      // possibly process the reminder
	      finally_check(status.valid);
	    }
	  };

	  if (sync) {
	    sendAjax();
	  } else if (status.last_val === filter) ; else {
	    if (status.timer) {
	      clearTimeout(status.timer);
	      status.submit_remind = false;
	    }
	    status.timer = setTimeout(sendAjax, timeout);
	  }

	  return status.valid;
	}

	window.makeUniqueValidator = makeUniqueValidator;
	window.memberValueValidator = memberValueValidator;
	window.makePasswordPatternValidator = makePasswordPatternValidator;
	window.passwordMatchValidator = passwordMatchValidator;
	window.poolnameValidator = poolnameValidator;
	window.passwordMatchRecheck = passwordMatchRecheck;
	window.hostOrMacValidator = hostOrMacValidator;
	window.ipAddressValidator = ipAddressValidator;
	window.bpfValidator = bpfValidator;

	/**
	    (C) 2022 - ntop.org    
	*/

	const ntopng_sync$1 = function() {
	    let components_ready = {};
	    let subscribers = [];        
	    return {
		ready: function(component_name) {
		    components_ready[component_name] = true;
		    subscribers.filter((s) => s.component_name == component_name).forEach((s) => s.resolve());
		    subscribers = subscribers.filter((s) => s.component_name != component_name);
		},
		on_ready: function(component_name) {
		    return new Promise((resolve, rejevt) => {
			if (components_ready[component_name]) {
			    resolve();
			    return;
			}
			subscribers.push({resolve, component_name, completed: false});
		    });
		},
	    };
	}();

	/**
	* Utility globals functions.
	*/
	const ntopng_utility$1 = function() {
	    let global_http_headers = {};
	    return {
		is_array: function(e) {
		    return Array.isArray(e);
		},
		is_object: function(e) {
		    return typeof e === 'object'
			&& !this.is_array(e)
			&& e !== null;
		},
		/**
		 * Deep copy of a object.
		 * @param {object} obj.
		 * @returns {object}.
		 */
		clone: function(obj) {
	            if (obj == null) { return null; }
	            if (this.is_object(obj)) {
			/* This does the deep copy using jquery for objects */
			return $.extend(true, {}, obj);
	            } else if (Array.isArray(obj)){
			/* This does the deep copy using jquery for other types */
			let res = [];
			for (let i = 0; i < obj.length; i += 1) {
			    let el = this.clone(obj[i]);
			    res.push(el);
			}
			return res;
	            } else {
			// return JSON.parse(JSON.stringify(obj))
			return obj;
		    }
		},      
		object_to_array: function(obj) {
		    if (obj == null) { return []; }
		    let array = [];
		    for (let key in obj) {
			array.push(obj[key]);
		    }
		    return array;
		},
		check_and_set_default_interval_time: function() {
		    if (ntopng_url_manager$1.get_url_entry("epoch_begin") == null
	      		|| ntopng_url_manager$1.get_url_entry("epoch_end") == null) {
			let default_epoch_begin = Number.parseInt((Date.now() - 1000 * 30 * 60) / 1000);
			let default_epoch_end = Number.parseInt(Date.now() / 1000);
			ntopng_url_manager$1.set_key_to_url("epoch_begin", default_epoch_begin);
			ntopng_url_manager$1.set_key_to_url("epoch_end", default_epoch_end);
		    }
		},
		from_utc_s_to_server_date: function(utc_seconds) {
		    let utc = utc_seconds * 1000;
		    let d_local = new Date(utc);
		    let local_offset = d_local.getTimezoneOffset();
		    let server_offset = moment.tz(utc, ntop_zoneinfo)._offset;
		    let offset_minutes =  server_offset + local_offset;
		    let offset_ms = offset_minutes * 1000 * 60;
		    var d_server = new Date(utc + offset_ms);
		    return d_server;
		},
		from_utc_to_server_date_format: function(utc_ms, format) {
		    if (format == null) { format = "DD/MMM/YYYY HH:mm"; }
		    let m = moment.tz(utc_ms, ntop_zoneinfo);
		    let m_local = moment(utc_ms);
		    m_local.format(format);
		    let tz_server = m.format(format);
		    return tz_server;
		},
		copy_object_keys: function(source_obj, dest_obj, recursive_object = false) {
		    if (source_obj == null) {
			return;
		    }
		    for (let key in source_obj) {
		    	if (source_obj[key] == null) { continue; }
		    	if (recursive_object == true && this.is_object(source_obj[key]) && this.is_object(dest_obj[key])) {
		    	    this.copy_object_keys(source_obj[key], dest_obj[key], recursive_object);
		    	} else {
		    	    dest_obj[key] = source_obj[key];
		    	}
		    }
		},
		set_http_globals_headers(headers) {
		    global_http_headers = headers;
		},
		http_request: async function(url, options, throw_exception, not_unwrap) {
		    try {
			if (options == null) {
			    options = {};
			}
			if (options.headers == null) {
			    options.headers = {};
			}
			if (options != null && options.headers != null && global_http_headers != null) {
			    options.headers = {
				...options.headers,
				...global_http_headers,
			    };
			}
			let res = await fetch(url, options);
			if (res.ok == false) {
			    console.error(`http_request ${url}\n ok == false`);
			    console.error(res);
			    return null;
			}
			let json_res = await res.json();
			if (not_unwrap == true) { return json_res; }
			return json_res.rsp;
		    } catch (err) {
			console.error(err);
			if (throw_exception == true) { throw err; }
			return null;
		    }
		},
		get_random_string: function() {
		    return Math.random().toString(16).substr(2, 8);
		},
		string_hash_code: function(s) {
		    let hash = 0, i, chr;
		    if (s.length === 0) return hash;
		    for (i = 0; i < s.length; i++) {
			chr   = s.charCodeAt(i);
			hash  = ((hash << 5) - hash) + chr;
			hash |= 0; // Convert to 32bit integer
		    }
		    return hash;
		},
		mod: function(x, y) {
		    x = x % y;
		    if (x < 0) { x += y; }
		    return x;
		}
	    }
	}();

	/**
	* Allows to manage the application global status.
	* The status is incapsulated into the url.
	*/
	const ntopng_status_manager$1 = function() {
	  let gloabal_status = {};
	  /** @type {{ [id: string]: (status: object) => void}} */
	  let subscribers = {}; // dictionary of { [id: string]: f_on_ntopng_status_change() }
	    const clone = (e) => ntopng_utility$1.clone(e);

	  const relplace_global_status = function(status) {
	gloabal_status = status;
	  };
	  /**
	   * Notifies the status to all subscribers with id different from skip_id.
	   * @param {object} status object that represent the application status.
	   * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
	   */
	  const notify_subscribers = function(status, skip_id) {
	      for (let id in subscribers) {
	          if (id == skip_id) { continue; }
	          let f_on_change = subscribers[id];
	          f_on_change(clone(status));
	      }
	  };

	  return {	
	      /**
	       * Gets the current global application status.
	       * @returns {object}
	       */
	      get_status: function() {
	    return clone(gloabal_status);
	      },

	update_subscribers: function() {
	    const status = this.get_status();
	    notify_subscribers(status);
	},

	      /**
	       * Allows to subscribers f_on_change callback on status change event.
	       * @param {string} id an identifier of the subscribtion. 
	       * @param {(status:object) => void} f_on_change callback that take object status as param.
	       * @param {boolean} get_init_notify if true the callback it's immediately called with the last status available.
	       */
	      on_status_change: function(id, f_on_change, get_init_notify) {
	          subscribers[id] = f_on_change;
	          if (get_init_notify == true) {
	              let status = this.get_status();
	              f_on_change(clone(status));
	          }
	      },

	      /**
	       * Raplaces the application status and notifies the new status to all subscribers.
	       * Notifies the new status to all subscribers.
	       * @param {Object} status object that represent the application status.
	       * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
	       */
	      replace_status: function(status, skip_id) {
	    relplace_global_status(status);
	          notify_subscribers(status, skip_id);
	      },

	      /**
	       * Adds or replaces all obj param keys to the application status.
	       * Notifies the new status to all subscribers.
	       * @param {Object} obj object to add or edit to the application status. 
	       * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
	       */
	      add_obj_to_status: function(obj, skip_id) {
	          let new_status = this.get_status();
	    ntopng_utility$1.copy_object_keys(obj, new_status);
	          this.replace_status(new_status, skip_id);
	      },

	      /**
	       * Adds or replaces the value key to the application status.
	       * Notifies the new status to all subscribers.
	       * @param {string} key key to adds or replaces.
	       * @param {any} value value to adds or replaces.
	       * @param {*} skip_id if != null doesn't notify the subscribers with skip_id identifier.
	       */
	      add_value_to_status: function(key, value, skip_id) {
	          let new_status = this.get_status();
	          new_status[key] = value;
	          // /* This is needed to have muliple filters for the same key */
	          // (new_status[key] && new_status[key].search(value) === -1) ? new_status[key] += "," + value : new_status[key] = value
	          
	          this.replace_status(new_status, skip_id);
	      },
	  }
	}();

	const ntopng_params_url_serializer = {
	  // filters: function(key, filters) {
	  // 	if (filters == null) { return ""; }
	  // 	let filters_groups = {};
	  // 	filters.forEach((f) => {
	  // 	    let group = filters_groups[f.id];
	  // 	    if (group == null) {
	  // 		group = [];
	  // 		filters_groups[f.id] = group;
	  // 	    }
	  // 	    group.push(f);
	  // 	});
	  // 	let url_params_array = [];
	  // 	for (let f_id in filters_groups) {
	  // 	    let group = filters_groups[f_id];
	  // 	    let url_values = group.filter((f) => f.value != null && f.operator != null && f.operator != "").map((f) => `${f.value};${f.operator}`).join(",");
	  // 	    let url_params = ntopng_url_manager.serialize_param(f_id, url_values);
	  // 	    url_params_array.push(url_params);
	  // 	}
	  // 	return url_params_array.join("&");
	  // },
	};

	const ntopng_url_manager$1 = function() {
	  /** @type {{ [key: string]: (obj: any) => string}} */
	  let custom_params_serializer = {};
	  ntopng_utility$1.copy_object_keys(ntopng_params_url_serializer, custom_params_serializer);
	  
	  return {
	get_url_params: function() {
	    return window.location.search.substring(1);
	},
	get_url_search_params: function(url) {
	    if (url == null) {
	  url = this.get_url_params();
	    }
	    // for(const [key, value] of entries) {
	          const url_params = new URLSearchParams(url);
	    return url_params;
	},
	get_url_entries: function(url) {
	          const url_params = this.get_url_search_params(url);
	          const entries = url_params.entries();
	    return entries;
	},
	      get_url_entry: function(param_name, url) {
	    let entries = this.get_url_entries(url);
	    for(const [key, value] of entries) {
	  if (key == param_name) { return value; }
	    }
	    return null;
	},
	get_url_object: function(url) {
	    let entries = this.get_url_entries(url);
	    let obj = {};
	    for (const [key, value] of entries) {
	  obj[key] = value;
	    }
	    return obj;
	},
	reload_url: function() {
	    window.location.reload();
	},
	replace_url: function(url_params) {
	          window.history.replaceState({}, null, `?${url_params}`);
	},
	replace_url_and_reload: function(url_params) {
	    this.replace_url(url_params);
	    this.reload_url();
	},
	serialize_param: function(key, value) {
	    if (value == null) {
	  value = "";
	    }
	    return `${key}=${encodeURIComponent(value)}`;
	},	
	set_custom_key_serializer: function(key, f_get_url_param) {
	    custom_params_serializer[key] = f_get_url_param;
	},

	/**
	 * Convert js object into a string that represent url params.
	 * Uses custom serializer if set.
	 * @param {object} obj.
	 * @returns {string}.
	 */
	obj_to_url_params: function(obj) {
	    let params = [];
	    const default_serializer = this.serialize_param;
	    for (let key in obj) {
	  let serializer = custom_params_serializer[key];
	  if (serializer == null) {
	      serializer = default_serializer;
	  }
	  let param = serializer(key, obj[key]);
	  params.push(param);
	    }
	    let url_params = params.join("&");
	          return url_params;
	},
	delete_params: function(params_key) {
	    let search_params = this.get_url_search_params();
	    params_key.forEach((p) => {
	  search_params.delete(p);
	    });
	    this.replace_url(search_params.toString());	    
	},
	set_key_to_url: function(key, value) {
	    if (value == null) { value = ""; }	  
	    let search_params = this.get_url_search_params();
	    search_params.set(key, value);
	    this.replace_url(search_params.toString());
	},
	add_obj_to_url: function(url_params_obj, url) {
	    let new_url_params = this.obj_to_url_params(url_params_obj);
	    let search_params = this.get_url_search_params(url);
	    let new_entries = this.get_url_entries(new_url_params);
	    for (const [key, value] of new_entries) {
		search_params.set(key, value);
	    }
	    let new_url = search_params.toString();
	    if (url != null) { return new_url; }
	    this.replace_url(new_url);
	},
	  }
	}();

	// export const ntopng_params_manager = function() {
	//     const new = function(params_in_url) {
		
	//     }
	    
	//     return {

	//     }
	// }

	/**
	* Object that represents a list of prefedefined events that represent the status.
	*/
	const ntopng_events$1 = {
	  EPOCH_CHANGE: "epoch_change", // { epoch_begin: number, epoch_end: number }
	  FILTERS_CHANGE: "filters_change", // {filters: {id: string, operator: string, value: string}[] }
	};

	const ntopng_events_compare = {
	  EPOCH_CHANGE: function(new_status, old_status) {
	return new_status.epoch_begin != old_status.epoch_begin
	    || new_status.epoch_end != old_status.epoch_end;
	  },
	  FILTERS_CHANGE: function(new_status, old_status) {	
	return (new_status.filters == null && old_status.filters != null)
	    || (new_status.filters != null && old_status.filters == null)
	    || (new_status.filters != null && old_status.filters != null &&
	  (
	      (new_status.filters.length != old_status.filters.length)
	    || (new_status.filters.some((f_new) => old_status.filters.find((f_old) => f_old.id == f_new.id) == null))
	  )
	       );
	  },
	};

	/**
	* Object that represents a list of prefedefined custom events.
	*/
	const ntopng_custom_events$1 = {
	  SHOW_MODAL_FILTERS: "show_modal_filters", // {id: string, operator: string, value: string}
	  MODAL_FILTERS_APPLY: "modal_filters_apply", // {id: string, label: string, operator: string, value: string, value_label: string}
	  SHOW_GLOBAL_ALERT_INFO: "show_global_alert_info", // html_text: string
	  VIS_DATA_LOADED: "vis_data_loaded", 
	  CHANGE_PAGE_TITLE: "change_page_title", 
	  DATATABLE_LOADED: "datatable_loaded", 
	};


	/**
	* A global events service that allows to manage the application global status.
	* The status is incapsulated into the url.
	*/
	const ntopng_events_manager$1 = function() {
	  const events_manager_id = "events_manager";
	  let status = {};

	  /** @type {{ [event_name: string]: { [id: string]: (status: object) => void}}} */
	  let events_subscribers = {}; // dictionary of { [event_name: string]: { [id: string]: f_on_event }

	    const clone = (e) => ntopng_utility$1.clone(e);

	  /**
	   * Notifies the status to all subscribers with id different from skip_id.
	   * @param {{ [id: string]: (status: object) => void}} subscribers dictionary of id => f_on_event().
	   * @param {object} status object that represent the application status.
	   * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
	   */
	  const notify_subscribers = function(subscribers, status, skip_id) {
	      for (let id in subscribers) {
	          if (id == skip_id) { continue; }
	          let f_on_change = subscribers[id];
	          f_on_change(clone(status));
	      }
	  };

	  /**
	   * A callback that dispatches each event to all subscribers.
	   * @param {object} new_status 
	   */
	  const on_status_change = function(new_status) {
	for (let event_name in ntopng_events$1) {
	    let f_compare = ntopng_events_compare[event_name];
	    if (f_compare(new_status, status) == true) {
	  let subscribers = events_subscribers[event_name];
	  notify_subscribers(subscribers, new_status);
	    }
	}

	      status = new_status;
	  };

	  ntopng_status_manager$1.on_status_change(events_manager_id, on_status_change, true);

	  const emit = function(event, params, skip_id) {
	let subscribers = events_subscribers[event];
	if (subscribers == null) { return; }
	notify_subscribers(subscribers, params, skip_id);
	  };

	  const on_event = function(id, event, f_on_event, get_init_notify) {
	      if (events_subscribers[event] == null) {
	          events_subscribers[event] = {};        
	      }
	      if (get_init_notify == true) {
	          let status = ntopng_status_manager$1.get_status();        
	          f_on_event(clone(status));
	      }
	      events_subscribers[event][id] = f_on_event;
	  };

	  return {
	emit_custom_event: function(event, params) {
	    emit(event, params);
	},
	on_custom_event: function(id, event, f_on_event) {
	    on_event(id, event, f_on_event);
	},
	      /**
	       * Changes the application status and emits the new status to all subcribers registered to the event. 
	       * @param {string} event event name.
	       * @param {object} new_status object to add or edit to the application status.
	       * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
	       */
	      emit_event: function(event, new_status, skip_id) {
	    emit(event, new_status, skip_id);
	          ntopng_status_manager$1.add_obj_to_status(new_status, events_manager_id);
	      },
	      /**
	       * Allows to subscribers f_on_event callback on status change on event event_name.
	       * @param {string} id an identifier of the subscribtion. 
	       * @param {string} event event name. 
	       * @param {(status:object) => void} f_on_event callback that take object status as param.
	       * @param {boolean} get_init_notify if true the callback it's immediately called with the last status available.
	       */
	      on_event_change: function(id, event, f_on_event, get_init_notify) {
	    on_event(id, event, f_on_event, get_init_notify);
	      },
	  }    
	}();

	window.ntopng_events = ntopng_events$1;
	window.ntopng_events_manager = ntopng_events_manager$1;
	window.ntopng_status_manager = ntopng_status_manager$1;
	window.ntopng_utility = ntopng_utility$1;
	window.ntopng_url_manager = ntopng_url_manager$1;
	window.ntopng_sync = ntopng_sync$1;
	window.ntopng_custom_events = ntopng_custom_events$1;

	// http://jsfiddle.net/stephenboak/hYuPb/

	// Wrapper function
	function do_pie(name, update_url, url_params, units, refresh) {
		var pie = new PieChart(name, update_url, url_params, units, refresh);
		if (refresh)
			pie.setInterval(setInterval(function () { pie.update(); }, refresh));

		// Return new class instance, with
		return pie;
	}

	function PieChart(name, update_url, url_params, units, refresh) {

		// Add object properties like this
		this.name = name;
		this.update_url = update_url;
		this.url_params = url_params;
		this.units = units;
		this.refresh = refresh;
		this.pieInterval;

	  let streakerDataAdded = [];
	  let paths = "";
	  let lines = [];
	  let valueLabels = [];
	  let nameLabels = [];

		var pieData = [];
		var oldPieData = [];
		var filteredPieData = [];
		var rsp = create_pie_chart(name, units);
		var arc_group = rsp[0];
		var donut = rsp[1];
		var totalValue = rsp[2];
		var color = rsp[4];
		var tweenDuration = rsp[5];
		var arc = rsp[6];
		var label_group = rsp[7];
		var r = rsp[9];
		var textOffset = rsp[10];


		// to run each time data is generated

		this.update = function () {
			// console.log(this.name);
			// console.log(this.url_params);
			$.ajax({
				type: 'GET',
				url: this.update_url,
				data: this.url_params,
				success: function (content) {
					let parsed_content;

					if (typeof (content) == "object")
						parsed_content = content;
					else if (typeof (content) == "string")
						parsed_content = jQuery.parseJSON(content);

					if (parsed_content)
						update_pie_chart(parsed_content);
				}
			});
		};

		///////////////////////////////////////////////////////////
		// STREAKER CONNECTION ////////////////////////////////////
		///////////////////////////////////////////////////////////

		// Needed to draw the pie immediately
		this.update();
		this.update();

		// var updateInterval = window.setInterval(update, refresh);

		function compare_by_label(a, b) {
			if (a.label < b.label) {
				return -1;
			} else if (a.label > b.label) {
				return 1;
			} else {
				return 0;
			}
		}

		function update_pie_chart(data) {
			if (data.rsp) // detect REST API v1
				data = data.rsp;

			data.sort(compare_by_label);
			streakerDataAdded = data;
			oldPieData = filteredPieData;
			pieData = donut(streakerDataAdded);

			var totalOctets = 0;
			filteredPieData = pieData.filter(filterData);
			function filterData(element, index, array) {
				element.name = streakerDataAdded[index].label;
				element.value = streakerDataAdded[index].value;
				element.url = streakerDataAdded[index].url;
				totalOctets += element.value;
				return (element.value > 0);
			}

			if ((filteredPieData.length > 0) && (oldPieData.length > 0)) {
				//REMOVE PLACEHOLDER CIRCLE
				arc_group.selectAll("circle").remove();

				if (totalValue) {
					totalValue.text(function () {
						var kb = totalOctets / 1024;
						return kb.toFixed(1);
						//return bchart.label.abbreviated(totalOctets*8);
					});
				}

				//DRAW ARC PATHS
				paths = arc_group.selectAll("path").data(filteredPieData);
				paths.enter().append("svg:path")
					.attr("stroke", "white")
					.attr("stroke-width", 0.5)
					.attr("fill", function (d, i) { return color(i); })
					.transition()
					.duration(tweenDuration)
					.attrTween("d", pieTween);
				paths
					.transition()
					.duration(tweenDuration)
					.attrTween("d", pieTween);
				paths.exit()
					.transition()
					.duration(tweenDuration)
					.attrTween("d", removePieTween)
					.remove();

				//DRAW TICK MARK LINES FOR LABELS
				lines = label_group.selectAll("line").data(filteredPieData);
				lines.enter().append("svg:line")
					.attr("x1", 0)
					.attr("x2", 0)
					.attr("y1", -r - 3)
					.attr("y2", -r - 8)
					.attr("stroke", "gray")
					.attr("transform", function (d) {
						return "rotate(" + (d.startAngle + d.endAngle) / 2 * (180 / Math.PI) + ")";
					});
				lines.transition()
					.duration(tweenDuration)
					.attr("transform", function (d) {
						return "rotate(" + (d.startAngle + d.endAngle) / 2 * (180 / Math.PI) + ")";
					});
				lines.exit().remove();

				//DRAW LABELS WITH PERCENTAGE VALUES
				valueLabels = label_group.selectAll("text.value").data(filteredPieData)
					.attr("dy", function (d) {
						if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
							return 5;
						} else {
							return -7;
						}
					})
					.attr("text-anchor", function (d) {
						if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
							return "beginning";
						} else {
							return "end";
						}
					})
					.text(function (d) {

						const percentage = (d.value / totalOctets) * 100;
						// approssimate the number to the third deciaml digit and show only the first decimal
						let percentageLabel = percentage.toFixed(1) + "%";
						return percentageLabel;
					});

				valueLabels.enter().append("svg:text")
					.attr("class", "value")
					.attr("transform", function (d) {
						return "translate(" + Math.cos(((d.startAngle + d.endAngle - Math.PI) / 2)) * (r + textOffset) + "," + Math.sin((d.startAngle + d.endAngle - Math.PI) / 2) * (r + textOffset) + ")";
					})
					.attr("dy", function (d) {
						if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
							return 5;
						} else {
							return -7;
						}
					})
					.attr("text-anchor", function (d) {
						if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
							return "beginning";
						} else {
							return "end";
						}
					}).text(function (d) {
						if (totalOctets <= 1) return "";
						const percentage = (d.value / totalOctets) * 100;
						let percentageLabel = percentage.toFixed(1) + "%";
						return percentageLabel;
					});

				valueLabels.transition().duration(tweenDuration).attrTween("transform", textTween);
				valueLabels.exit().remove();

				//DRAW LABELS WITH ENTITY NAMES
				nameLabels = label_group.selectAll("text.units").data(filteredPieData)
					.attr("dy", function (d) {
						if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
							return 17;
						} else {
							return 5;
						}
					})
					.attr("text-anchor", function (d) {
						if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
							return "beginning";
						} else {
							return "end";
						}
					}).text(function (d) {
						return d.name;
					})
					.on("click", function (d) { if (d.url) window.location.href = d.url; });

				nameLabels.enter().append("svg:text")
					.attr("class", "units")
					.attr("transform", function (d) {
						return "translate(" + Math.cos(((d.startAngle + d.endAngle - Math.PI) / 2)) * (r + textOffset) + "," + Math.sin((d.startAngle + d.endAngle - Math.PI) / 2) * (r + textOffset) + ")";
					})
					.attr("dy", function (d) {
						if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
							return 17;
						} else {
							return 5;
						}
					})
					.attr("text-anchor", function (d) {
						if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
							return "beginning";
						} else {
							return "end";
						}
					}).text(function (d) {
						return d.name;
					})
					.on("click", function (d) { if (d.url) window.location.href = d.url; });

				nameLabels.transition().duration(tweenDuration).attrTween("transform", textTween);

				nameLabels.exit().remove();
			}
		}

		///////////////////////////////////////////////////////////
		// FUNCTIONS //////////////////////////////////////////////
		///////////////////////////////////////////////////////////

		// Interpolate the arcs in data space.
		function pieTween(d, i) {
			var s0;
			var e0;
			if (oldPieData[i]) {
				s0 = oldPieData[i].startAngle;
				e0 = oldPieData[i].endAngle;
			} else if (!(oldPieData[i]) && oldPieData[i - 1]) {
				s0 = oldPieData[i - 1].endAngle;
				e0 = oldPieData[i - 1].endAngle;
			} else if (!(oldPieData[i - 1]) && oldPieData.length > 0) {
				s0 = oldPieData[oldPieData.length - 1].endAngle;
				e0 = oldPieData[oldPieData.length - 1].endAngle;
			} else {
				s0 = 0;
				e0 = 0;
			}
			var i = d3.interpolate({ startAngle: s0, endAngle: e0 }, { startAngle: d.startAngle, endAngle: d.endAngle });
			return function (t) {
				var b = i(t);
				return arc(b);
			};
		}

		function removePieTween(d, i) {
			s0 = 2 * Math.PI;
			e0 = 2 * Math.PI;
			var i = d3.interpolate({ startAngle: d.startAngle, endAngle: d.endAngle }, { startAngle: s0, endAngle: e0 });
			return function (t) {
				var b = i(t);
				return arc(b);
			};
		}

		function textTween(d, i) {
			var a;
			if (oldPieData[i]) {
				a = (oldPieData[i].startAngle + oldPieData[i].endAngle - Math.PI) / 2;
			} else if (!(oldPieData[i]) && oldPieData[i - 1]) {
				a = (oldPieData[i - 1].startAngle + oldPieData[i - 1].endAngle - Math.PI) / 2;
			} else if (!(oldPieData[i - 1]) && oldPieData.length > 0) {
				a = (oldPieData[oldPieData.length - 1].startAngle + oldPieData[oldPieData.length - 1].endAngle - Math.PI) / 2;
			} else {
				a = 0;
			}
			var b = (d.startAngle + d.endAngle - Math.PI) / 2;

			var fn = d3.interpolateNumber(a, b);
			return function (t) {
				var val = fn(t);
				return "translate(" + Math.cos(val) * (r + textOffset) + "," + Math.sin(val) * (r + textOffset) + ")";
			};
		}

	}

	///////////////////////////////////////////////////////////
	// PUBLIC FUNCIONTS ////////////////////////////////////
	///////////////////////////////////////////////////////////


	PieChart.prototype.setUrlParams = function (url_params) {
		this.url_params = url_params;
		this.forceUpdate();
	};

	PieChart.prototype.forceUpdate = function (url_params) {
		this.stopInterval();
		this.update();
		this.startInterval();
	};

	PieChart.prototype.setInterval = function (p_pieInterval) {
		this.pieInterval = p_pieInterval;
	};

	PieChart.prototype.stopInterval = function () {
		//disabled graph interval
		clearInterval(this.pieInterval);
	};

	PieChart.prototype.startInterval = function () {
		this.pieInterval = setInterval(this.update(), this.refresh);
	};
	///////////////////////////////////////////////////////////
	// INIT FUNCIONTS ////////////////////////////////////
	///////////////////////////////////////////////////////////

	function create_pie_chart(name, units) {
		var w = 500; //380 - Please keep in sync with pie-chart.css
		var h = 325; //280
		var ir = 52; //45
		var textOffset = 14;
		var tweenDuration = 250;
		var r = 116; //100;

		if ($(name).hasClass("pie-chart-small")) {
			w = 330;
			h = 250;
			r = w / 5 + 15;
			ir = r / 2;
		}

		//D3 helper function to populate pie slice parameters from array data
		var donut = d3.layout.pie().value(function (d) {
			if (d.value == 0) { d.value = 1; } // Force to 1, in order to update the graph
			return d.value;
		});

		//D3 helper function to create colors from an ordinal scale
		var color = d3.scale.category20();

		//D3 helper function to draw arcs, populates parameter "d" in path object
		var arc = d3.svg.arc()
			.startAngle(function (d) { return d.startAngle; })
			.endAngle(function (d) { return d.endAngle; })
			.innerRadius(ir)
			.outerRadius(r);

		///////////////////////////////////////////////////////////
		// CREATE VIS & GROUPS ////////////////////////////////////
		///////////////////////////////////////////////////////////

		var vis = d3.select(name).append("svg:svg")
			.attr("width", w)
			.attr("height", h)
			.attr("viewBox", "0 0 " + w + " " + h)
			.attr("preserveAspectRatio", "xMidYMid");

		//GROUP FOR ARCS/PATHS
		var arc_group = vis.append("svg:g")
			.attr("class", "arc")
			.attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

		//GROUP FOR LABELS
		var label_group = vis.append("svg:g")
			.attr("class", "label_group")
			.attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

		//GROUP FOR CENTER TEXT
		var center_group = vis.append("svg:g")
			.attr("class", "center_group")
			.attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

		//PLACEHOLDER GRAY CIRCLE
		arc_group.append("svg:circle")
			.attr("fill", "#EFEFEF")
			.attr("r", r);

		///////////////////////////////////////////////////////////
		// CENTER TEXT ////////////////////////////////////////////
		///////////////////////////////////////////////////////////

		//WHITE CIRCLE BEHIND LABELS
		center_group.append("svg:circle")
			.attr("fill", "white")
			.attr("r", ir);

		var totalUnits = null;
		var totalValue = null;

		if (units) {
			// "TOTAL" LABEL
			center_group.append("svg:text")
				.attr("class", "label")
				.attr("dy", -15)
				.attr("text-anchor", "middle") // text-align: right
				.text("TOTAL");

			//TOTAL TRAFFIC VALUE
			totalValue = center_group.append("svg:text")
				.attr("class", "total")
				.attr("dy", 7)
				.attr("text-anchor", "middle") // text-align: right
				.text("Waiting...");

			//UNITS LABEL
			totalUnits = center_group.append("svg:text")
				.attr("class", "units")
				.attr("dy", 21)
				.attr("text-anchor", "middle") // text-align: right
				.text(units);
		}

		return ([arc_group, donut, totalValue, totalUnits, color, tweenDuration, arc, label_group, center_group, r, textOffset]);
	}

	/**
	 * (C) 2013-21 - ntop.org
	 */

	const DEFINED_WIDGETS = {};
	/* Used to implement the on click events onto the graph */
	const DEFINED_EVENTS = {
	    /* On click event used by the flow analyze section, redirect to the current url + a single filter */
	    "db_analyze" : function (event, chartContext, config) {
	        const { dataPointIndex } = config;
	        const { filter } = config.w.config;
	        let value;

	        if(config.w.config.filtering_labels)
	            value = config.w.config.filtering_labels[dataPointIndex];

	        if(config.w.config.labels)
	            config.w.config.labels[dataPointIndex];

	        if(filter.length == 0 || value === undefined)
	            return;

	        let status = ntopng_status_manager.get_status();
	        let filters = status.filters;
	        filters.push({id: filter[0], operator: "eq", value: value});
	        // notify that filters status is updated
	        ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, {filters});
	    },

	    "none" : function (event, chartContext, config) {
	        return;
	    },
	    
	    /* Standard on click event, redirect to the url */
	    "standard" : function (event, chartContext, config) {
	        const { seriesIndex, dataPointIndex } = config;
	        const { series } = config.w.config;
	        if (seriesIndex === -1) return;
	        if (series === undefined) return;

	        const serie = series[seriesIndex];
	        if (serie.base_url !== undefined) {
	            const search = serie.data[dataPointIndex].meta.url_query;
	            location.href = `${serie.base_url}?${search}`;
	        }
	    },
	};

	const DEFINED_TOOLTIP = {
	    /* On click event used by the flow analyze section, redirect to the current url + a single filter */
	    "format_bytes" : function(value, { config, seriesIndex, dataPointIndex }) {
	        return NtopUtils.bytesToSize(value);
	    },

	    "format_pkts" : function(value, { config, seriesIndex, dataPointIndex }) {
	        return NtopUtils.formatPackets(value);
	    },

	    /* On click event used by the flow analyze section, redirect to the current url + a single filter */
	    "format_value" : function(value, { config, seriesIndex, dataPointIndex }) {
	        return NtopUtils.formatValue(value);
	    },

	    "format_multiple_date" : function(value, { config, seriesIndex, dataPointIndex }) {
	        return new Date(value[0]) + " - " + new Date(value[1])
	    },

	    /*
	     *  This formatter is used by the bubble host map, from the y axis,
	     *  used to show the Hosts, with their respective values 
	     */
	    "format_label_from_xy" : function({series, seriesIndex, dataPointIndex, w}) {
	        const serie = w.config.series[seriesIndex]["data"][dataPointIndex];
	        
	        const x_value = serie["x"];
	        const y_value = serie["y"];
	        const host_name = serie["meta"]["label"];

	        const x_axis_title = w.config.xaxis.title.text;
	        const y_axis_title = w.config.yaxis[0].title.text;

	        return (`
            <div class='apexcharts-theme-light apexcharts-active' id='test'>
                <div class='apexcharts-tooltip-title' style='font-family: Helvetica, Arial, sans-serif; font-size: 12px;'>
                    ${host_name}
                </div>
                <div class='apexcharts-tooltip-series-group apexcharts-active d-block'>
                    <div class='apexcharts-tooltip-text text-left'>
                        <b>${x_axis_title}</b>: ${x_value}
                    </div>
                    <div class='apexcharts-tooltip-text text-left'>
                        <b>${y_axis_title}</b>: ${y_value}
                    </div>
                </div>
            </div>`)
	    },
	};

	/* Standard Formatter */
	const DEFAULT_FORMATTER = DEFINED_TOOLTIP["format_value"];

	class WidgetUtils {

	    static registerWidget(widget) {
	        if (widget === null) throw new Error(`The passed widget reference is null!`);
	        if (widget.name in DEFINED_WIDGETS) throw new Error(`The widget ${widget.name} is already defined!`);
	        DEFINED_WIDGETS[widget.name] = widget;
	    }

	    static getWidgetByName(widgetName) {
	        if (widgetName in DEFINED_WIDGETS) {
	            return DEFINED_WIDGETS[widgetName];
	        }
	        throw new Error(`Widget ${widgetName} not found!`)
	    }
	}

	/**
	 * Define a simple wrapper class for the widgets.
	 */
	class Widget {

	    constructor(name, datasource = {}, updateTime = 0, additionalParams = {}) {

	        // field containing the data fetched from the datasources provided
	        this._fetchedData = [];

	        this.name = name;

	        // if 0 then don't update the chart automatically, the time
	        // is expressed in milliseconds
	        this._updateTime = updateTime;

	        this._datasource = datasource;
	        this._additionalParams = additionalParams;
	    }

	    /**
	     * Init the widget.
	     */
	    async init() {

	        // register the widget to the DEFINED_WIDGETS object
	        WidgetUtils.registerWidget(this);
	        this._fetchedData = await this._fetchData();

	        if (this._updateTime > 0) {
	            setInterval(async () => { await this.update(this._datasource.params); }, this._updateTime);
	        }
	    }

	    /**
	     * Destroy the widget freeing the resources used.
	     */
	    async destroy() { }

	    /**
	     * Force the widget to reload it's data.
	     */
	    async destroyAndUpdate(datasourceParams = {}) {
	        await this.destroy();
	        await this.update(datasourceParams);
	    }

	    async updateByUrl(url) {
	      const u = new URL(`${location.origin}${this._datasource.name}`);
	      let entries = ntopng_url_manager.get_url_entries(url);
	      for (const [key, value] of entries) {
	          u.searchParams.set(key, value);
	      }
	      this._datasource.endpoint = u.pathname + u.search;
	      this._fetchedData = await this._fetchData();
	    }
	  
	    async update(datasourceParams = {}) {
		// build the new endpoint
	        const u = new URL(`${location.origin}${this._datasource.name}`);

	        for (const [key, value] of Object.entries(datasourceParams)) {
	            u.searchParams.set(key, value);
	        }

	        this._datasource.endpoint = u.pathname + u.search;
	        this._fetchedData = await this._fetchData();
	    }

	    /**
	     * For each datasources provided to the constructor,
	     * do a GET request to a REST endpoint.
	     */
	    async _fetchData() {
	        const req = await fetch(`${http_prefix}${this._datasource.endpoint}`);
	        return await req.json();
	    }

	}

	class ChartWidget extends Widget {

	    constructor(name, type = 'line', datasource = {}, updateTime = 0, additionalParams = {}) {
	        super(name, datasource, updateTime, additionalParams);

	        this._chartType = type;
	        this._chart = {};
	        this._$htmlChart = document.querySelector(`#canvas-widget-${name}`);
	    }

	    static registerEventCallback(widgetName, eventName, callback) {
	        setTimeout(async () => {
	            try {
	                const widget = WidgetUtils.getWidgetByName(widgetName);
	                const updatedOptions = {
	                    chart: {
	                        events: {
	                            [eventName]: callback
	                        }
	                    }
	                };
	                await widget._chart.updateOptions(updatedOptions);
	            }
	            catch (e) {

	            }
	        }, 1000);
	    }

	    _generateConfig() {
	        const config = {
	            series: [],
	            tooltip: {
	                enabledOnSeries: [0],
	                x: {
	                    show: true,
	                    format: 'dd/MM/yyyy HH:mm:ss',
	                },
	                y: {
	                    formatter: function(value, { series, seriesIndex, dataPointIndex, w }) {
	                        return value;
	                    },
	                },
	                z: {
	                    show: false,
	                }
	            },
	            chart: {
	                type: this._chartType,
	                events: {},
	                height: '100%',
	                toolbar: {
	                    show: false,
	                }
	            },
	            xaxis: {
	                labels: {
	                    style: {
	                        fontSize: '14px',
	                    }
	                },
	                tooltip: {
	                    enabled: true,
	                    formatter: function(value) {
	                        return value;
	                    }
	                }
	            },
	            yaxis: {
	                labels: {
	                    style: {
	                        fontSize: '14px',
	                    }
	                },
	                tooltip: {
	                    enabled: true,
	                    formatter: function(value) {
	                        return value;
	                    }
	                }
	            },
	            zaxis: {
	                labels: {
	                    style: {
	                        fontSize: '14px',
	                    }
	                },
	                tooltip: {
	                    enabled: true
	                }
	            },
	            dataLabels: {
	                enabled: true,
	                style: {
	                    fontSize: '14px',
	                }
	            },
		    labels: [],
	            legend: {
	                show: true,
	                fontSize: '14px',
	                position: 'bottom',
	                onItemClick: {
	                    toggleDataSeries: true,
	                },
	            },
	            plotOptions: {
	                bar: {
	                    borderRadius: 4,
	                    horizontal: true,
	                }
	            },
	            noData: {
	                text: 'No Data',
	                align: 'center',
	                verticalAlign: 'middle',
	                style: {
	                    fontSize: '24px'
	                }
	            }
	        };

	        // check if the additionalParams field contains an apex property,
	        // then merge the two configurations giving priority to the custom one
	        if (this._additionalParams && this._additionalParams.apex) {
	            const mergedConfig = Object.assign(config, this._additionalParams.apex);
	            return mergedConfig;
	        }

	        return config;
	    }

	    _buildTooltip(config, rsp) {
	        /* By default the areaChart tooltip[y] is overwritten */
	        config["tooltip"]["y"] = {
	            formatter: function(value, { series, seriesIndex, dataPointIndex, w }) {
	                return value;
	            }
	        };

	        /* Changing events if given */
	        if (rsp['tooltip']) {
	            for (const axis in rsp['tooltip']) {
	                if (axis === "x" || axis === "y" || axis === "z") {
	                    const formatter = rsp['tooltip'][axis]['formatter'];
	                    if(!config['tooltip'][axis])
	                        config['tooltip'][axis] = {};

	                    config['tooltip'][axis]['formatter'] = DEFINED_TOOLTIP[formatter] || NtopUtils[formatter];
	                }
	            }

	            /* Customizable tooltip requested */
	            if(rsp['tooltip']['custom'])
	                config['tooltip']['custom'] = DEFINED_TOOLTIP[rsp['tooltip']['custom']] || NtopUtils[rsp['tooltip']['custom']];
	        }
	    }

	    _buildAxisFormatter(config, axisName) {

	        const axis = config[axisName];
	        
	        if (axis === undefined || axis.labels === undefined) return;
	        
	        // enable formatters
	        if (axis.labels.ntop_utils_formatter !== undefined && axis.labels.ntop_utils_formatter !== 'none') {
	            
	            const selectedFormatter = axis.labels.ntop_utils_formatter;

	            if (NtopUtils[selectedFormatter] === undefined) {
	                console.error(`xaxis: Formatting function '${selectedFormatter}' didn't found inside NtopUtils.`);
	            }
	            else {
	                axis.labels.formatter = NtopUtils[selectedFormatter];
	            }
	        }
	    }

	    _buildDataLabels(config, rsp) {
	        if (rsp["dataLabels"]) {
	            for (const [dataLabelsOpts, data] of Object.entries(rsp["dataLabels"])) {
	                config["dataLabels"][dataLabelsOpts] = data;
	            }
	        }   

	        let formatter = config["dataLabels"]["formatter"];
	        
	        if(formatter && DEFINED_TOOLTIP[formatter]) {
	            config["dataLabels"]["formatter"] = DEFINED_TOOLTIP[formatter];
	        }
	    }

	    _buildConfig() {

	        const config = this._generateConfig();
	        const rsp = this._fetchedData.rsp;
	        
	        // add additional params fetched from the datasource
	        const additionals = ['series', 'xaxis', 'yaxis', 'colors', 'labels', 'fill', 'filter', 'filtering_labels'];
	        
	        for (const additional of additionals) {

	            if (rsp[additional] === undefined) continue;

	            if (config[additional] !== undefined) {
	                config[additional] = Object.assign(config[additional], rsp[additional]);
	            }
	            else {
	                config[additional] = rsp[additional];
	            }
	        }
	        
	        /* Changing events if given */
	        if (rsp['events']) {
	            /* Just pass a table of events. e.g. { events = { click = "db_analyze", updated = "standard" } }*/
	            for (const event in rsp['events']) {
	                config['chart']['events'][event] = DEFINED_EVENTS[rsp['events'][event]];
	            }
	        }

	        if (rsp['horizontal_chart'] !== undefined) {
	            config['plotOptions']['bar']['horizontal'] = rsp['horizontal_chart'];
	        }

	        this._buildTooltip(config, rsp);
	        this._buildAxisFormatter(config, 'xaxis');
	        this._buildAxisFormatter(config, 'yaxis');
	        this._buildDataLabels(config, rsp);

	        return config;
	    }

	    _initializeChart() {
	        const config = this._buildConfig();
	        this._chartConfig = config;
	        this._chart = new ApexCharts(this._$htmlChart, this._chartConfig);
	        this._chart.render();
	    }

	    async init() {
	        await super.init();
	        this._initializeChart();
	    }

	    async destroy() {
	        await super.destroy();
	        this._chart.destroy();
	        this._chart = null;
	    }

	    async update(datasourceParams = {}) {
	        if(this._chartConfig !== undefined) {	    
	          if (datasourceParams) {
	            await super.update(datasourceParams);
	          } else {
	            await super.updateByUrl();
	          }
	          
	          if (this._chart != null) {
	                // expecting that rsp contains an object called series
	                const { colors, series, dataLabels, labels, xaxis, filtering_labels } = this._fetchedData.rsp;
	                // update the colors list
	                this._chartConfig.colors = colors;
	                this._chartConfig.series = series;
	                
	                if(xaxis && xaxis.categories)
	                    this._chartConfig.xaxis.categories = xaxis.categories;
	                
	                if(filtering_labels)
	                    this._chartConfig.filtering_labels = filtering_labels;

	                if(dataLabels) {
	                    let formatter = this._chartConfig.dataLabels.formatter;
	                    if(formatter && DEFINED_TOOLTIP[formatter])
	                        this._chartConfig.dataLabels.formatter = DEFINED_TOOLTIP[formatter];
	                    else
	                        this._chartConfig.dataLabels.formatter = DEFAULT_FORMATTER;
	                }
	                    
	                if(labels) 
	                    this._chartConfig.labels = labels;

	                this._chart.updateOptions(this._chartConfig, true);
	            }
	        }
	    }

	    async destroyAndUpdate(datasource = {}) {
	        await super.destroyAndUpdate(datasource);
	        this._initializeChart();
	    }

	}

	const fixSubMenuPosition = ($submenu, $hoverButton) => {

	    const MIN_SPACE = 20;
	    const MIN_HEIGHT = 150;

	    let distFromAbove = $hoverButton.position().top;
	    const submenuHeight = $submenu.height();
	    const documentHeight = $(window).height();

	    // if the submenu is too high to be shown then set
	    // the overflow on y axis
	    if (submenuHeight + distFromAbove >= documentHeight) {

	        const currentSubmenuHeight = documentHeight - distFromAbove;
	        if (currentSubmenuHeight <= MIN_HEIGHT) {
	            distFromAbove = distFromAbove - submenuHeight + $hoverButton.outerHeight();
	        }
	        else {
	            $submenu.css({'max-height': currentSubmenuHeight - MIN_SPACE, 'overflow-y': 'auto'});
	        }

	    }

	    // set the submenu height
	    $submenu.css('top', `${distFromAbove}px`);

	};

	$(window).on('scroll', function(){

	    const UPPER_LIMIT = 32;
	    $(`#n-navbar`).height();
	    const windowScrollTop = $(this).scrollTop();

	    if (windowScrollTop >= UPPER_LIMIT) {
	        $(`#n-navbar`).addClass("scrolled bg-light");
	    }
	    else {
	        $(`#n-navbar`).removeClass("scrolled bg-light");
	    }

	});

	$(() => {

	    const toggleSidebar = () => {
	        // if the layer doesn't exists then create it
	        if ($(`.sidebar-close-layer`).length == 0) {

	            const $layer = $(`<div class='sidebar-close-layer' style='display:none'></div>`);
	            // when the user clicks on the layer
	            $layer.on('click', function(){
	                // remove active class from sidebar
	                $(`#n-sidebar`).removeClass('active');
	                // hide the layer and remove it from the DOM
	                $layer.fadeOut(function() {
	                    $(this).remove();
	                });
	            });

	            // append the layer to the wrapper
	            $(`#wrapper`).append($layer);
	            // show the layer inside the page
	            $layer.fadeIn();
	        }
	        else {
	            // hide the existing layer and destroy it
	            $(`.sidebar-close-layer`).fadeOut(function() {
	                $(this).remove();
	            });
	        }

	        // show/hide the sidebar
	        $(`#n-sidebar`).toggleClass('active');
	    };

	    $('#n-sidebar a.submenu').bind({
	        mouseenter: function() {
	            let submenu = $(this).parent().find(`div[id$='submenu']`);
	            fixSubMenuPosition(submenu, $(this));
	            submenu.show();
	        },
	        mouseleave: function() {
	            let submenu = $(this).parent().find(`div[id$='submenu']`);
	            submenu.hide();
	        }
	    });

	    $(`div[id$='submenu']`).bind({
	        mouseenter: function() {
	            $(this).show();
	        },
	        mouseleave: function() {
	            $(this).hide();
	        }
	    });

	    /* toggle sidebar display */
	    $(`button[data-bs-toggle='sidebar']`).on('click', function() {
	        toggleSidebar();
	    });
	});

	$(window).on('resize', function() {

	    // re-calc submenu height
	    const $currentSubmenu = $('#n-sidebar').find(`div.show[id$='submenu']`);

	    if ($currentSubmenu.length > 0) {

	        const $hoverButton = $currentSubmenu.parent().find(`a[data-bs-toggle='collapse']`);
	        fixSubMenuPosition($currentSubmenu, $hoverButton);
	    }

	});

	/**
	    (C) 2022 - ntop.org
	*/

	const ntopChartApex$1 = function() {
	    // define default chartOptions for all chart type.
	    const _default_BASE_ChartOptions = {
		series: [],
		chart: {
		    height: "100%",
		    width: "100%",
		    toolbar: {
			tools: {
			    zoomout: false,
			    download: false,
			    zoomin: false,
			    zoom: " ",
			    selection: false,
			    pan: false,
			    reset: false
			}
		    },
		    events: {}
		},
		xaxis: {
		    tooltip: {
			enabled: false,
		    },
		},
		yaxis: {
		    labels: {
			show: true,
			style: {
			    colors: [],
			    fontSize: "11px",
			    fontWeight: 400,
			    cssClass: ""
			}
		    },
		    title: {
			rotate: -90,
			offsetY: 0,
			offsetX: 0,
			style: {
			    fontSize: "11px",
			    fontWeight: 900,
			    cssClass: ""
			}
		    },
		    tooltip: {
			enabled: false,
		    },
		},
	    	grid: {
	    	    show: false,
	    	},
		legend: {
		    show: true
		},
	    };

	    // define default xaxis formatter for chart with datetime on xaxis.
	    const _setXTimeFormatter = function(chartOptions) {
		chartOptions.xaxis.labels.formatter = function(value, { series, seriesIndex, dataPointIndex, w }) {
		    return ntopng_utility$1.from_utc_to_server_date_format(value);
		};
	    };

	    // define default chartOptions for area chart type.
	    const _default_TS_STACKED_ChartOptions = function() {
	      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
	      let TS_STACKED_ChartOptions = {
	          chart: {
	        stacked: true,
	        type: "area",
	        zoom: {
	            enabled: true,
	            type: "x",
	        },
	          },
	          tooltip: {
	        // shared: true,
	        x: {
	            format: "dd MMM yyyy HH:mm:ss"
	        },
	        y: {}
	          },
	          xaxis: {
	        labels: {
	            show: true,
	            datetimeUTC: false,
	            formatter: null,
	        },
	        axisTicks: {
	            show: false,
	        },
	        type: "datetime",
	        axisBorder: {
	            show: true,
	        },
	        convertedCatToNumeric: false
	          },
	              dataLabels: {
	            enabled: false
	              },
	              stroke: {
	                show: false,
	                curve: "smooth"
	              },
	              fill: {
	                type: "solid"
	              },
	      };
	      ntopng_utility$1.copy_object_keys(TS_STACKED_ChartOptions, chartOptions, true);
	      return chartOptions;
	        }();
	    
	        
	    // define default chartOptions for area chart type.
	    const _default_TS_PIE_ChartOptions = function() {
		let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
		let TS_STACKED_ChartOptions = {
	    chart: {
	      stacked: true,
	      type: "polarArea",
	      height: 400
	    },
	    yaxis: {
	      show: true,
	      labels: {
	        formatter: NtopUtils$1.bytesToSize
	      }
	    },
	    dataLabels: {
	      enabled: true,
	    },
	    legend: {
	      enabled: true,
	      position: 'bottom',
	    },
	    stroke: {
	      show: false,
	      curve: "smooth"
	    },
	    fill: {
	      type: "solid"
	    },
	    tooltip: {
	      y: {
	        formatter: NtopUtils$1.bytesToSize
	      },
	    },
		};
		ntopng_utility$1.copy_object_keys(TS_STACKED_ChartOptions, chartOptions, true);
		return chartOptions;
	    }();

	    // define default chartOptions for line chart type.
	    const _default_TS_LINE_ChartOptions = function() {
		let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
		let TS_LINE_ChartOptions = {
		    chart: {
			type: "line",
			zoom: {
			    enabled: true,
			    type: "x",
			},
		    },
		    tooltip: {
			shared: true,
			x: {
			    format: "dd MMM yyyy HH:mm:ss"
			},
			y: {}
		    },
		    xaxis: {
			labels: {
			    show: false,
			    datetimeUTC: false,
			    formatter: null,
			},
			axisTicks: {
			    show: true
			},
			type: "datetime",
			axisBorder: {
			    show: true
			},
			convertedCatToNumeric: false
		    },
	    	    stroke: {
	    	    	show: true,
			width: 2,
	    	    	curve: "smooth"
	    	    },
	    	    grid: {
	    	    	show: true,
	    	    },
	    	    dataLabels: {
	    		enabled: false
	    	    },
		};
		ntopng_utility$1.copy_object_keys(TS_LINE_ChartOptions, chartOptions, true);
		return chartOptions;
	    }();
	    
	    return {
		typeChart: {
		    TS_LINE: "TS_LINE",
		    TS_STACKED: "TS_STACKED",
		    PIE: "PIE",
		    BASE: "BASE",
		},
		newChart: function(type) {
		    let _chartOptions = {};
		    let _chart;

		    if (type == this.typeChart.TS_STACKED) {
	        _chartOptions = ntopng_utility$1.clone(_default_TS_STACKED_ChartOptions);
	        _setXTimeFormatter(_chartOptions);
		    } else if (type == this.typeChart.TS_LINE) {
	        _chartOptions = ntopng_utility$1.clone(_default_TS_LINE_ChartOptions);
	        _setXTimeFormatter(_chartOptions);
		    } else if (type == this.typeChart.PIE) {
	        _chartOptions = ntopng_utility$1.clone(_default_TS_PIE_ChartOptions);
	      }  else if (type == this.typeChart.BASE) {
	        _chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
	      } else {
			throw `ntopChartApex::newChart: chart type = ${type} unsupported`;
		    }
		    
		    return {
			drawChart: function(htmlElement, chartOptions) {
			    // add/replace chartOptions fields in _chartOptions
			    if(chartOptions.yaxis && chartOptions.yaxis.labels && chartOptions.yaxis.labels.formatter) {
	          const formatter = chartOptions.yaxis.labels.formatter;
	          if(formatter == "formatValue") {
	            chartOptions.yaxis.labels.formatter = NtopUtils$1.formatValue;
	          }
	          else if(formatter == "bytesToSize") {
	            chartOptions.yaxis.labels.formatter = NtopUtils$1.bytesToSize;
	          }
	        }
	        ntopng_utility$1.copy_object_keys(chartOptions, _chartOptions, true);
	        _chart = new ApexCharts(htmlElement, _chartOptions);
			    _chart.render();
			},
			destroyChart: function() {
			    if (_chart == null) { return; }
			    _chart.destroy();
			},
			updateChart: function(chartOptions) {
			    if (_chart == null) { return; }
			    _chart.updateOptions(chartOptions, true);
			},
			registerEvent: function(eventName, callback, updateChart = false) {
			    _chartOptions.chart.events[eventName] = callback;
			    if (updateChart == true) {
				_chart.updateOptions(_chartOptions);	    
			    }
			},
		    };
		},
	    };
	}();

	/**
	 * (C) 2020-21 - ntop.org
	 * This file contains utilities used by the *new* datatables.
	 */


	const DataTableHandlers = function() {
	    let handlersIdDict = {};
	    return {
		addHandler: function(h) {
		    let handlers = handlersIdDict[h.handlerId];
		    if (handlers == null) {
			handlers = [];
			handlersIdDict[h.handlerId] = handlers;
		    }
		    handlers.push(() => {
			h.onClick();
		    });
		    return `window['_DataTableButtonsOnClick']('${h.handlerId}', '${handlers.length - 1}')`;
		},
		getHandler: function(handlerId, rowId) {
		    let handlers = handlersIdDict[handlerId];
		    if (handlers == null) { return null; }
		    return handlers[rowId];
		},
		deleteHandlersById: function(handlerId) {
		    handlersIdDict[handlerId] = null;
		},
	    }
	}();

	window["_DataTableButtonsOnClick"] = function(handlerId, rowId) {
	    let onClick = DataTableHandlers.getHandler(handlerId, rowId);
	    if (onClick != null) {
		onClick();
	    }
	};

	class DataTableFiltersMenu$1 {

	    /**
	     *
	     * @param {options}
	     */
	    constructor({ tableAPI, filterMenuKey, filterTitle, filters, columnIndex, icon = null, extraAttributes = "", id = null, url = null, urlParams = null, removeAllEntry = false, callbackFunction = null }) {
	        this.rawFilters = filters;
	        this.tableAPI = tableAPI;
	        this.filterTitle = filterTitle;
	        this.icon = icon;
	        this.filterMenuKey = filterMenuKey;
	        this.columnIndex = columnIndex;
	        this.preventUpdate = false;
	        this.currentFilterSelected = undefined;
	        this.$datatableWrapper = $(tableAPI.context[0].nTableWrapper);
	        this.extraAttributes = extraAttributes;
	        this.id = id;
	        this.url = url;
	        this.urlParams;
	        this.removeAllEntry = removeAllEntry;
	        this.callbackFunction = callbackFunction;
	      }

	    get selectedFilter() {
	        return this.currentFilterSelected;
	    }

	    init() {

	        const self = this;

	        // when the datatable has been initialized render the dropdown
	        this.$datatableWrapper.on('init.dt', function () {
	          self._render(self.rawFilters);
	        });

	        // on ajax reload then update the datatable entries
	        this.tableAPI.on('draw', function () {
	          self._update();
	        });

	        return self;
	    }

	    _countEntries(regex, data = []) {

	        if (regex === undefined) {
	            console.error("DataTableFiltersMenu::_countEntries() => the passed regex is undefined!");
	        }

	        const reg = new RegExp(regex);
	        return data.filter(cellValue => reg.test(cellValue)).length;
	    }

	    _createMenuEntry(filter) {

	        const self = this;
	        let $entry = $(`<li class='dropdown-item pointer'>${filter.label} </li>`);
	        
	        if(self.url) {
	          $entry = $(`<li class='dropdown-item pointer'><a href=# class='p-1 standard-color'>${filter.label} </li>`);

	          if(filter.currently_active == true) {
	            // set active filter title and key
	            if (self.$dropdown.title.parent().find(`i.fas`).length == 0) {
	              self.$dropdown.title.parent().prepend(`<i class='fas fa-filter'></i>`);
	            }

	            const newContent = $entry.html();
	            self.$dropdown.title.html(newContent);
	            // remove the active class from the li elements
	            self.$dropdown.container.find('li').removeClass(`active`);
	            // add active class to current entry
	            if(filter.key !== 'all') {
	              $entry.addClass(`active`);
	            }
	          }
	        } else if (filter.regex !== undefined && (filter.countable === undefined || filter.countable)) {
	            const data = this.tableAPI.columns(this.columnIndex).data()[0];
	            const count = this._countEntries(filter.regex, data);
	            const $counter = $(`<span class='counter'>(${count})</span>`);

	            // if the count is 0 then hide the menu entry
	            if (count == 0) $entry.hide();

	            //append the $counter object inside the $entry
	            $entry.append($counter);
	        }

	        $entry.on('click', function (e) {
	          // set active filter title and key
	          if (self.$dropdown.title.parent().find(`i.fas`).length == 0) {
	            self.$dropdown.title.parent().prepend(`<i class='fas fa-filter'></i>`);
	          }

	          const newContent = $entry.html();
	          self.$dropdown.title.html(newContent);
	          // remove the active class from the li elements
	          self.$dropdown.container.find('li').removeClass(`active`);
	          // add active class to current entry
	          if(filter.key !== 'all') {
	            $entry.addClass(`active`);
	          }

	          if(self.callbackFunction) {
	            self.callbackFunction(self.tableAPI, filter);
	            if(filter.callback) filter.callback();
	            return;
	          }

	          if(!self.url) {
	            self.preventUpdate = true;

	            // if the filter have a callback then call it
	            if (filter.callback) filter.callback();
	            // perform the table filtering
	            self.tableAPI.column(self.columnIndex).search(filter.regex, true, false).draw();
	            // set current filter
	            self.currentFilterSelected = filter;
	          } else {
	            self.urlParams = window.location.search;
	            const newUrlParams = new URLSearchParams(self.urlParams);
	            newUrlParams.set(self.filterMenuKey, (typeof(filter.id) != undefined) ? filter.id : '');
	            self.url + '?' + newUrlParams.toString();

	            window.history.pushState('', '', window.location.pathname + '?' + newUrlParams.toString());
	            location.reload();
	          }
	        });

	        return $entry;
	    }

	    _createFilters(filters) {

	        const filtersCreated = {};

	        // for each filter defined in this.filters
	        for (const filter of filters) {

	            const $filter = this._createMenuEntry(filter);
	            // save the filter inside the $filters object
	            filtersCreated[filter.key] = { filter: filter, $node: $filter };
	        }

	        return filtersCreated;
	    }

	    _render(filters) {
	      if(typeof this.columnIndex == 'undefined') {
	        $(`<span id="${this.id}" ${this.extraAttributes} title="${this.filterTitle}">${this.icon || this.filterTitle}</span>`).insertBefore(this.$datatableWrapper.find('.dataTables_filter').parent());
	      } else {
	        const $dropdownContainer = $(`<div id='${this.filterMenuKey}_dropdown' class='dropdown d-inline'></div>`);
	        const $dropdownButton = $(`<button class='btn-link btn dropdown-toggle' data-bs-toggle="dropdown" type='button'></button>`);
	        const $dropdownTitle = $(`<span class='filter-title'>${this.filterTitle}</span>`);
	        $dropdownButton.append($dropdownTitle);

	        this.$dropdown = {
	          container: $dropdownContainer,
	          title: $dropdownTitle,
	          button: $dropdownButton
	        };

	        this.filters = this._createFilters(filters);

	        const $menuContainer = $(`<ul class='dropdown-menu dropdown-menu-lg-end scrollable-dropdown' id='${this.filterMenuKey}_dropdown_menu'></ul>`);
	        for (const [_, filter] of Object.entries(this.filters)) {
	            $menuContainer.append(filter.$node);
	        }

	        // the All entry is created by the object
	        if(!this.removeAllEntry) {
	          const allFilter = this._generateAllFilter();
	          $menuContainer.prepend(this._createMenuEntry(allFilter));  
	        }
	        
	        // append the created dropdown inside
	        $dropdownContainer.append($dropdownButton);
	        $dropdownContainer.append($menuContainer);
	        // append the dropdown menu inside the filter wrapper
	        $dropdownContainer.insertBefore(this.$datatableWrapper.find('.dataTables_filter').parent());

	        this._selectFilterFromState(this.filterMenuKey);
	      }
	    }

	    _selectFilterFromState(filterKey) {

	        if (!this.tableAPI.state) return;
	        if (!this.tableAPI.state.loaded()) return;
	        if (!this.tableAPI.state.loaded().filters) return;

	        // save the current table state
	        tableAPI.state.save();
	    }

	    _generateAllFilter() {
	        return {
	            key: 'all',
	            label: i18n_ext.all,
	            regex: '',
	            countable: false,
	            callback: () => {
	                this.$dropdown.title.parent().find('i.fas.fa-filter').remove();
	                this.$dropdown.title.html(`${this.filterTitle}`);
	            }
	        };
	    }

	    _update() {

	        // if the filters have not been initialized by _render then return
	        if (this.filters === undefined) return;
	        if (this.preventUpdate) {
	            this.preventUpdate = false;
	            return;
	        }

	        for (const [_, filter] of Object.entries(this.filters)) {
	            if (filter.countable == false || filter.filter.countable == false) continue;

	            const data = this.tableAPI.columns(this.columnIndex).data()[0];
	            const count = this._countEntries(filter.filter.regex, data);

	            // hide the filter if the count is zero
	            (count == 0) ? filter.$node.hide() : filter.$node.show();
	            // update the counter label
	            filter.$node.find('.counter').text(`(${count})`);
	            // update the selected button counter
	            this.$dropdown.button.find('.counter').text(`(${count})`);
	        }
	    }

	}

	class DataTableUtils$1 {

	    /**
	     * Return a standard config for the Sprymedia (c) DataTables
	     */
	    static getStdDatatableConfig(dtButtons = [], dom = "<'row'<'col-sm-2 d-inline-block'l><'col-sm-10 text-end d-inline-block'<'dt-search'f>B>rtip>") {

	        // hide the buttons section if there aren't buttons inside the array
	        if (dtButtons.length == 0) {
	            dom = "fBrtip";
	        }

	        return {
	            dom: dom,
	            pagingType: 'full_numbers',
	            lengthMenu: [[10, 25, 50, 100, 250], [10, 25, 50, 100, 250]],
	            language: {
	                search: i18n.script_search,
	                paginate: {
	                    previous: '&lt;',
	                    next: '&gt;',
	                    first: '',
	                    last: ''
	                }
	            },
	            saveState: true,
	            responsive: true,
	            buttons: {
	                buttons: dtButtons,
	                dom: {
	                    button: {
	                        className: 'btn btn-link'
	                    },
	                    container: {
	                        className: 'd-inline-block'
	                    }
	                }
	            }
	        }
	    }

	    static createLinkCallback(action) {
		let handler = "";
		let fOnClick = DataTableHandlers.addHandler(action.handler);
		handler = `onclick="${fOnClick}"`;
		return `<a href=#
                   ${handler}>
                   ${action.text || ''}
                </a>`;
	    }

	    /**
	     * Example of action:
	     * {
	     *  class: string,
	     *  data: object,
	     *  icon: string,
	     *  modal: string,
	     *  href: string,
	     *  hidden: bool,
	     * }
	     * @param {*} actions
	     */
	    static createActionButtons(actions = []) {

	        const buttons = [];
	        const dropdownButton = '<button type="button" class="btn btn-sm btn-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false"><i class="fas fa-align-justify"></i></button>';

	        actions.forEach((action, i) => {
		    let handler = "";
		    if (action.handler) {
			let fOnClick = DataTableHandlers.addHandler(action.handler);
			handler = `onclick="${fOnClick}"`;
		    }
	            let button = (`
            <li>
                <a
                    ${(action.href || action.modal) ? `href='${action.href || action.modal}'` : ``}
                    ${handler}
                    ${(action.onclick) ? `onclick='${action.onclick}'` : ``}
                    ${action.modal ? "data-bs-toggle='modal'" : ``}
                    class='dropdown-item ${action.class ? action.class : ``}'
                    ${action.hidden ? "style='display: none'" : ``}
                    ${action.external ? "target='_about'" : ``}
                    >
                    <i class='fas ${action.icon}'></i> ${action.title || ''}
                </a>
            </li>
            `);
	            buttons.push(button);
	        });

	        const list = `<ul class="dropdown-menu">${buttons.join('')}</ul>`;

	        return (`<div class='dropdown'>${dropdownButton}${list}</div>`);
	    }

	    static deleteButtonHandlers(handlerId) {
		DataTableHandlers.deleteHandlersById(handlerId);
	    }

	    static setAjaxConfig(config, url, dataSrc = '', method = "get", params = {}) {

	        config.ajax = {
	            url: url,
	            type: method,
	            dataSrc: dataSrc,
	            data: function (d) {
	                return $.extend({}, d, params);
	            }
	        };

	        return config;
	    }

	    static extendConfig(config, extension) {

	        // if there are custom filters then manage state in this way
	        if (extension.hasFilters) {

	            extension.stateSaveCallback = function (settings, data) {
	                localStorage.setItem('DataTables_' + settings.sInstance, JSON.stringify(data));
	            };

	            extension.stateLoadCallback = function (settings) {
	                return JSON.parse(localStorage.getItem('DataTables_' + settings.sInstance));
	            };

	            // on saving the table state store the selected filters
	            extension.stateSaveParams = function (settings, data) {

	                // save the filters selected from the user inside the state
	                $('[data-filter]').each(function () {

	                    const activeFilter = $(this).find(`li.active`).data('filter-key');
	                    if (!activeFilter) return;

	                    // if the filters object is not allocated then initizializes it
	                    if (!data.filters) data.filters = {};
	                    data.filters[$(this).data('filter')] = activeFilter;

	                });
	            };
	        }

	        // const userInitComplete = extension.initComplete;

	        // const initComplete = (settings, json) => {
	        //     if (userInitComplete !== undefined) userInitComplete(settings, json);
	        //     // turn on tooltips
	        //     $(`.actions-group [title]`).tooltip('enable');
	        // };

	        // // override initComplete function
	        // extension.initComplete = initComplete;

	        return $.extend({}, config, extension);
	    }

	    /**
	     * Format the passed seconds into the "HH:MM:SS" string.
	     * @param {number} seconds
	     */
	    static secondsToHHMMSS(seconds) {

	        const padZeroes = n => `${n}`.padStart(2, '0');

	        const sec = seconds % 60;
	        const mins = Math.floor(seconds / 60) % 60;
	        const hours = Math.floor(seconds / 3600);

	        return `${padZeroes(hours)}:${padZeroes(mins)}:${padZeroes(sec)}`;
	    }

	    /**
	    * Open the pool edit modal of a chosen pool if the query params contains the pool paramater
	    * @param tableAPI
	    */
	    static openEditModalByQuery(params) {

	        const urlParams = new URLSearchParams(window.location.search);
	        if (!urlParams.has(params.paramName)) return;

	        const dataID = urlParams.get(params.paramName);
	        const data = params.datatableInstance.data().toArray().find((data => data[params.paramName] == dataID));

	        // if the cancelIf param has been passed
	        // then test the cancelIf function, if the return value
	        // is true then cancel the modal opening
	        if (typeof (params.cancelIf) === 'function') {
	            if (params.cancelIf(data)) return;
	        }

	        const $modal = $(`#${params.modalHandler.getModalID()}`);

	        // if the pool id is valid then open the edit modal
	        if (data !== undefined) {
	            params.modalHandler.invokeModalInit(data);
	            $modal.modal('show');
	        }

	        if (!urlParams.has('referer')) {
	            $modal.on('hidden.bs.modal', function (e) {

	                const url = new URL(window.location.href);
	                url.searchParams.delete(params.paramName);

	                history.replaceState({}, '', url.toString());
	            });
	            return;
	        }
	        const referer = urlParams.get('referer');

	        $modal.on('hidden.bs.modal', function (e) {
	            window.location = referer;
	        });
	    }

	    static addToggleColumnsDropdown(tableAPI, toggleCallback = (col, visible) => {}) {

	        if (tableAPI === undefined) {
	            throw 'The $table is undefined!';
	        }

	        const tableID = tableAPI.table().node().id;

	        DataTableUtils$1._loadColumnsVisibility(tableAPI).then(function (fetchedData) {

	            let savedColumns = [-1];
	            if (fetchedData.success) {
	                savedColumns = fetchedData.columns.map(i => parseInt(i));
	            }
	            else {
	                console.warn(fetchedData.message);
	            }

	            const columns = [];
	            const ignoredColumns = [];
	            const $datatableWrapper = $(tableAPI.context[0].nTableWrapper);

	            // get the table headers 
	            tableAPI.columns().every(function (i) {

	                // avoid already hidden columns
	                if (!tableAPI.column(i).visible()) {
	                    ignoredColumns.push(i);
	                    return;
	                }

	                columns.push({ index: i, name: this.header().textContent, label: this.i18n.name /* Human-readable column name */ });
	            });

	            const $btnGroup = $(`
                <div class="btn-group">
                    <button type="button" class="btn btn-link dropdown-toggle" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        <i class="fas fa-eye"></i>
                    </button>
                </div>
            `);

	            const $dropdownMenu = $(`<div class="dropdown-menu dropdown-menu-right" style='width: max-content;'><h6 class="dropdown-header">Show Columns</h6></div>`);
	            const $checkboxes = $(`<div class='px-4'></div>`);

	            for (let i = 0; i < columns.length; i++) {
	                const column = columns[i];

			// Prevents columns with no names to be selectively hidden (e.g., the entity under the all alerts page)
			if(column.name == "")
			    continue;

	                // create a checkbox and delegate a change event
	                const id = `toggle-${column.name.split().join('_')}`; 

	                // check if the column id it's inside the savedColumns array
	                // if toggled is true then the column is not hidden
	                const toggled = savedColumns.indexOf(column.index) === -1;
	                if (!toggled) {
	                    const col = tableAPI.column(column.index);
	                    col.visible(false);
	                }

	                const $checkbox = $(`<input class="form-check-input" ${(toggled ? 'checked' : '')} type="checkbox" id="${id}">`);
	                const $wrapper = $(`
                    <div class="form-check form-switch">
                        <label class="form-check-label" for="${id}">
                            ${column.name}
                        </label>
                    </div>
                `);

	                $checkbox.on('change', function (e) {
	                    $(`.overlay`).toggle(500);
	                    
	                    // Get the column API object
	                    const col = tableAPI.column(column.index);
	                    // Toggle the visibility
	                    col.visible(!col.visible());

	                    const visible = col.visible();

	                    const hiddenColumns = [];
	                    // insert inside the array only the hidden columns
	                    tableAPI.columns().every(function(i) {
	                        if (tableAPI.column(i).visible() || ignoredColumns.indexOf(i) !== -1) return;
	                        hiddenColumns.push(i); 
	                    });

	                    // save the table view inside redis
	                    $.post(`${http_prefix}/lua/datatable_columns.lua`, {
	                        action: 'save', table: tableID, columns: hiddenColumns.join(','), csrf: window.__CSRF_DATATABLE__
	                    }).then(function(data) {
	                        if (data.success) return;
	                        console.warn(data.message);
	                    });

	                    if (toggleCallback !== undefined) {
	                        toggleCallback(col, visible);
	                    }

	                });

	                $wrapper.prepend($checkbox);
	                $checkboxes.append($wrapper);
	            }

	            $dropdownMenu.on("click.bs.dropdown", function (e) { e.stopPropagation(); });

	            // append the new node inside the datatable
	            $btnGroup.append($dropdownMenu.append($checkboxes));
	            $datatableWrapper.find('.dt-search').parent().append($btnGroup);
	        });
	    }

	    static async _loadColumnsVisibility(tableAPI) {
	        const tableID = tableAPI.table().node().id;
	        return $.get(`${http_prefix}/lua/datatable_columns.lua?table=${tableID}&action=load`);
	    }

	}

	class DataTableRenders$1 {

	    static alertSeverityAndType(severity, type, alert) {
	        return `${DataTableRenders$1.formatValueLabel(severity, type, alert)} ${DataTableRenders$1.formatValueLabel(alert.alert_id, type, alert)}`;
	    }

	    static hideIfZero(obj, type, row) {
	        let color = (obj.color !== undefined ? obj.color : "#aaa");
	        let value = (obj.value !== undefined ? obj.value : obj);
	        if (type === "display" && parseInt(value) === 0) color = "#aaa";
	        let span = `<span style='color: ${color}'>${NtopUtils$1.fint(value)}</span>`;
	        if (obj.url !== undefined) span = `<a href="${obj.url}">${span}</a>`;
	        return span;
	    }

	    static secondsToTime(seconds, type, row) {
	        if (type === "display") return NtopUtils$1.secondsToTime(seconds);
	        return seconds;
	    }

	    static filterize(key, value, label, tag_label, title, html) {
	        return `<a class='tag-filter' data-tag-key='${key}' title='${title || value}' data-tag-value='${value}' data-tag-label='${tag_label || label || value}' href='#'>${html || label || value}</a>`;
	    }

	    static formatValueLabel(obj, type, row) {
	        if (type !== "display") return obj.value;
	        let cell = obj.label;
	        if (obj.color) cell = `<span class='font-weight-bold' style='color: ${obj.color}'>${cell}</span>`;
	        return cell;
	    }

	    static formatMessage(obj, type, row) {
	        if (type !== "display") return obj.value;
	           
	        let cell = obj.descr;
	        if (obj.shorten_descr)
	            cell = `<span title="${obj.descr}">${obj.shorten_descr}</span>`;

	        return cell;
	    }

	    static formatSubtype(obj, type, row) {
	        if (type !== "display") return obj;

	        let label = DataTableRenders$1.filterize('subtype', obj, obj);

	        return label; 
	    }

	    static getFormatGenericField(field) {
		return function(obj, type, row) {
	            if (type !== "display") return obj.value;
	    	    let html_ref = '';
		    if (obj.reference !== undefined)
			html_ref = obj.reference;
	            let label = DataTableRenders$1.filterize(field, row[field].value, row[field].label, row[field].label, row[field].label);
	            return label + ' ' + html_ref;
		}
	    }

	    static formatSNMPInterface(obj, type, row) {
	        if (type !== "display") return obj.value;
	        let cell = DataTableRenders$1.filterize('snmp_interface', obj.value, obj.label, obj.label, obj.label);
	        if (obj.color) cell = `<span class='font-weight-bold' style='color: ${obj.color}'>${cell}</span>`;
	        return cell;
	    }

	    static formatSNMPIP(obj, type, row) {
	        if (type !== "display") return obj;
	        return DataTableRenders$1.filterize('ip', obj, obj, obj, obj);
	    }

	    static formatProbeIP(obj, type, row) {
	        if (type !== "display") return obj;

		let label = DataTableRenders$1.filterize('probe_ip', obj.value, obj.label, obj.label, obj.label_long);

	        return label; 
	    }
	   
	    static formatHost(obj, type, row) {
	        if (type !== "display") return obj;
	    	let html_ref = '';
		if (obj.reference !== undefined)
		   html_ref = obj.reference;
		let label = "";

		let hostKey, hostValue;
	        if (obj.label && obj.label != obj.value) {
		    hostKey = "name";
		    hostValue = obj.label_long;
	            label = DataTableRenders$1.filterize('name', obj.label_long, obj.label, obj.label, obj.label_long);
		}
	        else {
		    hostKey = "ip";
		    hostValue = obj.value;
	            label = DataTableRenders$1.filterize('ip', obj.value, obj.label, obj.label, obj.label_long);
		}

	        if (row.vlan_id && row.vlan_id != "" && row.vlan_id != "0") {
	            label = DataTableRenders$1.filterize(hostKey, `${hostValue}@${row.vlan_id}`, `${obj.label}@${row.vlan_id}`, `${obj.label}@${row.vlan_id}`, `${obj.label_long}@${row.vlan_id}`);
		}

	        if (obj.country)
	            label = label + DataTableRenders$1.filterize('country', obj.country, obj.country, obj.country, obj.country, ' <img src="' + http_prefix + '/dist/images/blank.gif" class="flag flag-' + obj.country.toLowerCase() + '"></a> ');

	        if (row.role && row.role.value == 'attacker')
	          label = label + ' ' + DataTableRenders$1.filterize('role', row.role.value, 
	            '<i class="fas fa-skull" title="'+row.role.label+'"></i>', row.role.label);
	        else if (row.role && row.role.value == 'victim')
	          label = label + ' ' + DataTableRenders$1.filterize('role', row.role.value,
	            '<i class="fas fa-sad-tear" title="'+row.role.label+'"></i>', row.role.label);

	        if (row.role_cli_srv && row.role_cli_srv.value == 'client')
	          label = label + ' ' + DataTableRenders$1.filterize('role_cli_srv', row.role_cli_srv.value, 
	            '<i class="fas fa-long-arrow-alt-right" title="'+row.role_cli_srv.label+'"></i>', row.role_cli_srv.label);
	        else if (row.role_cli_srv && row.role_cli_srv.value == 'server')
	          label = label + ' ' + DataTableRenders$1.filterize('role_cli_srv', row.role_cli_srv.value,
	            '<i class="fas fa-long-arrow-alt-left" title="'+row.role_cli_srv.label+'"></i>', row.role_cli_srv.label);

	        return label + ' ' + html_ref; 
	    }

	    static filterizeVlan(flow, row, key, value, label, title) {
		let valueVlan = value;
	  let labelVlan = label;
		let titleVlan = title;
		if (flow.vlan && flow.vlan.value != 0) {
		    valueVlan = `${value}@${flow.vlan.value}`;
		    labelVlan = `${label}@${flow.vlan.label}`;
		    titleVlan = `${title}@${flow.vlan.title}`;
		}
	      labelVlan = NtopUtils$1.shortenLabel(labelVlan, 16, ".");
	      return DataTableRenders$1.filterize(key, valueVlan, labelVlan, labelVlan, titleVlan); 
	    }

	    static formatFlowTuple(flow, type, row) {
	      let active_ref = (flow.active_url ? `<a href="${flow.active_url}"><i class="fas fa-stream"></i></a>` : "");

	        let cliLabel = "";
	        if (flow.cli_ip.name) {
	          let title = "";
	            if(flow.cli_ip.label_long) title = flow.cli_ip.value + " [" + flow.cli_ip.label_long + "]";
	            cliLabel = DataTableRenders$1.filterizeVlan(flow, row, 'cli_name', flow.cli_ip.name, flow.cli_ip.label, title); 
	        } else
	            cliLabel = DataTableRenders$1.filterizeVlan(flow, row, 'cli_ip', flow.cli_ip.value, flow.cli_ip.label, flow.cli_ip.label_long); 

	        let cliFlagLabel= '';

	        if (flow.cli_ip.country && flow.cli_ip.country !== "nil")
	            cliFlagLabel = DataTableRenders$1.filterize('cli_country', flow.cli_ip.country, flow.cli_ip.country, flow.cli_ip.country, flow.cli_ip.country, ' <img src="' + http_prefix + '/dist/images/blank.gif" class="flag flag-' + flow.cli_ip.country.toLowerCase() + '"></a> ');

	        let cliPortLabel = ((flow.cli_port && flow.cli_port > 0) ? ":"+DataTableRenders$1.filterize('cli_port', flow.cli_port, flow.cli_port) : "");

	        let cliBlacklisted ='';
	        if(flow.cli_ip.blacklisted == true) 
	          cliBlacklisted = " <i class=\'fas fa-ban fa-sm\' title=\'" + i18n("hosts_stats.blacklisted") + "\'></i>";

	        let srvLabel = "";
	        if (flow.srv_ip.name) {
	          let title = "";
	          if(flow.srv_ip.label_long) title = flow.srv_ip.value + " [" + flow.srv_ip.label_long + "]";
	            srvLabel = DataTableRenders$1.filterizeVlan(flow, row, 'srv_name', flow.srv_ip.name, flow.srv_ip.label, title);
	        } else
	            srvLabel = DataTableRenders$1.filterizeVlan(flow, row, 'srv_ip', flow.srv_ip.value, flow.srv_ip.label, flow.srv_ip.label_long);
	        let srvPortLabel = ((flow.cli_port && flow.cli_port > 0) ? ":"+DataTableRenders$1.filterize('srv_port', flow.srv_port, flow.srv_port) : "");

	        let srvFlagLabel= '';

	        if (flow.srv_ip.country && flow.srv_ip.country !== "nil")
	            srvFlagLabel = DataTableRenders$1.filterize('srv_country', flow.srv_ip.country, flow.srv_ip.country, flow.srv_ip.country, flow.srv_ip.country, ' <img src="' + http_prefix + '/dist/images/blank.gif" class="flag flag-' + flow.srv_ip.country.toLowerCase() + '"></a> ');

	        let srvBlacklisted ='';
	        if(flow.srv_ip.blacklisted == true) 
	          srvBlacklisted = " <i class=\'fas fa-ban fa-sm\' title=\'" + i18n("hosts_stats.blacklisted") + "\'></i>";
	    
	        let cliIcons = "";
	        let srvIcons = "";
	        if (row.cli_role) {
	            if (row.cli_role.value == 'attacker')
	                cliIcons += DataTableRenders$1.filterize('role', 'attacker', '<i class="fas fa-skull" title="'+row.cli_role.label+'"></i>', row.cli_role.tag_label);
	            else if (row.cli_role.value == 'victim')
	                cliIcons += DataTableRenders$1.filterize('role', 'victim',  '<i class="fas fa-sad-tear" title="'+row.cli_role.label+'"></i>', row.cli_role.tag_label);
	        }

	        if (row.srv_role) {
	            if (row.srv_role.value == 'attacker')
	                srvIcons += DataTableRenders$1.filterize('role', 'attacker', '<i class="fas fa-skull" title="'+row.srv_role.label+'"></i>', row.srv_role.tag_label);
	            else if (row.srv_role.value == 'victim')
	                srvIcons += DataTableRenders$1.filterize('role', 'victim',  '<i class="fas fa-sad-tear" title="'+row.srv_role.label+'"></i>', row.srv_role.tag_label);
	        }

	        return `${active_ref} ${cliLabel}${cliBlacklisted}${cliFlagLabel}${cliPortLabel} ${cliIcons} ${flow.cli_ip.reference} <i class="fas fa-exchange-alt fa-lg" aria-hidden="true"></i> ${srvLabel}${srvBlacklisted}${srvFlagLabel}${srvPortLabel} ${srvIcons} ${flow.srv_ip.reference}`;
	    }

	    static formatNameDescription(obj, type, row) {
	        if (type !== "display") return obj.name;
	        let msg = DataTableRenders$1.filterize('alert_id', obj.value, obj.name, obj.fullname, obj.fullname);

		/* DECIDED NOT TO SHOW SHORTENED DESCRIPTIONS IN THE ALERT COLUMNS
	        if(obj.description) {
	           const strip_tags = function(html) { let t = document.createElement("div"); t.innerHTML = html; return t.textContent || t.innerText || ""; }
	           let desc = strip_tags(obj.description);
	           if(desc.startsWith(obj.name)) desc = desc.replace(obj.name, "");
	           let name_len = strip_tags(obj.name).length;
	           let desc_len = desc.length;
	           let total_len = name_len + desc_len;
	           let tooltip = ""

	           let limit = 30; // description limit
	           if (row.family != 'flow') {
	             limit = 50; // some families have room for bigger descriptions
	           }

	           if (total_len > limit) { // cut and set a tooltip
	             if (name_len >= limit) {
	               desc = ""; // name is already too long, no description
	             } else { // cut the description
	               desc = desc.substr(0, limit - obj.name.length);
	               desc = desc.replace(/\s([^\s]*)$/, ''); // word break
	               desc = desc + '&hellip;'; // add '...'
	             }
	             tooltip = strip_tags(obj.description);
	           }

	           msg = msg + ': <span title="' + tooltip + '">' + desc + '</span>';
	        }
		*/

	        return msg;
	    }

	    static applyCellStyle(cell, cellData, rowData, rowIndex, colIndex) {
	      if (cellData.highlight) {
	         $(cell).css("border-left", "5px solid "+cellData.highlight);
	      }
	   }
	}

	window.do_pie = do_pie;

	window.DataTableUtils = DataTableUtils$1;
	window.DataTableFiltersMenu = DataTableFiltersMenu$1;
	window.DataTableRenders = DataTableRenders$1;

	window.ChartWidget = ChartWidget;
	window.WidgetUtils = WidgetUtils;
	window.ntopChartApex = ntopChartApex$1;

	/* Handle Blog Notifications */
	$(function () {

	  function blogNotifcationClick(e) {

	    if (e.type == "mousedown" && (e.metaKey || e.ctrlKey || e.which !== 2)) return;

	    const id = $(this).data('id');

	    $.post(`${http_prefix}/lua/update_blog_posts.lua`, {
	      blog_notification_id: id,
	      csrf: window.__BLOG_NOTIFICATION_CSRF__
	    },
	      (data) => {

	        if (data.success) {

	          $(this).off('click').off('mousedown').attr('data-read', 'true').data('read', 'true').find('.badge').remove();
	          
	          const count = $(`.blog-notification[data-read='false']`).length;

	          if (count == 0) {
	            $('.notification-bell').remove();
	          }
	          else {
	            $('.notification-bell').html(count);
	          }
	        }
	      });
	  }

	  // on the notifications not yet read delegate the click event
	  $(`.blog-notification[data-read='false']`).on('click', blogNotifcationClick).on('mousedown', blogNotifcationClick);
	});

	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 * IMPORTANT: all calls of this function must be prefixed with
	 * \/\*#\_\_PURE\_\_\*\/
	 * So that rollup can tree-shake them if necessary.
	 */
	function makeMap(str, expectsLowerCase) {
	    const map = Object.create(null);
	    const list = str.split(',');
	    for (let i = 0; i < list.length; i++) {
	        map[list[i]] = true;
	    }
	    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
	}

	/**
	 * dev only flag -> name mapping
	 */
	const PatchFlagNames = {
	    [1 /* TEXT */]: `TEXT`,
	    [2 /* CLASS */]: `CLASS`,
	    [4 /* STYLE */]: `STYLE`,
	    [8 /* PROPS */]: `PROPS`,
	    [16 /* FULL_PROPS */]: `FULL_PROPS`,
	    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
	    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
	    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
	    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
	    [512 /* NEED_PATCH */]: `NEED_PATCH`,
	    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
	    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
	    [-1 /* HOISTED */]: `HOISTED`,
	    [-2 /* BAIL */]: `BAIL`
	};

	/**
	 * Dev only
	 */
	const slotFlagsText = {
	    [1 /* STABLE */]: 'STABLE',
	    [2 /* DYNAMIC */]: 'DYNAMIC',
	    [3 /* FORWARDED */]: 'FORWARDED'
	};

	const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
	    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
	    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
	const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

	const range = 2;
	function generateCodeFrame(source, start = 0, end = source.length) {
	    // Split the content into individual lines but capture the newline sequence
	    // that separated each line. This is important because the actual sequence is
	    // needed to properly take into account the full line length for offset
	    // comparison
	    let lines = source.split(/(\r?\n)/);
	    // Separate the lines and newline sequences into separate arrays for easier referencing
	    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
	    lines = lines.filter((_, idx) => idx % 2 === 0);
	    let count = 0;
	    const res = [];
	    for (let i = 0; i < lines.length; i++) {
	        count +=
	            lines[i].length +
	                ((newlineSequences[i] && newlineSequences[i].length) || 0);
	        if (count >= start) {
	            for (let j = i - range; j <= i + range || end > count; j++) {
	                if (j < 0 || j >= lines.length)
	                    continue;
	                const line = j + 1;
	                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
	                const lineLength = lines[j].length;
	                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
	                if (j === i) {
	                    // push underline
	                    const pad = start - (count - (lineLength + newLineSeqLength));
	                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
	                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
	                }
	                else if (j > i) {
	                    if (end > count) {
	                        const length = Math.max(Math.min(end - count, lineLength), 1);
	                        res.push(`   |  ` + '^'.repeat(length));
	                    }
	                    count += lineLength + newLineSeqLength;
	                }
	            }
	            break;
	        }
	    }
	    return res.join('\n');
	}

	/**
	 * On the client we only need to offer special cases for boolean attributes that
	 * have different names from their corresponding dom properties:
	 * - itemscope -> N/A
	 * - allowfullscreen -> allowFullscreen
	 * - formnovalidate -> formNoValidate
	 * - ismap -> isMap
	 * - nomodule -> noModule
	 * - novalidate -> noValidate
	 * - readonly -> readOnly
	 */
	const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
	const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
	/**
	 * Boolean attributes should be included if the value is truthy or ''.
	 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
	 */
	function includeBooleanAttr(value) {
	    return !!value || value === '';
	}

	function normalizeStyle(value) {
	    if (isArray(value)) {
	        const res = {};
	        for (let i = 0; i < value.length; i++) {
	            const item = value[i];
	            const normalized = isString(item)
	                ? parseStringStyle(item)
	                : normalizeStyle(item);
	            if (normalized) {
	                for (const key in normalized) {
	                    res[key] = normalized[key];
	                }
	            }
	        }
	        return res;
	    }
	    else if (isString(value)) {
	        return value;
	    }
	    else if (isObject(value)) {
	        return value;
	    }
	}
	const listDelimiterRE = /;(?![^(]*\))/g;
	const propertyDelimiterRE = /:(.+)/;
	function parseStringStyle(cssText) {
	    const ret = {};
	    cssText.split(listDelimiterRE).forEach(item => {
	        if (item) {
	            const tmp = item.split(propertyDelimiterRE);
	            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
	        }
	    });
	    return ret;
	}
	function normalizeClass(value) {
	    let res = '';
	    if (isString(value)) {
	        res = value;
	    }
	    else if (isArray(value)) {
	        for (let i = 0; i < value.length; i++) {
	            const normalized = normalizeClass(value[i]);
	            if (normalized) {
	                res += normalized + ' ';
	            }
	        }
	    }
	    else if (isObject(value)) {
	        for (const name in value) {
	            if (value[name]) {
	                res += name + ' ';
	            }
	        }
	    }
	    return res.trim();
	}
	function normalizeProps(props) {
	    if (!props)
	        return null;
	    let { class: klass, style } = props;
	    if (klass && !isString(klass)) {
	        props.class = normalizeClass(klass);
	    }
	    if (style) {
	        props.style = normalizeStyle(style);
	    }
	    return props;
	}

	// These tag configs are shared between compiler-dom and runtime-dom, so they
	// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
	const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
	    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
	    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
	    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
	    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
	    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
	    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
	    'option,output,progress,select,textarea,details,dialog,menu,' +
	    'summary,template,blockquote,iframe,tfoot';
	// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
	const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
	    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
	    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
	    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
	    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
	    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
	    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
	    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
	    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
	    'text,textPath,title,tspan,unknown,use,view';
	const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
	/**
	 * Compiler only.
	 * Do NOT use in runtime code paths unless behind `true` flag.
	 */
	const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
	/**
	 * Compiler only.
	 * Do NOT use in runtime code paths unless behind `true` flag.
	 */
	const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
	/**
	 * Compiler only.
	 * Do NOT use in runtime code paths unless behind `true` flag.
	 */
	const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

	function looseCompareArrays(a, b) {
	    if (a.length !== b.length)
	        return false;
	    let equal = true;
	    for (let i = 0; equal && i < a.length; i++) {
	        equal = looseEqual(a[i], b[i]);
	    }
	    return equal;
	}
	function looseEqual(a, b) {
	    if (a === b)
	        return true;
	    let aValidType = isDate(a);
	    let bValidType = isDate(b);
	    if (aValidType || bValidType) {
	        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
	    }
	    aValidType = isSymbol(a);
	    bValidType = isSymbol(b);
	    if (aValidType || bValidType) {
	        return a === b;
	    }
	    aValidType = isArray(a);
	    bValidType = isArray(b);
	    if (aValidType || bValidType) {
	        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
	    }
	    aValidType = isObject(a);
	    bValidType = isObject(b);
	    if (aValidType || bValidType) {
	        /* istanbul ignore if: this if will probably never be called */
	        if (!aValidType || !bValidType) {
	            return false;
	        }
	        const aKeysCount = Object.keys(a).length;
	        const bKeysCount = Object.keys(b).length;
	        if (aKeysCount !== bKeysCount) {
	            return false;
	        }
	        for (const key in a) {
	            const aHasKey = a.hasOwnProperty(key);
	            const bHasKey = b.hasOwnProperty(key);
	            if ((aHasKey && !bHasKey) ||
	                (!aHasKey && bHasKey) ||
	                !looseEqual(a[key], b[key])) {
	                return false;
	            }
	        }
	    }
	    return String(a) === String(b);
	}
	function looseIndexOf(arr, val) {
	    return arr.findIndex(item => looseEqual(item, val));
	}

	/**
	 * For converting {{ interpolation }} values to displayed strings.
	 * @private
	 */
	const toDisplayString = (val) => {
	    return isString(val)
	        ? val
	        : val == null
	            ? ''
	            : isArray(val) ||
	                (isObject(val) &&
	                    (val.toString === objectToString || !isFunction(val.toString)))
	                ? JSON.stringify(val, replacer, 2)
	                : String(val);
	};
	const replacer = (_key, val) => {
	    // can't use isRef here since @vue/shared has no deps
	    if (val && val.__v_isRef) {
	        return replacer(_key, val.value);
	    }
	    else if (isMap(val)) {
	        return {
	            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
	                entries[`${key} =>`] = val;
	                return entries;
	            }, {})
	        };
	    }
	    else if (isSet(val)) {
	        return {
	            [`Set(${val.size})`]: [...val.values()]
	        };
	    }
	    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
	        return String(val);
	    }
	    return val;
	};

	const EMPTY_OBJ = Object.freeze({})
	    ;
	const EMPTY_ARR = Object.freeze([]) ;
	const NOOP = () => { };
	/**
	 * Always return false.
	 */
	const NO = () => false;
	const onRE = /^on[^a-z]/;
	const isOn = (key) => onRE.test(key);
	const isModelListener = (key) => key.startsWith('onUpdate:');
	const extend = Object.assign;
	const remove = (arr, el) => {
	    const i = arr.indexOf(el);
	    if (i > -1) {
	        arr.splice(i, 1);
	    }
	};
	const hasOwnProperty = Object.prototype.hasOwnProperty;
	const hasOwn = (val, key) => hasOwnProperty.call(val, key);
	const isArray = Array.isArray;
	const isMap = (val) => toTypeString(val) === '[object Map]';
	const isSet = (val) => toTypeString(val) === '[object Set]';
	const isDate = (val) => toTypeString(val) === '[object Date]';
	const isFunction = (val) => typeof val === 'function';
	const isString = (val) => typeof val === 'string';
	const isSymbol = (val) => typeof val === 'symbol';
	const isObject = (val) => val !== null && typeof val === 'object';
	const isPromise = (val) => {
	    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
	};
	const objectToString = Object.prototype.toString;
	const toTypeString = (value) => objectToString.call(value);
	const toRawType = (value) => {
	    // extract "RawType" from strings like "[object RawType]"
	    return toTypeString(value).slice(8, -1);
	};
	const isPlainObject = (val) => toTypeString(val) === '[object Object]';
	const isIntegerKey = (key) => isString(key) &&
	    key !== 'NaN' &&
	    key[0] !== '-' &&
	    '' + parseInt(key, 10) === key;
	const isReservedProp = /*#__PURE__*/ makeMap(
	// the leading comma is intentional so empty string "" is also included
	',key,ref,ref_for,ref_key,' +
	    'onVnodeBeforeMount,onVnodeMounted,' +
	    'onVnodeBeforeUpdate,onVnodeUpdated,' +
	    'onVnodeBeforeUnmount,onVnodeUnmounted');
	const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
	const cacheStringFunction = (fn) => {
	    const cache = Object.create(null);
	    return ((str) => {
	        const hit = cache[str];
	        return hit || (cache[str] = fn(str));
	    });
	};
	const camelizeRE = /-(\w)/g;
	/**
	 * @private
	 */
	const camelize = cacheStringFunction((str) => {
	    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
	});
	const hyphenateRE = /\B([A-Z])/g;
	/**
	 * @private
	 */
	const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
	/**
	 * @private
	 */
	const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
	/**
	 * @private
	 */
	const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
	// compare whether a value has changed, accounting for NaN.
	const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
	const invokeArrayFns = (fns, arg) => {
	    for (let i = 0; i < fns.length; i++) {
	        fns[i](arg);
	    }
	};
	const def = (obj, key, value) => {
	    Object.defineProperty(obj, key, {
	        configurable: true,
	        enumerable: false,
	        value
	    });
	};
	const toNumber = (val) => {
	    const n = parseFloat(val);
	    return isNaN(n) ? val : n;
	};
	let _globalThis;
	const getGlobalThis = () => {
	    return (_globalThis ||
	        (_globalThis =
	            typeof globalThis !== 'undefined'
	                ? globalThis
	                : typeof self !== 'undefined'
	                    ? self
	                    : typeof window !== 'undefined'
	                        ? window
	                        : typeof global !== 'undefined'
	                            ? global
	                            : {}));
	};

	function warn(msg, ...args) {
	    console.warn(`[Vue warn] ${msg}`, ...args);
	}

	let activeEffectScope;
	class EffectScope {
	    constructor(detached = false) {
	        /**
	         * @internal
	         */
	        this.active = true;
	        /**
	         * @internal
	         */
	        this.effects = [];
	        /**
	         * @internal
	         */
	        this.cleanups = [];
	        if (!detached && activeEffectScope) {
	            this.parent = activeEffectScope;
	            this.index =
	                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
	        }
	    }
	    run(fn) {
	        if (this.active) {
	            const currentEffectScope = activeEffectScope;
	            try {
	                activeEffectScope = this;
	                return fn();
	            }
	            finally {
	                activeEffectScope = currentEffectScope;
	            }
	        }
	        else {
	            warn(`cannot run an inactive effect scope.`);
	        }
	    }
	    /**
	     * This should only be called on non-detached scopes
	     * @internal
	     */
	    on() {
	        activeEffectScope = this;
	    }
	    /**
	     * This should only be called on non-detached scopes
	     * @internal
	     */
	    off() {
	        activeEffectScope = this.parent;
	    }
	    stop(fromParent) {
	        if (this.active) {
	            let i, l;
	            for (i = 0, l = this.effects.length; i < l; i++) {
	                this.effects[i].stop();
	            }
	            for (i = 0, l = this.cleanups.length; i < l; i++) {
	                this.cleanups[i]();
	            }
	            if (this.scopes) {
	                for (i = 0, l = this.scopes.length; i < l; i++) {
	                    this.scopes[i].stop(true);
	                }
	            }
	            // nested scope, dereference from parent to avoid memory leaks
	            if (this.parent && !fromParent) {
	                // optimized O(1) removal
	                const last = this.parent.scopes.pop();
	                if (last && last !== this) {
	                    this.parent.scopes[this.index] = last;
	                    last.index = this.index;
	                }
	            }
	            this.active = false;
	        }
	    }
	}
	function effectScope(detached) {
	    return new EffectScope(detached);
	}
	function recordEffectScope(effect, scope = activeEffectScope) {
	    if (scope && scope.active) {
	        scope.effects.push(effect);
	    }
	}
	function getCurrentScope() {
	    return activeEffectScope;
	}
	function onScopeDispose(fn) {
	    if (activeEffectScope) {
	        activeEffectScope.cleanups.push(fn);
	    }
	    else {
	        warn(`onScopeDispose() is called when there is no active effect scope` +
	            ` to be associated with.`);
	    }
	}

	const createDep = (effects) => {
	    const dep = new Set(effects);
	    dep.w = 0;
	    dep.n = 0;
	    return dep;
	};
	const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
	const newTracked = (dep) => (dep.n & trackOpBit) > 0;
	const initDepMarkers = ({ deps }) => {
	    if (deps.length) {
	        for (let i = 0; i < deps.length; i++) {
	            deps[i].w |= trackOpBit; // set was tracked
	        }
	    }
	};
	const finalizeDepMarkers = (effect) => {
	    const { deps } = effect;
	    if (deps.length) {
	        let ptr = 0;
	        for (let i = 0; i < deps.length; i++) {
	            const dep = deps[i];
	            if (wasTracked(dep) && !newTracked(dep)) {
	                dep.delete(effect);
	            }
	            else {
	                deps[ptr++] = dep;
	            }
	            // clear bits
	            dep.w &= ~trackOpBit;
	            dep.n &= ~trackOpBit;
	        }
	        deps.length = ptr;
	    }
	};

	const targetMap = new WeakMap();
	// The number of effects currently being tracked recursively.
	let effectTrackDepth = 0;
	let trackOpBit = 1;
	/**
	 * The bitwise track markers support at most 30 levels of recursion.
	 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
	 * When recursion depth is greater, fall back to using a full cleanup.
	 */
	const maxMarkerBits = 30;
	let activeEffect;
	const ITERATE_KEY = Symbol('iterate' );
	const MAP_KEY_ITERATE_KEY = Symbol('Map key iterate' );
	class ReactiveEffect {
	    constructor(fn, scheduler = null, scope) {
	        this.fn = fn;
	        this.scheduler = scheduler;
	        this.active = true;
	        this.deps = [];
	        this.parent = undefined;
	        recordEffectScope(this, scope);
	    }
	    run() {
	        if (!this.active) {
	            return this.fn();
	        }
	        let parent = activeEffect;
	        let lastShouldTrack = shouldTrack;
	        while (parent) {
	            if (parent === this) {
	                return;
	            }
	            parent = parent.parent;
	        }
	        try {
	            this.parent = activeEffect;
	            activeEffect = this;
	            shouldTrack = true;
	            trackOpBit = 1 << ++effectTrackDepth;
	            if (effectTrackDepth <= maxMarkerBits) {
	                initDepMarkers(this);
	            }
	            else {
	                cleanupEffect(this);
	            }
	            return this.fn();
	        }
	        finally {
	            if (effectTrackDepth <= maxMarkerBits) {
	                finalizeDepMarkers(this);
	            }
	            trackOpBit = 1 << --effectTrackDepth;
	            activeEffect = this.parent;
	            shouldTrack = lastShouldTrack;
	            this.parent = undefined;
	            if (this.deferStop) {
	                this.stop();
	            }
	        }
	    }
	    stop() {
	        // stopped while running itself - defer the cleanup
	        if (activeEffect === this) {
	            this.deferStop = true;
	        }
	        else if (this.active) {
	            cleanupEffect(this);
	            if (this.onStop) {
	                this.onStop();
	            }
	            this.active = false;
	        }
	    }
	}
	function cleanupEffect(effect) {
	    const { deps } = effect;
	    if (deps.length) {
	        for (let i = 0; i < deps.length; i++) {
	            deps[i].delete(effect);
	        }
	        deps.length = 0;
	    }
	}
	function effect(fn, options) {
	    if (fn.effect) {
	        fn = fn.effect.fn;
	    }
	    const _effect = new ReactiveEffect(fn);
	    if (options) {
	        extend(_effect, options);
	        if (options.scope)
	            recordEffectScope(_effect, options.scope);
	    }
	    if (!options || !options.lazy) {
	        _effect.run();
	    }
	    const runner = _effect.run.bind(_effect);
	    runner.effect = _effect;
	    return runner;
	}
	function stop(runner) {
	    runner.effect.stop();
	}
	let shouldTrack = true;
	const trackStack = [];
	function pauseTracking() {
	    trackStack.push(shouldTrack);
	    shouldTrack = false;
	}
	function resetTracking() {
	    const last = trackStack.pop();
	    shouldTrack = last === undefined ? true : last;
	}
	function track(target, type, key) {
	    if (shouldTrack && activeEffect) {
	        let depsMap = targetMap.get(target);
	        if (!depsMap) {
	            targetMap.set(target, (depsMap = new Map()));
	        }
	        let dep = depsMap.get(key);
	        if (!dep) {
	            depsMap.set(key, (dep = createDep()));
	        }
	        const eventInfo = { effect: activeEffect, target, type, key }
	            ;
	        trackEffects(dep, eventInfo);
	    }
	}
	function trackEffects(dep, debuggerEventExtraInfo) {
	    let shouldTrack = false;
	    if (effectTrackDepth <= maxMarkerBits) {
	        if (!newTracked(dep)) {
	            dep.n |= trackOpBit; // set newly tracked
	            shouldTrack = !wasTracked(dep);
	        }
	    }
	    else {
	        // Full cleanup mode.
	        shouldTrack = !dep.has(activeEffect);
	    }
	    if (shouldTrack) {
	        dep.add(activeEffect);
	        activeEffect.deps.push(dep);
	        if (activeEffect.onTrack) {
	            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
	        }
	    }
	}
	function trigger(target, type, key, newValue, oldValue, oldTarget) {
	    const depsMap = targetMap.get(target);
	    if (!depsMap) {
	        // never been tracked
	        return;
	    }
	    let deps = [];
	    if (type === "clear" /* CLEAR */) {
	        // collection being cleared
	        // trigger all effects for target
	        deps = [...depsMap.values()];
	    }
	    else if (key === 'length' && isArray(target)) {
	        depsMap.forEach((dep, key) => {
	            if (key === 'length' || key >= newValue) {
	                deps.push(dep);
	            }
	        });
	    }
	    else {
	        // schedule runs for SET | ADD | DELETE
	        if (key !== void 0) {
	            deps.push(depsMap.get(key));
	        }
	        // also run for iteration key on ADD | DELETE | Map.SET
	        switch (type) {
	            case "add" /* ADD */:
	                if (!isArray(target)) {
	                    deps.push(depsMap.get(ITERATE_KEY));
	                    if (isMap(target)) {
	                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
	                    }
	                }
	                else if (isIntegerKey(key)) {
	                    // new index added to array -> length changes
	                    deps.push(depsMap.get('length'));
	                }
	                break;
	            case "delete" /* DELETE */:
	                if (!isArray(target)) {
	                    deps.push(depsMap.get(ITERATE_KEY));
	                    if (isMap(target)) {
	                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
	                    }
	                }
	                break;
	            case "set" /* SET */:
	                if (isMap(target)) {
	                    deps.push(depsMap.get(ITERATE_KEY));
	                }
	                break;
	        }
	    }
	    const eventInfo = { target, type, key, newValue, oldValue, oldTarget }
	        ;
	    if (deps.length === 1) {
	        if (deps[0]) {
	            {
	                triggerEffects(deps[0], eventInfo);
	            }
	        }
	    }
	    else {
	        const effects = [];
	        for (const dep of deps) {
	            if (dep) {
	                effects.push(...dep);
	            }
	        }
	        {
	            triggerEffects(createDep(effects), eventInfo);
	        }
	    }
	}
	function triggerEffects(dep, debuggerEventExtraInfo) {
	    // spread into array for stabilization
	    const effects = isArray(dep) ? dep : [...dep];
	    for (const effect of effects) {
	        if (effect.computed) {
	            triggerEffect(effect, debuggerEventExtraInfo);
	        }
	    }
	    for (const effect of effects) {
	        if (!effect.computed) {
	            triggerEffect(effect, debuggerEventExtraInfo);
	        }
	    }
	}
	function triggerEffect(effect, debuggerEventExtraInfo) {
	    if (effect !== activeEffect || effect.allowRecurse) {
	        if (effect.onTrigger) {
	            effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
	        }
	        if (effect.scheduler) {
	            effect.scheduler();
	        }
	        else {
	            effect.run();
	        }
	    }
	}

	const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);
	const builtInSymbols = new Set(
	/*#__PURE__*/
	Object.getOwnPropertyNames(Symbol)
	    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'
	    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode
	    // function
	    .filter(key => key !== 'arguments' && key !== 'caller')
	    .map(key => Symbol[key])
	    .filter(isSymbol));
	const get = /*#__PURE__*/ createGetter();
	const shallowGet = /*#__PURE__*/ createGetter(false, true);
	const readonlyGet = /*#__PURE__*/ createGetter(true);
	const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
	const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
	function createArrayInstrumentations() {
	    const instrumentations = {};
	    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
	        instrumentations[key] = function (...args) {
	            const arr = toRaw(this);
	            for (let i = 0, l = this.length; i < l; i++) {
	                track(arr, "get" /* GET */, i + '');
	            }
	            // we run the method using the original args first (which may be reactive)
	            const res = arr[key](...args);
	            if (res === -1 || res === false) {
	                // if that didn't work, run it again using raw values.
	                return arr[key](...args.map(toRaw));
	            }
	            else {
	                return res;
	            }
	        };
	    });
	    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
	        instrumentations[key] = function (...args) {
	            pauseTracking();
	            const res = toRaw(this)[key].apply(this, args);
	            resetTracking();
	            return res;
	        };
	    });
	    return instrumentations;
	}
	function createGetter(isReadonly = false, shallow = false) {
	    return function get(target, key, receiver) {
	        if (key === "__v_isReactive" /* IS_REACTIVE */) {
	            return !isReadonly;
	        }
	        else if (key === "__v_isReadonly" /* IS_READONLY */) {
	            return isReadonly;
	        }
	        else if (key === "__v_isShallow" /* IS_SHALLOW */) {
	            return shallow;
	        }
	        else if (key === "__v_raw" /* RAW */ &&
	            receiver ===
	                (isReadonly
	                    ? shallow
	                        ? shallowReadonlyMap
	                        : readonlyMap
	                    : shallow
	                        ? shallowReactiveMap
	                        : reactiveMap).get(target)) {
	            return target;
	        }
	        const targetIsArray = isArray(target);
	        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
	            return Reflect.get(arrayInstrumentations, key, receiver);
	        }
	        const res = Reflect.get(target, key, receiver);
	        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
	            return res;
	        }
	        if (!isReadonly) {
	            track(target, "get" /* GET */, key);
	        }
	        if (shallow) {
	            return res;
	        }
	        if (isRef(res)) {
	            // ref unwrapping - skip unwrap for Array + integer key.
	            return targetIsArray && isIntegerKey(key) ? res : res.value;
	        }
	        if (isObject(res)) {
	            // Convert returned value into a proxy as well. we do the isObject check
	            // here to avoid invalid value warning. Also need to lazy access readonly
	            // and reactive here to avoid circular dependency.
	            return isReadonly ? readonly(res) : reactive(res);
	        }
	        return res;
	    };
	}
	const set = /*#__PURE__*/ createSetter();
	const shallowSet = /*#__PURE__*/ createSetter(true);
	function createSetter(shallow = false) {
	    return function set(target, key, value, receiver) {
	        let oldValue = target[key];
	        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
	            return false;
	        }
	        if (!shallow && !isReadonly(value)) {
	            if (!isShallow(value)) {
	                value = toRaw(value);
	                oldValue = toRaw(oldValue);
	            }
	            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
	                oldValue.value = value;
	                return true;
	            }
	        }
	        const hadKey = isArray(target) && isIntegerKey(key)
	            ? Number(key) < target.length
	            : hasOwn(target, key);
	        const result = Reflect.set(target, key, value, receiver);
	        // don't trigger if target is something up in the prototype chain of original
	        if (target === toRaw(receiver)) {
	            if (!hadKey) {
	                trigger(target, "add" /* ADD */, key, value);
	            }
	            else if (hasChanged(value, oldValue)) {
	                trigger(target, "set" /* SET */, key, value, oldValue);
	            }
	        }
	        return result;
	    };
	}
	function deleteProperty(target, key) {
	    const hadKey = hasOwn(target, key);
	    const oldValue = target[key];
	    const result = Reflect.deleteProperty(target, key);
	    if (result && hadKey) {
	        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
	    }
	    return result;
	}
	function has(target, key) {
	    const result = Reflect.has(target, key);
	    if (!isSymbol(key) || !builtInSymbols.has(key)) {
	        track(target, "has" /* HAS */, key);
	    }
	    return result;
	}
	function ownKeys(target) {
	    track(target, "iterate" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);
	    return Reflect.ownKeys(target);
	}
	const mutableHandlers = {
	    get,
	    set,
	    deleteProperty,
	    has,
	    ownKeys
	};
	const readonlyHandlers = {
	    get: readonlyGet,
	    set(target, key) {
	        {
	            warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
	        }
	        return true;
	    },
	    deleteProperty(target, key) {
	        {
	            warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
	        }
	        return true;
	    }
	};
	const shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {
	    get: shallowGet,
	    set: shallowSet
	});
	// Props handlers are special in the sense that it should not unwrap top-level
	// refs (in order to allow refs to be explicitly passed down), but should
	// retain the reactivity of the normal readonly object.
	const shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {
	    get: shallowReadonlyGet
	});

	const toShallow = (value) => value;
	const getProto = (v) => Reflect.getPrototypeOf(v);
	function get$1(target, key, isReadonly = false, isShallow = false) {
	    // #1772: readonly(reactive(Map)) should return readonly + reactive version
	    // of the value
	    target = target["__v_raw" /* RAW */];
	    const rawTarget = toRaw(target);
	    const rawKey = toRaw(key);
	    if (!isReadonly) {
	        if (key !== rawKey) {
	            track(rawTarget, "get" /* GET */, key);
	        }
	        track(rawTarget, "get" /* GET */, rawKey);
	    }
	    const { has } = getProto(rawTarget);
	    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
	    if (has.call(rawTarget, key)) {
	        return wrap(target.get(key));
	    }
	    else if (has.call(rawTarget, rawKey)) {
	        return wrap(target.get(rawKey));
	    }
	    else if (target !== rawTarget) {
	        // #3602 readonly(reactive(Map))
	        // ensure that the nested reactive `Map` can do tracking for itself
	        target.get(key);
	    }
	}
	function has$1(key, isReadonly = false) {
	    const target = this["__v_raw" /* RAW */];
	    const rawTarget = toRaw(target);
	    const rawKey = toRaw(key);
	    if (!isReadonly) {
	        if (key !== rawKey) {
	            track(rawTarget, "has" /* HAS */, key);
	        }
	        track(rawTarget, "has" /* HAS */, rawKey);
	    }
	    return key === rawKey
	        ? target.has(key)
	        : target.has(key) || target.has(rawKey);
	}
	function size(target, isReadonly = false) {
	    target = target["__v_raw" /* RAW */];
	    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
	    return Reflect.get(target, 'size', target);
	}
	function add(value) {
	    value = toRaw(value);
	    const target = toRaw(this);
	    const proto = getProto(target);
	    const hadKey = proto.has.call(target, value);
	    if (!hadKey) {
	        target.add(value);
	        trigger(target, "add" /* ADD */, value, value);
	    }
	    return this;
	}
	function set$1(key, value) {
	    value = toRaw(value);
	    const target = toRaw(this);
	    const { has, get } = getProto(target);
	    let hadKey = has.call(target, key);
	    if (!hadKey) {
	        key = toRaw(key);
	        hadKey = has.call(target, key);
	    }
	    else {
	        checkIdentityKeys(target, has, key);
	    }
	    const oldValue = get.call(target, key);
	    target.set(key, value);
	    if (!hadKey) {
	        trigger(target, "add" /* ADD */, key, value);
	    }
	    else if (hasChanged(value, oldValue)) {
	        trigger(target, "set" /* SET */, key, value, oldValue);
	    }
	    return this;
	}
	function deleteEntry(key) {
	    const target = toRaw(this);
	    const { has, get } = getProto(target);
	    let hadKey = has.call(target, key);
	    if (!hadKey) {
	        key = toRaw(key);
	        hadKey = has.call(target, key);
	    }
	    else {
	        checkIdentityKeys(target, has, key);
	    }
	    const oldValue = get ? get.call(target, key) : undefined;
	    // forward the operation before queueing reactions
	    const result = target.delete(key);
	    if (hadKey) {
	        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
	    }
	    return result;
	}
	function clear() {
	    const target = toRaw(this);
	    const hadItems = target.size !== 0;
	    const oldTarget = isMap(target)
	            ? new Map(target)
	            : new Set(target)
	        ;
	    // forward the operation before queueing reactions
	    const result = target.clear();
	    if (hadItems) {
	        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
	    }
	    return result;
	}
	function createForEach(isReadonly, isShallow) {
	    return function forEach(callback, thisArg) {
	        const observed = this;
	        const target = observed["__v_raw" /* RAW */];
	        const rawTarget = toRaw(target);
	        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
	        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
	        return target.forEach((value, key) => {
	            // important: make sure the callback is
	            // 1. invoked with the reactive map as `this` and 3rd arg
	            // 2. the value received should be a corresponding reactive/readonly.
	            return callback.call(thisArg, wrap(value), wrap(key), observed);
	        });
	    };
	}
	function createIterableMethod(method, isReadonly, isShallow) {
	    return function (...args) {
	        const target = this["__v_raw" /* RAW */];
	        const rawTarget = toRaw(target);
	        const targetIsMap = isMap(rawTarget);
	        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
	        const isKeyOnly = method === 'keys' && targetIsMap;
	        const innerIterator = target[method](...args);
	        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
	        !isReadonly &&
	            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
	        // return a wrapped iterator which returns observed versions of the
	        // values emitted from the real iterator
	        return {
	            // iterator protocol
	            next() {
	                const { value, done } = innerIterator.next();
	                return done
	                    ? { value, done }
	                    : {
	                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
	                        done
	                    };
	            },
	            // iterable protocol
	            [Symbol.iterator]() {
	                return this;
	            }
	        };
	    };
	}
	function createReadonlyMethod(type) {
	    return function (...args) {
	        {
	            const key = args[0] ? `on key "${args[0]}" ` : ``;
	            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
	        }
	        return type === "delete" /* DELETE */ ? false : this;
	    };
	}
	function createInstrumentations() {
	    const mutableInstrumentations = {
	        get(key) {
	            return get$1(this, key);
	        },
	        get size() {
	            return size(this);
	        },
	        has: has$1,
	        add,
	        set: set$1,
	        delete: deleteEntry,
	        clear,
	        forEach: createForEach(false, false)
	    };
	    const shallowInstrumentations = {
	        get(key) {
	            return get$1(this, key, false, true);
	        },
	        get size() {
	            return size(this);
	        },
	        has: has$1,
	        add,
	        set: set$1,
	        delete: deleteEntry,
	        clear,
	        forEach: createForEach(false, true)
	    };
	    const readonlyInstrumentations = {
	        get(key) {
	            return get$1(this, key, true);
	        },
	        get size() {
	            return size(this, true);
	        },
	        has(key) {
	            return has$1.call(this, key, true);
	        },
	        add: createReadonlyMethod("add" /* ADD */),
	        set: createReadonlyMethod("set" /* SET */),
	        delete: createReadonlyMethod("delete" /* DELETE */),
	        clear: createReadonlyMethod("clear" /* CLEAR */),
	        forEach: createForEach(true, false)
	    };
	    const shallowReadonlyInstrumentations = {
	        get(key) {
	            return get$1(this, key, true, true);
	        },
	        get size() {
	            return size(this, true);
	        },
	        has(key) {
	            return has$1.call(this, key, true);
	        },
	        add: createReadonlyMethod("add" /* ADD */),
	        set: createReadonlyMethod("set" /* SET */),
	        delete: createReadonlyMethod("delete" /* DELETE */),
	        clear: createReadonlyMethod("clear" /* CLEAR */),
	        forEach: createForEach(true, true)
	    };
	    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
	    iteratorMethods.forEach(method => {
	        mutableInstrumentations[method] = createIterableMethod(method, false, false);
	        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
	        shallowInstrumentations[method] = createIterableMethod(method, false, true);
	        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
	    });
	    return [
	        mutableInstrumentations,
	        readonlyInstrumentations,
	        shallowInstrumentations,
	        shallowReadonlyInstrumentations
	    ];
	}
	const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
	function createInstrumentationGetter(isReadonly, shallow) {
	    const instrumentations = shallow
	        ? isReadonly
	            ? shallowReadonlyInstrumentations
	            : shallowInstrumentations
	        : isReadonly
	            ? readonlyInstrumentations
	            : mutableInstrumentations;
	    return (target, key, receiver) => {
	        if (key === "__v_isReactive" /* IS_REACTIVE */) {
	            return !isReadonly;
	        }
	        else if (key === "__v_isReadonly" /* IS_READONLY */) {
	            return isReadonly;
	        }
	        else if (key === "__v_raw" /* RAW */) {
	            return target;
	        }
	        return Reflect.get(hasOwn(instrumentations, key) && key in target
	            ? instrumentations
	            : target, key, receiver);
	    };
	}
	const mutableCollectionHandlers = {
	    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
	};
	const shallowCollectionHandlers = {
	    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
	};
	const readonlyCollectionHandlers = {
	    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
	};
	const shallowReadonlyCollectionHandlers = {
	    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
	};
	function checkIdentityKeys(target, has, key) {
	    const rawKey = toRaw(key);
	    if (rawKey !== key && has.call(target, rawKey)) {
	        const type = toRawType(target);
	        console.warn(`Reactive ${type} contains both the raw and reactive ` +
	            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
	            `which can lead to inconsistencies. ` +
	            `Avoid differentiating between the raw and reactive versions ` +
	            `of an object and only use the reactive version if possible.`);
	    }
	}

	const reactiveMap = new WeakMap();
	const shallowReactiveMap = new WeakMap();
	const readonlyMap = new WeakMap();
	const shallowReadonlyMap = new WeakMap();
	function targetTypeMap(rawType) {
	    switch (rawType) {
	        case 'Object':
	        case 'Array':
	            return 1 /* COMMON */;
	        case 'Map':
	        case 'Set':
	        case 'WeakMap':
	        case 'WeakSet':
	            return 2 /* COLLECTION */;
	        default:
	            return 0 /* INVALID */;
	    }
	}
	function getTargetType(value) {
	    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
	        ? 0 /* INVALID */
	        : targetTypeMap(toRawType(value));
	}
	function reactive(target) {
	    // if trying to observe a readonly proxy, return the readonly version.
	    if (isReadonly(target)) {
	        return target;
	    }
	    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
	}
	/**
	 * Return a shallowly-reactive copy of the original object, where only the root
	 * level properties are reactive. It also does not auto-unwrap refs (even at the
	 * root level).
	 */
	function shallowReactive(target) {
	    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
	}
	/**
	 * Creates a readonly copy of the original object. Note the returned copy is not
	 * made reactive, but `readonly` can be called on an already reactive object.
	 */
	function readonly(target) {
	    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
	}
	/**
	 * Returns a reactive-copy of the original object, where only the root level
	 * properties are readonly, and does NOT unwrap refs nor recursively convert
	 * returned properties.
	 * This is used for creating the props proxy object for stateful components.
	 */
	function shallowReadonly(target) {
	    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
	}
	function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
	    if (!isObject(target)) {
	        {
	            console.warn(`value cannot be made reactive: ${String(target)}`);
	        }
	        return target;
	    }
	    // target is already a Proxy, return it.
	    // exception: calling readonly() on a reactive object
	    if (target["__v_raw" /* RAW */] &&
	        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
	        return target;
	    }
	    // target already has corresponding Proxy
	    const existingProxy = proxyMap.get(target);
	    if (existingProxy) {
	        return existingProxy;
	    }
	    // only specific value types can be observed.
	    const targetType = getTargetType(target);
	    if (targetType === 0 /* INVALID */) {
	        return target;
	    }
	    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
	    proxyMap.set(target, proxy);
	    return proxy;
	}
	function isReactive(value) {
	    if (isReadonly(value)) {
	        return isReactive(value["__v_raw" /* RAW */]);
	    }
	    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
	}
	function isReadonly(value) {
	    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
	}
	function isShallow(value) {
	    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
	}
	function isProxy(value) {
	    return isReactive(value) || isReadonly(value);
	}
	function toRaw(observed) {
	    const raw = observed && observed["__v_raw" /* RAW */];
	    return raw ? toRaw(raw) : observed;
	}
	function markRaw(value) {
	    def(value, "__v_skip" /* SKIP */, true);
	    return value;
	}
	const toReactive = (value) => isObject(value) ? reactive(value) : value;
	const toReadonly = (value) => isObject(value) ? readonly(value) : value;

	function trackRefValue(ref) {
	    if (shouldTrack && activeEffect) {
	        ref = toRaw(ref);
	        {
	            trackEffects(ref.dep || (ref.dep = createDep()), {
	                target: ref,
	                type: "get" /* GET */,
	                key: 'value'
	            });
	        }
	    }
	}
	function triggerRefValue(ref, newVal) {
	    ref = toRaw(ref);
	    if (ref.dep) {
	        {
	            triggerEffects(ref.dep, {
	                target: ref,
	                type: "set" /* SET */,
	                key: 'value',
	                newValue: newVal
	            });
	        }
	    }
	}
	function isRef(r) {
	    return !!(r && r.__v_isRef === true);
	}
	function ref(value) {
	    return createRef(value, false);
	}
	function shallowRef(value) {
	    return createRef(value, true);
	}
	function createRef(rawValue, shallow) {
	    if (isRef(rawValue)) {
	        return rawValue;
	    }
	    return new RefImpl(rawValue, shallow);
	}
	class RefImpl {
	    constructor(value, __v_isShallow) {
	        this.__v_isShallow = __v_isShallow;
	        this.dep = undefined;
	        this.__v_isRef = true;
	        this._rawValue = __v_isShallow ? value : toRaw(value);
	        this._value = __v_isShallow ? value : toReactive(value);
	    }
	    get value() {
	        trackRefValue(this);
	        return this._value;
	    }
	    set value(newVal) {
	        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
	        if (hasChanged(newVal, this._rawValue)) {
	            this._rawValue = newVal;
	            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
	            triggerRefValue(this, newVal);
	        }
	    }
	}
	function triggerRef(ref) {
	    triggerRefValue(ref, ref.value );
	}
	function unref(ref) {
	    return isRef(ref) ? ref.value : ref;
	}
	const shallowUnwrapHandlers = {
	    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
	    set: (target, key, value, receiver) => {
	        const oldValue = target[key];
	        if (isRef(oldValue) && !isRef(value)) {
	            oldValue.value = value;
	            return true;
	        }
	        else {
	            return Reflect.set(target, key, value, receiver);
	        }
	    }
	};
	function proxyRefs(objectWithRefs) {
	    return isReactive(objectWithRefs)
	        ? objectWithRefs
	        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
	}
	class CustomRefImpl {
	    constructor(factory) {
	        this.dep = undefined;
	        this.__v_isRef = true;
	        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));
	        this._get = get;
	        this._set = set;
	    }
	    get value() {
	        return this._get();
	    }
	    set value(newVal) {
	        this._set(newVal);
	    }
	}
	function customRef(factory) {
	    return new CustomRefImpl(factory);
	}
	function toRefs(object) {
	    if (!isProxy(object)) {
	        console.warn(`toRefs() expects a reactive object but received a plain one.`);
	    }
	    const ret = isArray(object) ? new Array(object.length) : {};
	    for (const key in object) {
	        ret[key] = toRef(object, key);
	    }
	    return ret;
	}
	class ObjectRefImpl {
	    constructor(_object, _key, _defaultValue) {
	        this._object = _object;
	        this._key = _key;
	        this._defaultValue = _defaultValue;
	        this.__v_isRef = true;
	    }
	    get value() {
	        const val = this._object[this._key];
	        return val === undefined ? this._defaultValue : val;
	    }
	    set value(newVal) {
	        this._object[this._key] = newVal;
	    }
	}
	function toRef(object, key, defaultValue) {
	    const val = object[key];
	    return isRef(val)
	        ? val
	        : new ObjectRefImpl(object, key, defaultValue);
	}

	class ComputedRefImpl {
	    constructor(getter, _setter, isReadonly, isSSR) {
	        this._setter = _setter;
	        this.dep = undefined;
	        this.__v_isRef = true;
	        this._dirty = true;
	        this.effect = new ReactiveEffect(getter, () => {
	            if (!this._dirty) {
	                this._dirty = true;
	                triggerRefValue(this);
	            }
	        });
	        this.effect.computed = this;
	        this.effect.active = this._cacheable = !isSSR;
	        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
	    }
	    get value() {
	        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
	        const self = toRaw(this);
	        trackRefValue(self);
	        if (self._dirty || !self._cacheable) {
	            self._dirty = false;
	            self._value = self.effect.run();
	        }
	        return self._value;
	    }
	    set value(newValue) {
	        this._setter(newValue);
	    }
	}
	function computed(getterOrOptions, debugOptions, isSSR = false) {
	    let getter;
	    let setter;
	    const onlyGetter = isFunction(getterOrOptions);
	    if (onlyGetter) {
	        getter = getterOrOptions;
	        setter = () => {
	                console.warn('Write operation failed: computed value is readonly');
	            }
	            ;
	    }
	    else {
	        getter = getterOrOptions.get;
	        setter = getterOrOptions.set;
	    }
	    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
	    if (debugOptions && !isSSR) {
	        cRef.effect.onTrack = debugOptions.onTrack;
	        cRef.effect.onTrigger = debugOptions.onTrigger;
	    }
	    return cRef;
	}

	const stack = [];
	function pushWarningContext(vnode) {
	    stack.push(vnode);
	}
	function popWarningContext() {
	    stack.pop();
	}
	function warn$1(msg, ...args) {
	    // avoid props formatting or warn handler tracking deps that might be mutated
	    // during patch, leading to infinite recursion.
	    pauseTracking();
	    const instance = stack.length ? stack[stack.length - 1].component : null;
	    const appWarnHandler = instance && instance.appContext.config.warnHandler;
	    const trace = getComponentTrace();
	    if (appWarnHandler) {
	        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
	            msg + args.join(''),
	            instance && instance.proxy,
	            trace
	                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
	                .join('\n'),
	            trace
	        ]);
	    }
	    else {
	        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
	        /* istanbul ignore if */
	        if (trace.length &&
	            // avoid spamming console during tests
	            !false) {
	            warnArgs.push(`\n`, ...formatTrace(trace));
	        }
	        console.warn(...warnArgs);
	    }
	    resetTracking();
	}
	function getComponentTrace() {
	    let currentVNode = stack[stack.length - 1];
	    if (!currentVNode) {
	        return [];
	    }
	    // we can't just use the stack because it will be incomplete during updates
	    // that did not start from the root. Re-construct the parent chain using
	    // instance parent pointers.
	    const normalizedStack = [];
	    while (currentVNode) {
	        const last = normalizedStack[0];
	        if (last && last.vnode === currentVNode) {
	            last.recurseCount++;
	        }
	        else {
	            normalizedStack.push({
	                vnode: currentVNode,
	                recurseCount: 0
	            });
	        }
	        const parentInstance = currentVNode.component && currentVNode.component.parent;
	        currentVNode = parentInstance && parentInstance.vnode;
	    }
	    return normalizedStack;
	}
	/* istanbul ignore next */
	function formatTrace(trace) {
	    const logs = [];
	    trace.forEach((entry, i) => {
	        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
	    });
	    return logs;
	}
	function formatTraceEntry({ vnode, recurseCount }) {
	    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
	    const isRoot = vnode.component ? vnode.component.parent == null : false;
	    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
	    const close = `>` + postfix;
	    return vnode.props
	        ? [open, ...formatProps(vnode.props), close]
	        : [open + close];
	}
	/* istanbul ignore next */
	function formatProps(props) {
	    const res = [];
	    const keys = Object.keys(props);
	    keys.slice(0, 3).forEach(key => {
	        res.push(...formatProp(key, props[key]));
	    });
	    if (keys.length > 3) {
	        res.push(` ...`);
	    }
	    return res;
	}
	/* istanbul ignore next */
	function formatProp(key, value, raw) {
	    if (isString(value)) {
	        value = JSON.stringify(value);
	        return raw ? value : [`${key}=${value}`];
	    }
	    else if (typeof value === 'number' ||
	        typeof value === 'boolean' ||
	        value == null) {
	        return raw ? value : [`${key}=${value}`];
	    }
	    else if (isRef(value)) {
	        value = formatProp(key, toRaw(value.value), true);
	        return raw ? value : [`${key}=Ref<`, value, `>`];
	    }
	    else if (isFunction(value)) {
	        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
	    }
	    else {
	        value = toRaw(value);
	        return raw ? value : [`${key}=`, value];
	    }
	}

	const ErrorTypeStrings = {
	    ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
	    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
	    ["c" /* CREATED */]: 'created hook',
	    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
	    ["m" /* MOUNTED */]: 'mounted hook',
	    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
	    ["u" /* UPDATED */]: 'updated',
	    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
	    ["um" /* UNMOUNTED */]: 'unmounted hook',
	    ["a" /* ACTIVATED */]: 'activated hook',
	    ["da" /* DEACTIVATED */]: 'deactivated hook',
	    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
	    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
	    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
	    [0 /* SETUP_FUNCTION */]: 'setup function',
	    [1 /* RENDER_FUNCTION */]: 'render function',
	    [2 /* WATCH_GETTER */]: 'watcher getter',
	    [3 /* WATCH_CALLBACK */]: 'watcher callback',
	    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
	    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
	    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
	    [7 /* VNODE_HOOK */]: 'vnode hook',
	    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
	    [9 /* TRANSITION_HOOK */]: 'transition hook',
	    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
	    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
	    [12 /* FUNCTION_REF */]: 'ref function',
	    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
	    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
	        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'
	};
	function callWithErrorHandling(fn, instance, type, args) {
	    let res;
	    try {
	        res = args ? fn(...args) : fn();
	    }
	    catch (err) {
	        handleError(err, instance, type);
	    }
	    return res;
	}
	function callWithAsyncErrorHandling(fn, instance, type, args) {
	    if (isFunction(fn)) {
	        const res = callWithErrorHandling(fn, instance, type, args);
	        if (res && isPromise(res)) {
	            res.catch(err => {
	                handleError(err, instance, type);
	            });
	        }
	        return res;
	    }
	    const values = [];
	    for (let i = 0; i < fn.length; i++) {
	        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
	    }
	    return values;
	}
	function handleError(err, instance, type, throwInDev = true) {
	    const contextVNode = instance ? instance.vnode : null;
	    if (instance) {
	        let cur = instance.parent;
	        // the exposed instance is the render proxy to keep it consistent with 2.x
	        const exposedInstance = instance.proxy;
	        // in production the hook receives only the error code
	        const errorInfo = ErrorTypeStrings[type] ;
	        while (cur) {
	            const errorCapturedHooks = cur.ec;
	            if (errorCapturedHooks) {
	                for (let i = 0; i < errorCapturedHooks.length; i++) {
	                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
	                        return;
	                    }
	                }
	            }
	            cur = cur.parent;
	        }
	        // app-level handling
	        const appErrorHandler = instance.appContext.config.errorHandler;
	        if (appErrorHandler) {
	            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
	            return;
	        }
	    }
	    logError(err, type, contextVNode, throwInDev);
	}
	function logError(err, type, contextVNode, throwInDev = true) {
	    {
	        const info = ErrorTypeStrings[type];
	        if (contextVNode) {
	            pushWarningContext(contextVNode);
	        }
	        warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
	        if (contextVNode) {
	            popWarningContext();
	        }
	        // crash in dev by default so it's more noticeable
	        if (throwInDev) {
	            throw err;
	        }
	        else {
	            console.error(err);
	        }
	    }
	}

	let isFlushing = false;
	let isFlushPending = false;
	const queue = [];
	let flushIndex = 0;
	const pendingPreFlushCbs = [];
	let activePreFlushCbs = null;
	let preFlushIndex = 0;
	const pendingPostFlushCbs = [];
	let activePostFlushCbs = null;
	let postFlushIndex = 0;
	const resolvedPromise = /*#__PURE__*/ Promise.resolve();
	let currentFlushPromise = null;
	let currentPreFlushParentJob = null;
	const RECURSION_LIMIT = 100;
	function nextTick(fn) {
	    const p = currentFlushPromise || resolvedPromise;
	    return fn ? p.then(this ? fn.bind(this) : fn) : p;
	}
	// #2768
	// Use binary-search to find a suitable position in the queue,
	// so that the queue maintains the increasing order of job's id,
	// which can prevent the job from being skipped and also can avoid repeated patching.
	function findInsertionIndex(id) {
	    // the start index should be `flushIndex + 1`
	    let start = flushIndex + 1;
	    let end = queue.length;
	    while (start < end) {
	        const middle = (start + end) >>> 1;
	        const middleJobId = getId(queue[middle]);
	        middleJobId < id ? (start = middle + 1) : (end = middle);
	    }
	    return start;
	}
	function queueJob(job) {
	    // the dedupe search uses the startIndex argument of Array.includes()
	    // by default the search index includes the current job that is being run
	    // so it cannot recursively trigger itself again.
	    // if the job is a watch() callback, the search will start with a +1 index to
	    // allow it recursively trigger itself - it is the user's responsibility to
	    // ensure it doesn't end up in an infinite loop.
	    if ((!queue.length ||
	        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
	        job !== currentPreFlushParentJob) {
	        if (job.id == null) {
	            queue.push(job);
	        }
	        else {
	            queue.splice(findInsertionIndex(job.id), 0, job);
	        }
	        queueFlush();
	    }
	}
	function queueFlush() {
	    if (!isFlushing && !isFlushPending) {
	        isFlushPending = true;
	        currentFlushPromise = resolvedPromise.then(flushJobs);
	    }
	}
	function invalidateJob(job) {
	    const i = queue.indexOf(job);
	    if (i > flushIndex) {
	        queue.splice(i, 1);
	    }
	}
	function queueCb(cb, activeQueue, pendingQueue, index) {
	    if (!isArray(cb)) {
	        if (!activeQueue ||
	            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
	            pendingQueue.push(cb);
	        }
	    }
	    else {
	        // if cb is an array, it is a component lifecycle hook which can only be
	        // triggered by a job, which is already deduped in the main queue, so
	        // we can skip duplicate check here to improve perf
	        pendingQueue.push(...cb);
	    }
	    queueFlush();
	}
	function queuePreFlushCb(cb) {
	    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
	}
	function queuePostFlushCb(cb) {
	    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
	}
	function flushPreFlushCbs(seen, parentJob = null) {
	    if (pendingPreFlushCbs.length) {
	        currentPreFlushParentJob = parentJob;
	        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
	        pendingPreFlushCbs.length = 0;
	        {
	            seen = seen || new Map();
	        }
	        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
	            if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
	                continue;
	            }
	            activePreFlushCbs[preFlushIndex]();
	        }
	        activePreFlushCbs = null;
	        preFlushIndex = 0;
	        currentPreFlushParentJob = null;
	        // recursively flush until it drains
	        flushPreFlushCbs(seen, parentJob);
	    }
	}
	function flushPostFlushCbs(seen) {
	    // flush any pre cbs queued during the flush (e.g. pre watchers)
	    flushPreFlushCbs();
	    if (pendingPostFlushCbs.length) {
	        const deduped = [...new Set(pendingPostFlushCbs)];
	        pendingPostFlushCbs.length = 0;
	        // #1947 already has active queue, nested flushPostFlushCbs call
	        if (activePostFlushCbs) {
	            activePostFlushCbs.push(...deduped);
	            return;
	        }
	        activePostFlushCbs = deduped;
	        {
	            seen = seen || new Map();
	        }
	        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
	        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
	            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
	                continue;
	            }
	            activePostFlushCbs[postFlushIndex]();
	        }
	        activePostFlushCbs = null;
	        postFlushIndex = 0;
	    }
	}
	const getId = (job) => job.id == null ? Infinity : job.id;
	function flushJobs(seen) {
	    isFlushPending = false;
	    isFlushing = true;
	    {
	        seen = seen || new Map();
	    }
	    flushPreFlushCbs(seen);
	    // Sort queue before flush.
	    // This ensures that:
	    // 1. Components are updated from parent to child. (because parent is always
	    //    created before the child so its render effect will have smaller
	    //    priority number)
	    // 2. If a component is unmounted during a parent component's update,
	    //    its update can be skipped.
	    queue.sort((a, b) => getId(a) - getId(b));
	    // conditional usage of checkRecursiveUpdate must be determined out of
	    // try ... catch block since Rollup by default de-optimizes treeshaking
	    // inside try-catch. This can leave all warning code unshaked. Although
	    // they would get eventually shaken by a minifier like terser, some minifiers
	    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
	    const check = (job) => checkRecursiveUpdates(seen, job)
	        ;
	    try {
	        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
	            const job = queue[flushIndex];
	            if (job && job.active !== false) {
	                if (true && check(job)) {
	                    continue;
	                }
	                // console.log(`running:`, job.id)
	                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
	            }
	        }
	    }
	    finally {
	        flushIndex = 0;
	        queue.length = 0;
	        flushPostFlushCbs(seen);
	        isFlushing = false;
	        currentFlushPromise = null;
	        // some postFlushCb queued jobs!
	        // keep flushing until it drains.
	        if (queue.length ||
	            pendingPreFlushCbs.length ||
	            pendingPostFlushCbs.length) {
	            flushJobs(seen);
	        }
	    }
	}
	function checkRecursiveUpdates(seen, fn) {
	    if (!seen.has(fn)) {
	        seen.set(fn, 1);
	    }
	    else {
	        const count = seen.get(fn);
	        if (count > RECURSION_LIMIT) {
	            const instance = fn.ownerInstance;
	            const componentName = instance && getComponentName(instance.type);
	            warn$1(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
	                `This means you have a reactive effect that is mutating its own ` +
	                `dependencies and thus recursively triggering itself. Possible sources ` +
	                `include component template, render function, updated hook or ` +
	                `watcher source function.`);
	            return true;
	        }
	        else {
	            seen.set(fn, count + 1);
	        }
	    }
	}

	/* eslint-disable no-restricted-globals */
	let isHmrUpdating = false;
	const hmrDirtyComponents = new Set();
	// Expose the HMR runtime on the global object
	// This makes it entirely tree-shakable without polluting the exports and makes
	// it easier to be used in toolings like vue-loader
	// Note: for a component to be eligible for HMR it also needs the __hmrId option
	// to be set so that its instances can be registered / removed.
	{
	    getGlobalThis().__VUE_HMR_RUNTIME__ = {
	        createRecord: tryWrap(createRecord),
	        rerender: tryWrap(rerender),
	        reload: tryWrap(reload)
	    };
	}
	const map = new Map();
	function registerHMR(instance) {
	    const id = instance.type.__hmrId;
	    let record = map.get(id);
	    if (!record) {
	        createRecord(id, instance.type);
	        record = map.get(id);
	    }
	    record.instances.add(instance);
	}
	function unregisterHMR(instance) {
	    map.get(instance.type.__hmrId).instances.delete(instance);
	}
	function createRecord(id, initialDef) {
	    if (map.has(id)) {
	        return false;
	    }
	    map.set(id, {
	        initialDef: normalizeClassComponent(initialDef),
	        instances: new Set()
	    });
	    return true;
	}
	function normalizeClassComponent(component) {
	    return isClassComponent(component) ? component.__vccOpts : component;
	}
	function rerender(id, newRender) {
	    const record = map.get(id);
	    if (!record) {
	        return;
	    }
	    // update initial record (for not-yet-rendered component)
	    record.initialDef.render = newRender;
	    [...record.instances].forEach(instance => {
	        if (newRender) {
	            instance.render = newRender;
	            normalizeClassComponent(instance.type).render = newRender;
	        }
	        instance.renderCache = [];
	        // this flag forces child components with slot content to update
	        isHmrUpdating = true;
	        instance.update();
	        isHmrUpdating = false;
	    });
	}
	function reload(id, newComp) {
	    const record = map.get(id);
	    if (!record)
	        return;
	    newComp = normalizeClassComponent(newComp);
	    // update initial def (for not-yet-rendered components)
	    updateComponentDef(record.initialDef, newComp);
	    // create a snapshot which avoids the set being mutated during updates
	    const instances = [...record.instances];
	    for (const instance of instances) {
	        const oldComp = normalizeClassComponent(instance.type);
	        if (!hmrDirtyComponents.has(oldComp)) {
	            // 1. Update existing comp definition to match new one
	            if (oldComp !== record.initialDef) {
	                updateComponentDef(oldComp, newComp);
	            }
	            // 2. mark definition dirty. This forces the renderer to replace the
	            // component on patch.
	            hmrDirtyComponents.add(oldComp);
	        }
	        // 3. invalidate options resolution cache
	        instance.appContext.optionsCache.delete(instance.type);
	        // 4. actually update
	        if (instance.ceReload) {
	            // custom element
	            hmrDirtyComponents.add(oldComp);
	            instance.ceReload(newComp.styles);
	            hmrDirtyComponents.delete(oldComp);
	        }
	        else if (instance.parent) {
	            // 4. Force the parent instance to re-render. This will cause all updated
	            // components to be unmounted and re-mounted. Queue the update so that we
	            // don't end up forcing the same parent to re-render multiple times.
	            queueJob(instance.parent.update);
	            // instance is the inner component of an async custom element
	            // invoke to reset styles
	            if (instance.parent.type.__asyncLoader &&
	                instance.parent.ceReload) {
	                instance.parent.ceReload(newComp.styles);
	            }
	        }
	        else if (instance.appContext.reload) {
	            // root instance mounted via createApp() has a reload method
	            instance.appContext.reload();
	        }
	        else if (typeof window !== 'undefined') {
	            // root instance inside tree created via raw render(). Force reload.
	            window.location.reload();
	        }
	        else {
	            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
	        }
	    }
	    // 5. make sure to cleanup dirty hmr components after update
	    queuePostFlushCb(() => {
	        for (const instance of instances) {
	            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
	        }
	    });
	}
	function updateComponentDef(oldComp, newComp) {
	    extend(oldComp, newComp);
	    for (const key in oldComp) {
	        if (key !== '__file' && !(key in newComp)) {
	            delete oldComp[key];
	        }
	    }
	}
	function tryWrap(fn) {
	    return (id, arg) => {
	        try {
	            return fn(id, arg);
	        }
	        catch (e) {
	            console.error(e);
	            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
	                `Full reload required.`);
	        }
	    };
	}

	let devtools;
	let buffer = [];
	let devtoolsNotInstalled = false;
	function emit(event, ...args) {
	    if (devtools) {
	        devtools.emit(event, ...args);
	    }
	    else if (!devtoolsNotInstalled) {
	        buffer.push({ event, args });
	    }
	}
	function setDevtoolsHook(hook, target) {
	    var _a, _b;
	    devtools = hook;
	    if (devtools) {
	        devtools.enabled = true;
	        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
	        buffer = [];
	    }
	    else if (
	    // handle late devtools injection - only do this if we are in an actual
	    // browser environment to avoid the timer handle stalling test runner exit
	    // (#4815)
	    typeof window !== 'undefined' &&
	        // some envs mock window but not fully
	        window.HTMLElement &&
	        // also exclude jsdom
	        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
	        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
	            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
	        replay.push((newHook) => {
	            setDevtoolsHook(newHook, target);
	        });
	        // clear buffer after 3s - the user probably doesn't have devtools installed
	        // at all, and keeping the buffer will cause memory leaks (#4738)
	        setTimeout(() => {
	            if (!devtools) {
	                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
	                devtoolsNotInstalled = true;
	                buffer = [];
	            }
	        }, 3000);
	    }
	    else {
	        // non-browser env, assume not installed
	        devtoolsNotInstalled = true;
	        buffer = [];
	    }
	}
	function devtoolsInitApp(app, version) {
	    emit("app:init" /* APP_INIT */, app, version, {
	        Fragment,
	        Text,
	        Comment,
	        Static
	    });
	}
	function devtoolsUnmountApp(app) {
	    emit("app:unmount" /* APP_UNMOUNT */, app);
	}
	const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
	const devtoolsComponentUpdated = 
	/*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
	const devtoolsComponentRemoved = 
	/*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);
	function createDevtoolsComponentHook(hook) {
	    return (component) => {
	        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
	    };
	}
	const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
	const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
	function createDevtoolsPerformanceHook(hook) {
	    return (component, type, time) => {
	        emit(hook, component.appContext.app, component.uid, component, type, time);
	    };
	}
	function devtoolsComponentEmit(component, event, params) {
	    emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
	}

	function emit$1(instance, event, ...rawArgs) {
	    if (instance.isUnmounted)
	        return;
	    const props = instance.vnode.props || EMPTY_OBJ;
	    {
	        const { emitsOptions, propsOptions: [propsOptions] } = instance;
	        if (emitsOptions) {
	            if (!(event in emitsOptions) &&
	                !(false )) {
	                if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
	                    warn$1(`Component emitted event "${event}" but it is neither declared in ` +
	                        `the emits option nor as an "${toHandlerKey(event)}" prop.`);
	                }
	            }
	            else {
	                const validator = emitsOptions[event];
	                if (isFunction(validator)) {
	                    const isValid = validator(...rawArgs);
	                    if (!isValid) {
	                        warn$1(`Invalid event arguments: event validation failed for event "${event}".`);
	                    }
	                }
	            }
	        }
	    }
	    let args = rawArgs;
	    const isModelListener = event.startsWith('update:');
	    // for v-model update:xxx events, apply modifiers on args
	    const modelArg = isModelListener && event.slice(7);
	    if (modelArg && modelArg in props) {
	        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
	        const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
	        if (trim) {
	            args = rawArgs.map(a => a.trim());
	        }
	        if (number) {
	            args = rawArgs.map(toNumber);
	        }
	    }
	    {
	        devtoolsComponentEmit(instance, event, args);
	    }
	    {
	        const lowerCaseEvent = event.toLowerCase();
	        if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
	            warn$1(`Event "${lowerCaseEvent}" is emitted in component ` +
	                `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
	                `Note that HTML attributes are case-insensitive and you cannot use ` +
	                `v-on to listen to camelCase events when using in-DOM templates. ` +
	                `You should probably use "${hyphenate(event)}" instead of "${event}".`);
	        }
	    }
	    let handlerName;
	    let handler = props[(handlerName = toHandlerKey(event))] ||
	        // also try camelCase event handler (#2249)
	        props[(handlerName = toHandlerKey(camelize(event)))];
	    // for v-model update:xxx events, also trigger kebab-case equivalent
	    // for props passed via kebab-case
	    if (!handler && isModelListener) {
	        handler = props[(handlerName = toHandlerKey(hyphenate(event)))];
	    }
	    if (handler) {
	        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
	    }
	    const onceHandler = props[handlerName + `Once`];
	    if (onceHandler) {
	        if (!instance.emitted) {
	            instance.emitted = {};
	        }
	        else if (instance.emitted[handlerName]) {
	            return;
	        }
	        instance.emitted[handlerName] = true;
	        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
	    }
	}
	function normalizeEmitsOptions(comp, appContext, asMixin = false) {
	    const cache = appContext.emitsCache;
	    const cached = cache.get(comp);
	    if (cached !== undefined) {
	        return cached;
	    }
	    const raw = comp.emits;
	    let normalized = {};
	    // apply mixin/extends props
	    let hasExtends = false;
	    if (!isFunction(comp)) {
	        const extendEmits = (raw) => {
	            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
	            if (normalizedFromExtend) {
	                hasExtends = true;
	                extend(normalized, normalizedFromExtend);
	            }
	        };
	        if (!asMixin && appContext.mixins.length) {
	            appContext.mixins.forEach(extendEmits);
	        }
	        if (comp.extends) {
	            extendEmits(comp.extends);
	        }
	        if (comp.mixins) {
	            comp.mixins.forEach(extendEmits);
	        }
	    }
	    if (!raw && !hasExtends) {
	        cache.set(comp, null);
	        return null;
	    }
	    if (isArray(raw)) {
	        raw.forEach(key => (normalized[key] = null));
	    }
	    else {
	        extend(normalized, raw);
	    }
	    cache.set(comp, normalized);
	    return normalized;
	}
	// Check if an incoming prop key is a declared emit event listener.
	// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
	// both considered matched listeners.
	function isEmitListener(options, key) {
	    if (!options || !isOn(key)) {
	        return false;
	    }
	    key = key.slice(2).replace(/Once$/, '');
	    return (hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||
	        hasOwn(options, hyphenate(key)) ||
	        hasOwn(options, key));
	}

	/**
	 * mark the current rendering instance for asset resolution (e.g.
	 * resolveComponent, resolveDirective) during render
	 */
	let currentRenderingInstance = null;
	let currentScopeId = null;
	/**
	 * Note: rendering calls maybe nested. The function returns the parent rendering
	 * instance if present, which should be restored after the render is done:
	 *
	 * ```js
	 * const prev = setCurrentRenderingInstance(i)
	 * // ...render
	 * setCurrentRenderingInstance(prev)
	 * ```
	 */
	function setCurrentRenderingInstance(instance) {
	    const prev = currentRenderingInstance;
	    currentRenderingInstance = instance;
	    currentScopeId = (instance && instance.type.__scopeId) || null;
	    return prev;
	}
	/**
	 * Set scope id when creating hoisted vnodes.
	 * @private compiler helper
	 */
	function pushScopeId(id) {
	    currentScopeId = id;
	}
	/**
	 * Technically we no longer need this after 3.0.8 but we need to keep the same
	 * API for backwards compat w/ code generated by compilers.
	 * @private
	 */
	function popScopeId() {
	    currentScopeId = null;
	}
	/**
	 * Only for backwards compat
	 * @private
	 */
	const withScopeId = (_id) => withCtx;
	/**
	 * Wrap a slot function to memoize current rendering instance
	 * @private compiler helper
	 */
	function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
	) {
	    if (!ctx)
	        return fn;
	    // already normalized
	    if (fn._n) {
	        return fn;
	    }
	    const renderFnWithContext = (...args) => {
	        // If a user calls a compiled slot inside a template expression (#1745), it
	        // can mess up block tracking, so by default we disable block tracking and
	        // force bail out when invoking a compiled slot (indicated by the ._d flag).
	        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
	        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
	        if (renderFnWithContext._d) {
	            setBlockTracking(-1);
	        }
	        const prevInstance = setCurrentRenderingInstance(ctx);
	        const res = fn(...args);
	        setCurrentRenderingInstance(prevInstance);
	        if (renderFnWithContext._d) {
	            setBlockTracking(1);
	        }
	        {
	            devtoolsComponentUpdated(ctx);
	        }
	        return res;
	    };
	    // mark normalized to avoid duplicated wrapping
	    renderFnWithContext._n = true;
	    // mark this as compiled by default
	    // this is used in vnode.ts -> normalizeChildren() to set the slot
	    // rendering flag.
	    renderFnWithContext._c = true;
	    // disable block tracking by default
	    renderFnWithContext._d = true;
	    return renderFnWithContext;
	}

	/**
	 * dev only flag to track whether $attrs was used during render.
	 * If $attrs was used during render then the warning for failed attrs
	 * fallthrough can be suppressed.
	 */
	let accessedAttrs = false;
	function markAttrsAccessed() {
	    accessedAttrs = true;
	}
	function renderComponentRoot(instance) {
	    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
	    let result;
	    let fallthroughAttrs;
	    const prev = setCurrentRenderingInstance(instance);
	    {
	        accessedAttrs = false;
	    }
	    try {
	        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
	            // withProxy is a proxy with a different `has` trap only for
	            // runtime-compiled render functions using `with` block.
	            const proxyToUse = withProxy || proxy;
	            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
	            fallthroughAttrs = attrs;
	        }
	        else {
	            // functional
	            const render = Component;
	            // in dev, mark attrs accessed if optional props (attrs === props)
	            if (true && attrs === props) {
	                markAttrsAccessed();
	            }
	            result = normalizeVNode(render.length > 1
	                ? render(props, true
	                    ? {
	                        get attrs() {
	                            markAttrsAccessed();
	                            return attrs;
	                        },
	                        slots,
	                        emit
	                    }
	                    : { attrs, slots, emit })
	                : render(props, null /* we know it doesn't need it */));
	            fallthroughAttrs = Component.props
	                ? attrs
	                : getFunctionalFallthrough(attrs);
	        }
	    }
	    catch (err) {
	        blockStack.length = 0;
	        handleError(err, instance, 1 /* RENDER_FUNCTION */);
	        result = createVNode(Comment);
	    }
	    // attr merging
	    // in dev mode, comments are preserved, and it's possible for a template
	    // to have comments along side the root element which makes it a fragment
	    let root = result;
	    let setRoot = undefined;
	    if (result.patchFlag > 0 &&
	        result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
	        [root, setRoot] = getChildRoot(result);
	    }
	    if (fallthroughAttrs && inheritAttrs !== false) {
	        const keys = Object.keys(fallthroughAttrs);
	        const { shapeFlag } = root;
	        if (keys.length) {
	            if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {
	                if (propsOptions && keys.some(isModelListener)) {
	                    // If a v-model listener (onUpdate:xxx) has a corresponding declared
	                    // prop, it indicates this component expects to handle v-model and
	                    // it should not fallthrough.
	                    // related: #1543, #1643, #1989
	                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
	                }
	                root = cloneVNode(root, fallthroughAttrs);
	            }
	            else if (!accessedAttrs && root.type !== Comment) {
	                const allAttrs = Object.keys(attrs);
	                const eventAttrs = [];
	                const extraAttrs = [];
	                for (let i = 0, l = allAttrs.length; i < l; i++) {
	                    const key = allAttrs[i];
	                    if (isOn(key)) {
	                        // ignore v-model handlers when they fail to fallthrough
	                        if (!isModelListener(key)) {
	                            // remove `on`, lowercase first letter to reflect event casing
	                            // accurately
	                            eventAttrs.push(key[2].toLowerCase() + key.slice(3));
	                        }
	                    }
	                    else {
	                        extraAttrs.push(key);
	                    }
	                }
	                if (extraAttrs.length) {
	                    warn$1(`Extraneous non-props attributes (` +
	                        `${extraAttrs.join(', ')}) ` +
	                        `were passed to component but could not be automatically inherited ` +
	                        `because component renders fragment or text root nodes.`);
	                }
	                if (eventAttrs.length) {
	                    warn$1(`Extraneous non-emits event listeners (` +
	                        `${eventAttrs.join(', ')}) ` +
	                        `were passed to component but could not be automatically inherited ` +
	                        `because component renders fragment or text root nodes. ` +
	                        `If the listener is intended to be a component custom event listener only, ` +
	                        `declare it using the "emits" option.`);
	                }
	            }
	        }
	    }
	    // inherit directives
	    if (vnode.dirs) {
	        if (!isElementRoot(root)) {
	            warn$1(`Runtime directive used on component with non-element root node. ` +
	                `The directives will not function as intended.`);
	        }
	        // clone before mutating since the root may be a hoisted vnode
	        root = cloneVNode(root);
	        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
	    }
	    // inherit transition data
	    if (vnode.transition) {
	        if (!isElementRoot(root)) {
	            warn$1(`Component inside <Transition> renders non-element root node ` +
	                `that cannot be animated.`);
	        }
	        root.transition = vnode.transition;
	    }
	    if (setRoot) {
	        setRoot(root);
	    }
	    else {
	        result = root;
	    }
	    setCurrentRenderingInstance(prev);
	    return result;
	}
	/**
	 * dev only
	 * In dev mode, template root level comments are rendered, which turns the
	 * template into a fragment root, but we need to locate the single element
	 * root for attrs and scope id processing.
	 */
	const getChildRoot = (vnode) => {
	    const rawChildren = vnode.children;
	    const dynamicChildren = vnode.dynamicChildren;
	    const childRoot = filterSingleRoot(rawChildren);
	    if (!childRoot) {
	        return [vnode, undefined];
	    }
	    const index = rawChildren.indexOf(childRoot);
	    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
	    const setRoot = (updatedRoot) => {
	        rawChildren[index] = updatedRoot;
	        if (dynamicChildren) {
	            if (dynamicIndex > -1) {
	                dynamicChildren[dynamicIndex] = updatedRoot;
	            }
	            else if (updatedRoot.patchFlag > 0) {
	                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
	            }
	        }
	    };
	    return [normalizeVNode(childRoot), setRoot];
	};
	function filterSingleRoot(children) {
	    let singleRoot;
	    for (let i = 0; i < children.length; i++) {
	        const child = children[i];
	        if (isVNode(child)) {
	            // ignore user comment
	            if (child.type !== Comment || child.children === 'v-if') {
	                if (singleRoot) {
	                    // has more than 1 non-comment child, return now
	                    return;
	                }
	                else {
	                    singleRoot = child;
	                }
	            }
	        }
	        else {
	            return;
	        }
	    }
	    return singleRoot;
	}
	const getFunctionalFallthrough = (attrs) => {
	    let res;
	    for (const key in attrs) {
	        if (key === 'class' || key === 'style' || isOn(key)) {
	            (res || (res = {}))[key] = attrs[key];
	        }
	    }
	    return res;
	};
	const filterModelListeners = (attrs, props) => {
	    const res = {};
	    for (const key in attrs) {
	        if (!isModelListener(key) || !(key.slice(9) in props)) {
	            res[key] = attrs[key];
	        }
	    }
	    return res;
	};
	const isElementRoot = (vnode) => {
	    return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||
	        vnode.type === Comment // potential v-if branch switch
	    );
	};
	function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
	    const { props: prevProps, children: prevChildren, component } = prevVNode;
	    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
	    const emits = component.emitsOptions;
	    // Parent component's render function was hot-updated. Since this may have
	    // caused the child component's slots content to have changed, we need to
	    // force the child to update as well.
	    if ((prevChildren || nextChildren) && isHmrUpdating) {
	        return true;
	    }
	    // force child update for runtime directive or transition on component vnode.
	    if (nextVNode.dirs || nextVNode.transition) {
	        return true;
	    }
	    if (optimized && patchFlag >= 0) {
	        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
	            // slot content that references values that might have changed,
	            // e.g. in a v-for
	            return true;
	        }
	        if (patchFlag & 16 /* FULL_PROPS */) {
	            if (!prevProps) {
	                return !!nextProps;
	            }
	            // presence of this flag indicates props are always non-null
	            return hasPropsChanged(prevProps, nextProps, emits);
	        }
	        else if (patchFlag & 8 /* PROPS */) {
	            const dynamicProps = nextVNode.dynamicProps;
	            for (let i = 0; i < dynamicProps.length; i++) {
	                const key = dynamicProps[i];
	                if (nextProps[key] !== prevProps[key] &&
	                    !isEmitListener(emits, key)) {
	                    return true;
	                }
	            }
	        }
	    }
	    else {
	        // this path is only taken by manually written render functions
	        // so presence of any children leads to a forced update
	        if (prevChildren || nextChildren) {
	            if (!nextChildren || !nextChildren.$stable) {
	                return true;
	            }
	        }
	        if (prevProps === nextProps) {
	            return false;
	        }
	        if (!prevProps) {
	            return !!nextProps;
	        }
	        if (!nextProps) {
	            return true;
	        }
	        return hasPropsChanged(prevProps, nextProps, emits);
	    }
	    return false;
	}
	function hasPropsChanged(prevProps, nextProps, emitsOptions) {
	    const nextKeys = Object.keys(nextProps);
	    if (nextKeys.length !== Object.keys(prevProps).length) {
	        return true;
	    }
	    for (let i = 0; i < nextKeys.length; i++) {
	        const key = nextKeys[i];
	        if (nextProps[key] !== prevProps[key] &&
	            !isEmitListener(emitsOptions, key)) {
	            return true;
	        }
	    }
	    return false;
	}
	function updateHOCHostEl({ vnode, parent }, el // HostNode
	) {
	    while (parent && parent.subTree === vnode) {
	        (vnode = parent.vnode).el = el;
	        parent = parent.parent;
	    }
	}

	const isSuspense = (type) => type.__isSuspense;
	// Suspense exposes a component-like API, and is treated like a component
	// in the compiler, but internally it's a special built-in type that hooks
	// directly into the renderer.
	const SuspenseImpl = {
	    name: 'Suspense',
	    // In order to make Suspense tree-shakable, we need to avoid importing it
	    // directly in the renderer. The renderer checks for the __isSuspense flag
	    // on a vnode's type and calls the `process` method, passing in renderer
	    // internals.
	    __isSuspense: true,
	    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
	    // platform-specific impl passed from renderer
	    rendererInternals) {
	        if (n1 == null) {
	            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
	        }
	        else {
	            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
	        }
	    },
	    hydrate: hydrateSuspense,
	    create: createSuspenseBoundary,
	    normalize: normalizeSuspenseChildren
	};
	// Force-casted public typing for h and TSX props inference
	const Suspense = (SuspenseImpl );
	function triggerEvent(vnode, name) {
	    const eventListener = vnode.props && vnode.props[name];
	    if (isFunction(eventListener)) {
	        eventListener();
	    }
	}
	function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
	    const { p: patch, o: { createElement } } = rendererInternals;
	    const hiddenContainer = createElement('div');
	    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
	    // start mounting the content subtree in an off-dom container
	    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
	    // now check if we have encountered any async deps
	    if (suspense.deps > 0) {
	        // has async
	        // invoke @fallback event
	        triggerEvent(vnode, 'onPending');
	        triggerEvent(vnode, 'onFallback');
	        // mount the fallback tree
	        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
	        isSVG, slotScopeIds);
	        setActiveBranch(suspense, vnode.ssFallback);
	    }
	    else {
	        // Suspense has no async deps. Just resolve.
	        suspense.resolve();
	    }
	}
	function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
	    const suspense = (n2.suspense = n1.suspense);
	    suspense.vnode = n2;
	    n2.el = n1.el;
	    const newBranch = n2.ssContent;
	    const newFallback = n2.ssFallback;
	    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
	    if (pendingBranch) {
	        suspense.pendingBranch = newBranch;
	        if (isSameVNodeType(newBranch, pendingBranch)) {
	            // same root type but content may have changed.
	            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
	            if (suspense.deps <= 0) {
	                suspense.resolve();
	            }
	            else if (isInFallback) {
	                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
	                isSVG, slotScopeIds, optimized);
	                setActiveBranch(suspense, newFallback);
	            }
	        }
	        else {
	            // toggled before pending tree is resolved
	            suspense.pendingId++;
	            if (isHydrating) {
	                // if toggled before hydration is finished, the current DOM tree is
	                // no longer valid. set it as the active branch so it will be unmounted
	                // when resolved
	                suspense.isHydrating = false;
	                suspense.activeBranch = pendingBranch;
	            }
	            else {
	                unmount(pendingBranch, parentComponent, suspense);
	            }
	            // increment pending ID. this is used to invalidate async callbacks
	            // reset suspense state
	            suspense.deps = 0;
	            // discard effects from pending branch
	            suspense.effects.length = 0;
	            // discard previous container
	            suspense.hiddenContainer = createElement('div');
	            if (isInFallback) {
	                // already in fallback state
	                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
	                if (suspense.deps <= 0) {
	                    suspense.resolve();
	                }
	                else {
	                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
	                    isSVG, slotScopeIds, optimized);
	                    setActiveBranch(suspense, newFallback);
	                }
	            }
	            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
	                // toggled "back" to current active branch
	                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
	                // force resolve
	                suspense.resolve(true);
	            }
	            else {
	                // switched to a 3rd branch
	                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
	                if (suspense.deps <= 0) {
	                    suspense.resolve();
	                }
	            }
	        }
	    }
	    else {
	        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
	            // root did not change, just normal patch
	            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
	            setActiveBranch(suspense, newBranch);
	        }
	        else {
	            // root node toggled
	            // invoke @pending event
	            triggerEvent(n2, 'onPending');
	            // mount pending branch in off-dom container
	            suspense.pendingBranch = newBranch;
	            suspense.pendingId++;
	            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
	            if (suspense.deps <= 0) {
	                // incoming branch has no async deps, resolve now.
	                suspense.resolve();
	            }
	            else {
	                const { timeout, pendingId } = suspense;
	                if (timeout > 0) {
	                    setTimeout(() => {
	                        if (suspense.pendingId === pendingId) {
	                            suspense.fallback(newFallback);
	                        }
	                    }, timeout);
	                }
	                else if (timeout === 0) {
	                    suspense.fallback(newFallback);
	                }
	            }
	        }
	    }
	}
	let hasWarned = false;
	function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
	    /* istanbul ignore if */
	    if (!hasWarned) {
	        hasWarned = true;
	        // @ts-ignore `console.info` cannot be null error
	        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
	    }
	    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
	    const timeout = toNumber(vnode.props && vnode.props.timeout);
	    const suspense = {
	        vnode,
	        parent,
	        parentComponent,
	        isSVG,
	        container,
	        hiddenContainer,
	        anchor,
	        deps: 0,
	        pendingId: 0,
	        timeout: typeof timeout === 'number' ? timeout : -1,
	        activeBranch: null,
	        pendingBranch: null,
	        isInFallback: true,
	        isHydrating,
	        isUnmounted: false,
	        effects: [],
	        resolve(resume = false) {
	            {
	                if (!resume && !suspense.pendingBranch) {
	                    throw new Error(`suspense.resolve() is called without a pending branch.`);
	                }
	                if (suspense.isUnmounted) {
	                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
	                }
	            }
	            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
	            if (suspense.isHydrating) {
	                suspense.isHydrating = false;
	            }
	            else if (!resume) {
	                const delayEnter = activeBranch &&
	                    pendingBranch.transition &&
	                    pendingBranch.transition.mode === 'out-in';
	                if (delayEnter) {
	                    activeBranch.transition.afterLeave = () => {
	                        if (pendingId === suspense.pendingId) {
	                            move(pendingBranch, container, anchor, 0 /* ENTER */);
	                        }
	                    };
	                }
	                // this is initial anchor on mount
	                let { anchor } = suspense;
	                // unmount current active tree
	                if (activeBranch) {
	                    // if the fallback tree was mounted, it may have been moved
	                    // as part of a parent suspense. get the latest anchor for insertion
	                    anchor = next(activeBranch);
	                    unmount(activeBranch, parentComponent, suspense, true);
	                }
	                if (!delayEnter) {
	                    // move content from off-dom container to actual container
	                    move(pendingBranch, container, anchor, 0 /* ENTER */);
	                }
	            }
	            setActiveBranch(suspense, pendingBranch);
	            suspense.pendingBranch = null;
	            suspense.isInFallback = false;
	            // flush buffered effects
	            // check if there is a pending parent suspense
	            let parent = suspense.parent;
	            let hasUnresolvedAncestor = false;
	            while (parent) {
	                if (parent.pendingBranch) {
	                    // found a pending parent suspense, merge buffered post jobs
	                    // into that parent
	                    parent.effects.push(...effects);
	                    hasUnresolvedAncestor = true;
	                    break;
	                }
	                parent = parent.parent;
	            }
	            // no pending parent suspense, flush all jobs
	            if (!hasUnresolvedAncestor) {
	                queuePostFlushCb(effects);
	            }
	            suspense.effects = [];
	            // invoke @resolve event
	            triggerEvent(vnode, 'onResolve');
	        },
	        fallback(fallbackVNode) {
	            if (!suspense.pendingBranch) {
	                return;
	            }
	            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
	            // invoke @fallback event
	            triggerEvent(vnode, 'onFallback');
	            const anchor = next(activeBranch);
	            const mountFallback = () => {
	                if (!suspense.isInFallback) {
	                    return;
	                }
	                // mount the fallback tree
	                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
	                isSVG, slotScopeIds, optimized);
	                setActiveBranch(suspense, fallbackVNode);
	            };
	            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
	            if (delayEnter) {
	                activeBranch.transition.afterLeave = mountFallback;
	            }
	            suspense.isInFallback = true;
	            // unmount current active branch
	            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
	            true // shouldRemove
	            );
	            if (!delayEnter) {
	                mountFallback();
	            }
	        },
	        move(container, anchor, type) {
	            suspense.activeBranch &&
	                move(suspense.activeBranch, container, anchor, type);
	            suspense.container = container;
	        },
	        next() {
	            return suspense.activeBranch && next(suspense.activeBranch);
	        },
	        registerDep(instance, setupRenderEffect) {
	            const isInPendingSuspense = !!suspense.pendingBranch;
	            if (isInPendingSuspense) {
	                suspense.deps++;
	            }
	            const hydratedEl = instance.vnode.el;
	            instance
	                .asyncDep.catch(err => {
	                handleError(err, instance, 0 /* SETUP_FUNCTION */);
	            })
	                .then(asyncSetupResult => {
	                // retry when the setup() promise resolves.
	                // component may have been unmounted before resolve.
	                if (instance.isUnmounted ||
	                    suspense.isUnmounted ||
	                    suspense.pendingId !== instance.suspenseId) {
	                    return;
	                }
	                // retry from this component
	                instance.asyncResolved = true;
	                const { vnode } = instance;
	                {
	                    pushWarningContext(vnode);
	                }
	                handleSetupResult(instance, asyncSetupResult, false);
	                if (hydratedEl) {
	                    // vnode may have been replaced if an update happened before the
	                    // async dep is resolved.
	                    vnode.el = hydratedEl;
	                }
	                const placeholder = !hydratedEl && instance.subTree.el;
	                setupRenderEffect(instance, vnode, 
	                // component may have been moved before resolve.
	                // if this is not a hydration, instance.subTree will be the comment
	                // placeholder.
	                parentNode(hydratedEl || instance.subTree.el), 
	                // anchor will not be used if this is hydration, so only need to
	                // consider the comment placeholder case.
	                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
	                if (placeholder) {
	                    remove(placeholder);
	                }
	                updateHOCHostEl(instance, vnode.el);
	                {
	                    popWarningContext();
	                }
	                // only decrease deps count if suspense is not already resolved
	                if (isInPendingSuspense && --suspense.deps === 0) {
	                    suspense.resolve();
	                }
	            });
	        },
	        unmount(parentSuspense, doRemove) {
	            suspense.isUnmounted = true;
	            if (suspense.activeBranch) {
	                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
	            }
	            if (suspense.pendingBranch) {
	                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
	            }
	        }
	    };
	    return suspense;
	}
	function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
	    /* eslint-disable no-restricted-globals */
	    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
	    // there are two possible scenarios for server-rendered suspense:
	    // - success: ssr content should be fully resolved
	    // - failure: ssr content should be the fallback branch.
	    // however, on the client we don't really know if it has failed or not
	    // attempt to hydrate the DOM assuming it has succeeded, but we still
	    // need to construct a suspense boundary first
	    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
	    if (suspense.deps === 0) {
	        suspense.resolve();
	    }
	    return result;
	    /* eslint-enable no-restricted-globals */
	}
	function normalizeSuspenseChildren(vnode) {
	    const { shapeFlag, children } = vnode;
	    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;
	    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
	    vnode.ssFallback = isSlotChildren
	        ? normalizeSuspenseSlot(children.fallback)
	        : createVNode(Comment);
	}
	function normalizeSuspenseSlot(s) {
	    let block;
	    if (isFunction(s)) {
	        const trackBlock = isBlockTreeEnabled && s._c;
	        if (trackBlock) {
	            // disableTracking: false
	            // allow block tracking for compiled slots
	            // (see ./componentRenderContext.ts)
	            s._d = false;
	            openBlock();
	        }
	        s = s();
	        if (trackBlock) {
	            s._d = true;
	            block = currentBlock;
	            closeBlock();
	        }
	    }
	    if (isArray(s)) {
	        const singleChild = filterSingleRoot(s);
	        if (!singleChild) {
	            warn$1(`<Suspense> slots expect a single root node.`);
	        }
	        s = singleChild;
	    }
	    s = normalizeVNode(s);
	    if (block && !s.dynamicChildren) {
	        s.dynamicChildren = block.filter(c => c !== s);
	    }
	    return s;
	}
	function queueEffectWithSuspense(fn, suspense) {
	    if (suspense && suspense.pendingBranch) {
	        if (isArray(fn)) {
	            suspense.effects.push(...fn);
	        }
	        else {
	            suspense.effects.push(fn);
	        }
	    }
	    else {
	        queuePostFlushCb(fn);
	    }
	}
	function setActiveBranch(suspense, branch) {
	    suspense.activeBranch = branch;
	    const { vnode, parentComponent } = suspense;
	    const el = (vnode.el = branch.el);
	    // in case suspense is the root node of a component,
	    // recursively update the HOC el
	    if (parentComponent && parentComponent.subTree === vnode) {
	        parentComponent.vnode.el = el;
	        updateHOCHostEl(parentComponent, el);
	    }
	}

	function provide(key, value) {
	    if (!currentInstance) {
	        {
	            warn$1(`provide() can only be used inside setup().`);
	        }
	    }
	    else {
	        let provides = currentInstance.provides;
	        // by default an instance inherits its parent's provides object
	        // but when it needs to provide values of its own, it creates its
	        // own provides object using parent provides object as prototype.
	        // this way in `inject` we can simply look up injections from direct
	        // parent and let the prototype chain do the work.
	        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
	        if (parentProvides === provides) {
	            provides = currentInstance.provides = Object.create(parentProvides);
	        }
	        // TS doesn't allow symbol as index type
	        provides[key] = value;
	    }
	}
	function inject(key, defaultValue, treatDefaultAsFactory = false) {
	    // fallback to `currentRenderingInstance` so that this can be called in
	    // a functional component
	    const instance = currentInstance || currentRenderingInstance;
	    if (instance) {
	        // #2400
	        // to support `app.use` plugins,
	        // fallback to appContext's `provides` if the instance is at root
	        const provides = instance.parent == null
	            ? instance.vnode.appContext && instance.vnode.appContext.provides
	            : instance.parent.provides;
	        if (provides && key in provides) {
	            // TS doesn't allow symbol as index type
	            return provides[key];
	        }
	        else if (arguments.length > 1) {
	            return treatDefaultAsFactory && isFunction(defaultValue)
	                ? defaultValue.call(instance.proxy)
	                : defaultValue;
	        }
	        else {
	            warn$1(`injection "${String(key)}" not found.`);
	        }
	    }
	    else {
	        warn$1(`inject() can only be used inside setup() or functional components.`);
	    }
	}

	// Simple effect.
	function watchEffect(effect, options) {
	    return doWatch(effect, null, options);
	}
	function watchPostEffect(effect, options) {
	    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'post' }) ));
	}
	function watchSyncEffect(effect, options) {
	    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'sync' }) ));
	}
	// initial value for watchers to trigger on undefined initial values
	const INITIAL_WATCHER_VALUE = {};
	// implementation
	function watch(source, cb, options) {
	    if (!isFunction(cb)) {
	        warn$1(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
	            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
	            `supports \`watch(source, cb, options?) signature.`);
	    }
	    return doWatch(source, cb, options);
	}
	function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
	    if (!cb) {
	        if (immediate !== undefined) {
	            warn$1(`watch() "immediate" option is only respected when using the ` +
	                `watch(source, callback, options?) signature.`);
	        }
	        if (deep !== undefined) {
	            warn$1(`watch() "deep" option is only respected when using the ` +
	                `watch(source, callback, options?) signature.`);
	        }
	    }
	    const warnInvalidSource = (s) => {
	        warn$1(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
	            `a reactive object, or an array of these types.`);
	    };
	    const instance = currentInstance;
	    let getter;
	    let forceTrigger = false;
	    let isMultiSource = false;
	    if (isRef(source)) {
	        getter = () => source.value;
	        forceTrigger = isShallow(source);
	    }
	    else if (isReactive(source)) {
	        getter = () => source;
	        deep = true;
	    }
	    else if (isArray(source)) {
	        isMultiSource = true;
	        forceTrigger = source.some(s => isReactive(s) || isShallow(s));
	        getter = () => source.map(s => {
	            if (isRef(s)) {
	                return s.value;
	            }
	            else if (isReactive(s)) {
	                return traverse(s);
	            }
	            else if (isFunction(s)) {
	                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
	            }
	            else {
	                warnInvalidSource(s);
	            }
	        });
	    }
	    else if (isFunction(source)) {
	        if (cb) {
	            // getter with cb
	            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
	        }
	        else {
	            // no cb -> simple effect
	            getter = () => {
	                if (instance && instance.isUnmounted) {
	                    return;
	                }
	                if (cleanup) {
	                    cleanup();
	                }
	                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);
	            };
	        }
	    }
	    else {
	        getter = NOOP;
	        warnInvalidSource(source);
	    }
	    if (cb && deep) {
	        const baseGetter = getter;
	        getter = () => traverse(baseGetter());
	    }
	    let cleanup;
	    let onCleanup = (fn) => {
	        cleanup = effect.onStop = () => {
	            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
	        };
	    };
	    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
	    const job = () => {
	        if (!effect.active) {
	            return;
	        }
	        if (cb) {
	            // watch(source, cb)
	            const newValue = effect.run();
	            if (deep ||
	                forceTrigger ||
	                (isMultiSource
	                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))
	                    : hasChanged(newValue, oldValue)) ||
	                (false  )) {
	                // cleanup before running cb again
	                if (cleanup) {
	                    cleanup();
	                }
	                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
	                    newValue,
	                    // pass undefined as the old value when it's changed for the first time
	                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
	                    onCleanup
	                ]);
	                oldValue = newValue;
	            }
	        }
	        else {
	            // watchEffect
	            effect.run();
	        }
	    };
	    // important: mark the job as a watcher callback so that scheduler knows
	    // it is allowed to self-trigger (#1727)
	    job.allowRecurse = !!cb;
	    let scheduler;
	    if (flush === 'sync') {
	        scheduler = job; // the scheduler function gets called directly
	    }
	    else if (flush === 'post') {
	        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
	    }
	    else {
	        // default: 'pre'
	        scheduler = () => queuePreFlushCb(job);
	    }
	    const effect = new ReactiveEffect(getter, scheduler);
	    {
	        effect.onTrack = onTrack;
	        effect.onTrigger = onTrigger;
	    }
	    // initial run
	    if (cb) {
	        if (immediate) {
	            job();
	        }
	        else {
	            oldValue = effect.run();
	        }
	    }
	    else if (flush === 'post') {
	        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
	    }
	    else {
	        effect.run();
	    }
	    return () => {
	        effect.stop();
	        if (instance && instance.scope) {
	            remove(instance.scope.effects, effect);
	        }
	    };
	}
	// this.$watch
	function instanceWatch(source, value, options) {
	    const publicThis = this.proxy;
	    const getter = isString(source)
	        ? source.includes('.')
	            ? createPathGetter(publicThis, source)
	            : () => publicThis[source]
	        : source.bind(publicThis, publicThis);
	    let cb;
	    if (isFunction(value)) {
	        cb = value;
	    }
	    else {
	        cb = value.handler;
	        options = value;
	    }
	    const cur = currentInstance;
	    setCurrentInstance(this);
	    const res = doWatch(getter, cb.bind(publicThis), options);
	    if (cur) {
	        setCurrentInstance(cur);
	    }
	    else {
	        unsetCurrentInstance();
	    }
	    return res;
	}
	function createPathGetter(ctx, path) {
	    const segments = path.split('.');
	    return () => {
	        let cur = ctx;
	        for (let i = 0; i < segments.length && cur; i++) {
	            cur = cur[segments[i]];
	        }
	        return cur;
	    };
	}
	function traverse(value, seen) {
	    if (!isObject(value) || value["__v_skip" /* SKIP */]) {
	        return value;
	    }
	    seen = seen || new Set();
	    if (seen.has(value)) {
	        return value;
	    }
	    seen.add(value);
	    if (isRef(value)) {
	        traverse(value.value, seen);
	    }
	    else if (isArray(value)) {
	        for (let i = 0; i < value.length; i++) {
	            traverse(value[i], seen);
	        }
	    }
	    else if (isSet(value) || isMap(value)) {
	        value.forEach((v) => {
	            traverse(v, seen);
	        });
	    }
	    else if (isPlainObject(value)) {
	        for (const key in value) {
	            traverse(value[key], seen);
	        }
	    }
	    return value;
	}

	function useTransitionState() {
	    const state = {
	        isMounted: false,
	        isLeaving: false,
	        isUnmounting: false,
	        leavingVNodes: new Map()
	    };
	    onMounted(() => {
	        state.isMounted = true;
	    });
	    onBeforeUnmount(() => {
	        state.isUnmounting = true;
	    });
	    return state;
	}
	const TransitionHookValidator = [Function, Array];
	const BaseTransitionImpl = {
	    name: `BaseTransition`,
	    props: {
	        mode: String,
	        appear: Boolean,
	        persisted: Boolean,
	        // enter
	        onBeforeEnter: TransitionHookValidator,
	        onEnter: TransitionHookValidator,
	        onAfterEnter: TransitionHookValidator,
	        onEnterCancelled: TransitionHookValidator,
	        // leave
	        onBeforeLeave: TransitionHookValidator,
	        onLeave: TransitionHookValidator,
	        onAfterLeave: TransitionHookValidator,
	        onLeaveCancelled: TransitionHookValidator,
	        // appear
	        onBeforeAppear: TransitionHookValidator,
	        onAppear: TransitionHookValidator,
	        onAfterAppear: TransitionHookValidator,
	        onAppearCancelled: TransitionHookValidator
	    },
	    setup(props, { slots }) {
	        const instance = getCurrentInstance();
	        const state = useTransitionState();
	        let prevTransitionKey;
	        return () => {
	            const children = slots.default && getTransitionRawChildren(slots.default(), true);
	            if (!children || !children.length) {
	                return;
	            }
	            let child = children[0];
	            if (children.length > 1) {
	                let hasFound = false;
	                // locate first non-comment child
	                for (const c of children) {
	                    if (c.type !== Comment) {
	                        if (hasFound) {
	                            // warn more than one non-comment child
	                            warn$1('<transition> can only be used on a single element or component. ' +
	                                'Use <transition-group> for lists.');
	                            break;
	                        }
	                        child = c;
	                        hasFound = true;
	                    }
	                }
	            }
	            // there's no need to track reactivity for these props so use the raw
	            // props for a bit better perf
	            const rawProps = toRaw(props);
	            const { mode } = rawProps;
	            // check mode
	            if (mode &&
	                mode !== 'in-out' &&
	                mode !== 'out-in' &&
	                mode !== 'default') {
	                warn$1(`invalid <transition> mode: ${mode}`);
	            }
	            if (state.isLeaving) {
	                return emptyPlaceholder(child);
	            }
	            // in the case of <transition><keep-alive/></transition>, we need to
	            // compare the type of the kept-alive children.
	            const innerChild = getKeepAliveChild(child);
	            if (!innerChild) {
	                return emptyPlaceholder(child);
	            }
	            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
	            setTransitionHooks(innerChild, enterHooks);
	            const oldChild = instance.subTree;
	            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
	            let transitionKeyChanged = false;
	            const { getTransitionKey } = innerChild.type;
	            if (getTransitionKey) {
	                const key = getTransitionKey();
	                if (prevTransitionKey === undefined) {
	                    prevTransitionKey = key;
	                }
	                else if (key !== prevTransitionKey) {
	                    prevTransitionKey = key;
	                    transitionKeyChanged = true;
	                }
	            }
	            // handle mode
	            if (oldInnerChild &&
	                oldInnerChild.type !== Comment &&
	                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
	                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
	                // update old tree's hooks in case of dynamic transition
	                setTransitionHooks(oldInnerChild, leavingHooks);
	                // switching between different views
	                if (mode === 'out-in') {
	                    state.isLeaving = true;
	                    // return placeholder node and queue update when leave finishes
	                    leavingHooks.afterLeave = () => {
	                        state.isLeaving = false;
	                        instance.update();
	                    };
	                    return emptyPlaceholder(child);
	                }
	                else if (mode === 'in-out' && innerChild.type !== Comment) {
	                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
	                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
	                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
	                        // early removal callback
	                        el._leaveCb = () => {
	                            earlyRemove();
	                            el._leaveCb = undefined;
	                            delete enterHooks.delayedLeave;
	                        };
	                        enterHooks.delayedLeave = delayedLeave;
	                    };
	                }
	            }
	            return child;
	        };
	    }
	};
	// export the public type for h/tsx inference
	// also to avoid inline import() in generated d.ts files
	const BaseTransition = BaseTransitionImpl;
	function getLeavingNodesForType(state, vnode) {
	    const { leavingVNodes } = state;
	    let leavingVNodesCache = leavingVNodes.get(vnode.type);
	    if (!leavingVNodesCache) {
	        leavingVNodesCache = Object.create(null);
	        leavingVNodes.set(vnode.type, leavingVNodesCache);
	    }
	    return leavingVNodesCache;
	}
	// The transition hooks are attached to the vnode as vnode.transition
	// and will be called at appropriate timing in the renderer.
	function resolveTransitionHooks(vnode, props, state, instance) {
	    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
	    const key = String(vnode.key);
	    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
	    const callHook = (hook, args) => {
	        hook &&
	            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
	    };
	    const callAsyncHook = (hook, args) => {
	        const done = args[1];
	        callHook(hook, args);
	        if (isArray(hook)) {
	            if (hook.every(hook => hook.length <= 1))
	                done();
	        }
	        else if (hook.length <= 1) {
	            done();
	        }
	    };
	    const hooks = {
	        mode,
	        persisted,
	        beforeEnter(el) {
	            let hook = onBeforeEnter;
	            if (!state.isMounted) {
	                if (appear) {
	                    hook = onBeforeAppear || onBeforeEnter;
	                }
	                else {
	                    return;
	                }
	            }
	            // for same element (v-show)
	            if (el._leaveCb) {
	                el._leaveCb(true /* cancelled */);
	            }
	            // for toggled element with same key (v-if)
	            const leavingVNode = leavingVNodesCache[key];
	            if (leavingVNode &&
	                isSameVNodeType(vnode, leavingVNode) &&
	                leavingVNode.el._leaveCb) {
	                // force early removal (not cancelled)
	                leavingVNode.el._leaveCb();
	            }
	            callHook(hook, [el]);
	        },
	        enter(el) {
	            let hook = onEnter;
	            let afterHook = onAfterEnter;
	            let cancelHook = onEnterCancelled;
	            if (!state.isMounted) {
	                if (appear) {
	                    hook = onAppear || onEnter;
	                    afterHook = onAfterAppear || onAfterEnter;
	                    cancelHook = onAppearCancelled || onEnterCancelled;
	                }
	                else {
	                    return;
	                }
	            }
	            let called = false;
	            const done = (el._enterCb = (cancelled) => {
	                if (called)
	                    return;
	                called = true;
	                if (cancelled) {
	                    callHook(cancelHook, [el]);
	                }
	                else {
	                    callHook(afterHook, [el]);
	                }
	                if (hooks.delayedLeave) {
	                    hooks.delayedLeave();
	                }
	                el._enterCb = undefined;
	            });
	            if (hook) {
	                callAsyncHook(hook, [el, done]);
	            }
	            else {
	                done();
	            }
	        },
	        leave(el, remove) {
	            const key = String(vnode.key);
	            if (el._enterCb) {
	                el._enterCb(true /* cancelled */);
	            }
	            if (state.isUnmounting) {
	                return remove();
	            }
	            callHook(onBeforeLeave, [el]);
	            let called = false;
	            const done = (el._leaveCb = (cancelled) => {
	                if (called)
	                    return;
	                called = true;
	                remove();
	                if (cancelled) {
	                    callHook(onLeaveCancelled, [el]);
	                }
	                else {
	                    callHook(onAfterLeave, [el]);
	                }
	                el._leaveCb = undefined;
	                if (leavingVNodesCache[key] === vnode) {
	                    delete leavingVNodesCache[key];
	                }
	            });
	            leavingVNodesCache[key] = vnode;
	            if (onLeave) {
	                callAsyncHook(onLeave, [el, done]);
	            }
	            else {
	                done();
	            }
	        },
	        clone(vnode) {
	            return resolveTransitionHooks(vnode, props, state, instance);
	        }
	    };
	    return hooks;
	}
	// the placeholder really only handles one special case: KeepAlive
	// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
	// placeholder with empty content to avoid the KeepAlive instance from being
	// unmounted.
	function emptyPlaceholder(vnode) {
	    if (isKeepAlive(vnode)) {
	        vnode = cloneVNode(vnode);
	        vnode.children = null;
	        return vnode;
	    }
	}
	function getKeepAliveChild(vnode) {
	    return isKeepAlive(vnode)
	        ? vnode.children
	            ? vnode.children[0]
	            : undefined
	        : vnode;
	}
	function setTransitionHooks(vnode, hooks) {
	    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
	        setTransitionHooks(vnode.component.subTree, hooks);
	    }
	    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
	        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
	        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
	    }
	    else {
	        vnode.transition = hooks;
	    }
	}
	function getTransitionRawChildren(children, keepComment = false, parentKey) {
	    let ret = [];
	    let keyedFragmentCount = 0;
	    for (let i = 0; i < children.length; i++) {
	        let child = children[i];
	        // #5360 inherit parent key in case of <template v-for>
	        const key = parentKey == null
	            ? child.key
	            : String(parentKey) + String(child.key != null ? child.key : i);
	        // handle fragment children case, e.g. v-for
	        if (child.type === Fragment) {
	            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
	                keyedFragmentCount++;
	            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
	        }
	        // comment placeholders should be skipped, e.g. v-if
	        else if (keepComment || child.type !== Comment) {
	            ret.push(key != null ? cloneVNode(child, { key }) : child);
	        }
	    }
	    // #1126 if a transition children list contains multiple sub fragments, these
	    // fragments will be merged into a flat children array. Since each v-for
	    // fragment may contain different static bindings inside, we need to de-op
	    // these children to force full diffs to ensure correct behavior.
	    if (keyedFragmentCount > 1) {
	        for (let i = 0; i < ret.length; i++) {
	            ret[i].patchFlag = -2 /* BAIL */;
	        }
	    }
	    return ret;
	}

	// implementation, close to no-op
	function defineComponent(options) {
	    return isFunction(options) ? { setup: options, name: options.name } : options;
	}

	const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
	function defineAsyncComponent(source) {
	    if (isFunction(source)) {
	        source = { loader: source };
	    }
	    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
	    suspensible = true, onError: userOnError } = source;
	    let pendingRequest = null;
	    let resolvedComp;
	    let retries = 0;
	    const retry = () => {
	        retries++;
	        pendingRequest = null;
	        return load();
	    };
	    const load = () => {
	        let thisRequest;
	        return (pendingRequest ||
	            (thisRequest = pendingRequest =
	                loader()
	                    .catch(err => {
	                    err = err instanceof Error ? err : new Error(String(err));
	                    if (userOnError) {
	                        return new Promise((resolve, reject) => {
	                            const userRetry = () => resolve(retry());
	                            const userFail = () => reject(err);
	                            userOnError(err, userRetry, userFail, retries + 1);
	                        });
	                    }
	                    else {
	                        throw err;
	                    }
	                })
	                    .then((comp) => {
	                    if (thisRequest !== pendingRequest && pendingRequest) {
	                        return pendingRequest;
	                    }
	                    if (!comp) {
	                        warn$1(`Async component loader resolved to undefined. ` +
	                            `If you are using retry(), make sure to return its return value.`);
	                    }
	                    // interop module default
	                    if (comp &&
	                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
	                        comp = comp.default;
	                    }
	                    if (comp && !isObject(comp) && !isFunction(comp)) {
	                        throw new Error(`Invalid async component load result: ${comp}`);
	                    }
	                    resolvedComp = comp;
	                    return comp;
	                })));
	    };
	    return defineComponent({
	        name: 'AsyncComponentWrapper',
	        __asyncLoader: load,
	        get __asyncResolved() {
	            return resolvedComp;
	        },
	        setup() {
	            const instance = currentInstance;
	            // already resolved
	            if (resolvedComp) {
	                return () => createInnerComp(resolvedComp, instance);
	            }
	            const onError = (err) => {
	                pendingRequest = null;
	                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
	            };
	            // suspense-controlled or SSR.
	            if ((suspensible && instance.suspense) ||
	                (false )) {
	                return load()
	                    .then(comp => {
	                    return () => createInnerComp(comp, instance);
	                })
	                    .catch(err => {
	                    onError(err);
	                    return () => errorComponent
	                        ? createVNode(errorComponent, {
	                            error: err
	                        })
	                        : null;
	                });
	            }
	            const loaded = ref(false);
	            const error = ref();
	            const delayed = ref(!!delay);
	            if (delay) {
	                setTimeout(() => {
	                    delayed.value = false;
	                }, delay);
	            }
	            if (timeout != null) {
	                setTimeout(() => {
	                    if (!loaded.value && !error.value) {
	                        const err = new Error(`Async component timed out after ${timeout}ms.`);
	                        onError(err);
	                        error.value = err;
	                    }
	                }, timeout);
	            }
	            load()
	                .then(() => {
	                loaded.value = true;
	                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
	                    // parent is keep-alive, force update so the loaded component's
	                    // name is taken into account
	                    queueJob(instance.parent.update);
	                }
	            })
	                .catch(err => {
	                onError(err);
	                error.value = err;
	            });
	            return () => {
	                if (loaded.value && resolvedComp) {
	                    return createInnerComp(resolvedComp, instance);
	                }
	                else if (error.value && errorComponent) {
	                    return createVNode(errorComponent, {
	                        error: error.value
	                    });
	                }
	                else if (loadingComponent && !delayed.value) {
	                    return createVNode(loadingComponent);
	                }
	            };
	        }
	    });
	}
	function createInnerComp(comp, { vnode: { ref, props, children, shapeFlag }, parent }) {
	    const vnode = createVNode(comp, props, children);
	    // ensure inner component inherits the async wrapper's ref owner
	    vnode.ref = ref;
	    return vnode;
	}

	const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
	const KeepAliveImpl = {
	    name: `KeepAlive`,
	    // Marker for special handling inside the renderer. We are not using a ===
	    // check directly on KeepAlive in the renderer, because importing it directly
	    // would prevent it from being tree-shaken.
	    __isKeepAlive: true,
	    props: {
	        include: [String, RegExp, Array],
	        exclude: [String, RegExp, Array],
	        max: [String, Number]
	    },
	    setup(props, { slots }) {
	        const instance = getCurrentInstance();
	        // KeepAlive communicates with the instantiated renderer via the
	        // ctx where the renderer passes in its internals,
	        // and the KeepAlive instance exposes activate/deactivate implementations.
	        // The whole point of this is to avoid importing KeepAlive directly in the
	        // renderer to facilitate tree-shaking.
	        const sharedContext = instance.ctx;
	        const cache = new Map();
	        const keys = new Set();
	        let current = null;
	        {
	            instance.__v_cache = cache;
	        }
	        const parentSuspense = instance.suspense;
	        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
	        const storageContainer = createElement('div');
	        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
	            const instance = vnode.component;
	            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
	            // in case props have changed
	            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
	            queuePostRenderEffect(() => {
	                instance.isDeactivated = false;
	                if (instance.a) {
	                    invokeArrayFns(instance.a);
	                }
	                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
	                if (vnodeHook) {
	                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
	                }
	            }, parentSuspense);
	            {
	                // Update components tree
	                devtoolsComponentAdded(instance);
	            }
	        };
	        sharedContext.deactivate = (vnode) => {
	            const instance = vnode.component;
	            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
	            queuePostRenderEffect(() => {
	                if (instance.da) {
	                    invokeArrayFns(instance.da);
	                }
	                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
	                if (vnodeHook) {
	                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
	                }
	                instance.isDeactivated = true;
	            }, parentSuspense);
	            {
	                // Update components tree
	                devtoolsComponentAdded(instance);
	            }
	        };
	        function unmount(vnode) {
	            // reset the shapeFlag so it can be properly unmounted
	            resetShapeFlag(vnode);
	            _unmount(vnode, instance, parentSuspense, true);
	        }
	        function pruneCache(filter) {
	            cache.forEach((vnode, key) => {
	                const name = getComponentName(vnode.type);
	                if (name && (!filter || !filter(name))) {
	                    pruneCacheEntry(key);
	                }
	            });
	        }
	        function pruneCacheEntry(key) {
	            const cached = cache.get(key);
	            if (!current || cached.type !== current.type) {
	                unmount(cached);
	            }
	            else if (current) {
	                // current active instance should no longer be kept-alive.
	                // we can't unmount it now but it might be later, so reset its flag now.
	                resetShapeFlag(current);
	            }
	            cache.delete(key);
	            keys.delete(key);
	        }
	        // prune cache on include/exclude prop change
	        watch(() => [props.include, props.exclude], ([include, exclude]) => {
	            include && pruneCache(name => matches(include, name));
	            exclude && pruneCache(name => !matches(exclude, name));
	        }, 
	        // prune post-render after `current` has been updated
	        { flush: 'post', deep: true });
	        // cache sub tree after render
	        let pendingCacheKey = null;
	        const cacheSubtree = () => {
	            // fix #1621, the pendingCacheKey could be 0
	            if (pendingCacheKey != null) {
	                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
	            }
	        };
	        onMounted(cacheSubtree);
	        onUpdated(cacheSubtree);
	        onBeforeUnmount(() => {
	            cache.forEach(cached => {
	                const { subTree, suspense } = instance;
	                const vnode = getInnerChild(subTree);
	                if (cached.type === vnode.type) {
	                    // current instance will be unmounted as part of keep-alive's unmount
	                    resetShapeFlag(vnode);
	                    // but invoke its deactivated hook here
	                    const da = vnode.component.da;
	                    da && queuePostRenderEffect(da, suspense);
	                    return;
	                }
	                unmount(cached);
	            });
	        });
	        return () => {
	            pendingCacheKey = null;
	            if (!slots.default) {
	                return null;
	            }
	            const children = slots.default();
	            const rawVNode = children[0];
	            if (children.length > 1) {
	                {
	                    warn$1(`KeepAlive should contain exactly one component child.`);
	                }
	                current = null;
	                return children;
	            }
	            else if (!isVNode(rawVNode) ||
	                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
	                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
	                current = null;
	                return rawVNode;
	            }
	            let vnode = getInnerChild(rawVNode);
	            const comp = vnode.type;
	            // for async components, name check should be based in its loaded
	            // inner component if available
	            const name = getComponentName(isAsyncWrapper(vnode)
	                ? vnode.type.__asyncResolved || {}
	                : comp);
	            const { include, exclude, max } = props;
	            if ((include && (!name || !matches(include, name))) ||
	                (exclude && name && matches(exclude, name))) {
	                current = vnode;
	                return rawVNode;
	            }
	            const key = vnode.key == null ? comp : vnode.key;
	            const cachedVNode = cache.get(key);
	            // clone vnode if it's reused because we are going to mutate it
	            if (vnode.el) {
	                vnode = cloneVNode(vnode);
	                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
	                    rawVNode.ssContent = vnode;
	                }
	            }
	            // #1513 it's possible for the returned vnode to be cloned due to attr
	            // fallthrough or scopeId, so the vnode here may not be the final vnode
	            // that is mounted. Instead of caching it directly, we store the pending
	            // key and cache `instance.subTree` (the normalized vnode) in
	            // beforeMount/beforeUpdate hooks.
	            pendingCacheKey = key;
	            if (cachedVNode) {
	                // copy over mounted state
	                vnode.el = cachedVNode.el;
	                vnode.component = cachedVNode.component;
	                if (vnode.transition) {
	                    // recursively update transition hooks on subTree
	                    setTransitionHooks(vnode, vnode.transition);
	                }
	                // avoid vnode being mounted as fresh
	                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
	                // make this key the freshest
	                keys.delete(key);
	                keys.add(key);
	            }
	            else {
	                keys.add(key);
	                // prune oldest entry
	                if (max && keys.size > parseInt(max, 10)) {
	                    pruneCacheEntry(keys.values().next().value);
	                }
	            }
	            // avoid vnode being unmounted
	            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
	            current = vnode;
	            return isSuspense(rawVNode.type) ? rawVNode : vnode;
	        };
	    }
	};
	// export the public type for h/tsx inference
	// also to avoid inline import() in generated d.ts files
	const KeepAlive = KeepAliveImpl;
	function matches(pattern, name) {
	    if (isArray(pattern)) {
	        return pattern.some((p) => matches(p, name));
	    }
	    else if (isString(pattern)) {
	        return pattern.split(',').includes(name);
	    }
	    else if (pattern.test) {
	        return pattern.test(name);
	    }
	    /* istanbul ignore next */
	    return false;
	}
	function onActivated(hook, target) {
	    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
	}
	function onDeactivated(hook, target) {
	    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
	}
	function registerKeepAliveHook(hook, type, target = currentInstance) {
	    // cache the deactivate branch check wrapper for injected hooks so the same
	    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
	    // deactivation check".
	    const wrappedHook = hook.__wdc ||
	        (hook.__wdc = () => {
	            // only fire the hook if the target instance is NOT in a deactivated branch.
	            let current = target;
	            while (current) {
	                if (current.isDeactivated) {
	                    return;
	                }
	                current = current.parent;
	            }
	            return hook();
	        });
	    injectHook(type, wrappedHook, target);
	    // In addition to registering it on the target instance, we walk up the parent
	    // chain and register it on all ancestor instances that are keep-alive roots.
	    // This avoids the need to walk the entire component tree when invoking these
	    // hooks, and more importantly, avoids the need to track child components in
	    // arrays.
	    if (target) {
	        let current = target.parent;
	        while (current && current.parent) {
	            if (isKeepAlive(current.parent.vnode)) {
	                injectToKeepAliveRoot(wrappedHook, type, target, current);
	            }
	            current = current.parent;
	        }
	    }
	}
	function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
	    // injectHook wraps the original for error handling, so make sure to remove
	    // the wrapped version.
	    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
	    onUnmounted(() => {
	        remove(keepAliveRoot[type], injected);
	    }, target);
	}
	function resetShapeFlag(vnode) {
	    let shapeFlag = vnode.shapeFlag;
	    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
	        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
	    }
	    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
	        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
	    }
	    vnode.shapeFlag = shapeFlag;
	}
	function getInnerChild(vnode) {
	    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
	}

	function injectHook(type, hook, target = currentInstance, prepend = false) {
	    if (target) {
	        const hooks = target[type] || (target[type] = []);
	        // cache the error handling wrapper for injected hooks so the same hook
	        // can be properly deduped by the scheduler. "__weh" stands for "with error
	        // handling".
	        const wrappedHook = hook.__weh ||
	            (hook.__weh = (...args) => {
	                if (target.isUnmounted) {
	                    return;
	                }
	                // disable tracking inside all lifecycle hooks
	                // since they can potentially be called inside effects.
	                pauseTracking();
	                // Set currentInstance during hook invocation.
	                // This assumes the hook does not synchronously trigger other hooks, which
	                // can only be false when the user does something really funky.
	                setCurrentInstance(target);
	                const res = callWithAsyncErrorHandling(hook, target, type, args);
	                unsetCurrentInstance();
	                resetTracking();
	                return res;
	            });
	        if (prepend) {
	            hooks.unshift(wrappedHook);
	        }
	        else {
	            hooks.push(wrappedHook);
	        }
	        return wrappedHook;
	    }
	    else {
	        const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''));
	        warn$1(`${apiName} is called when there is no active component instance to be ` +
	            `associated with. ` +
	            `Lifecycle injection APIs can only be used during execution of setup().` +
	            (` If you are using async setup(), make sure to register lifecycle ` +
	                    `hooks before the first await statement.`
	                ));
	    }
	}
	const createHook = (lifecycle) => (hook, target = currentInstance) => 
	// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
	(!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */) &&
	    injectHook(lifecycle, hook, target);
	const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
	const onMounted = createHook("m" /* MOUNTED */);
	const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
	const onUpdated = createHook("u" /* UPDATED */);
	const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
	const onUnmounted = createHook("um" /* UNMOUNTED */);
	const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */);
	const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
	const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
	function onErrorCaptured(hook, target = currentInstance) {
	    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
	}

	/**
	Runtime helper for applying directives to a vnode. Example usage:

	const comp = resolveComponent('comp')
	const foo = resolveDirective('foo')
	const bar = resolveDirective('bar')

	return withDirectives(h(comp), [
	  [foo, this.x],
	  [bar, this.y]
	])
	*/
	function validateDirectiveName(name) {
	    if (isBuiltInDirective(name)) {
	        warn$1('Do not use built-in directive ids as custom directive id: ' + name);
	    }
	}
	/**
	 * Adds directives to a VNode.
	 */
	function withDirectives(vnode, directives) {
	    const internalInstance = currentRenderingInstance;
	    if (internalInstance === null) {
	        warn$1(`withDirectives can only be used inside render functions.`);
	        return vnode;
	    }
	    const instance = getExposeProxy(internalInstance) ||
	        internalInstance.proxy;
	    const bindings = vnode.dirs || (vnode.dirs = []);
	    for (let i = 0; i < directives.length; i++) {
	        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
	        if (isFunction(dir)) {
	            dir = {
	                mounted: dir,
	                updated: dir
	            };
	        }
	        if (dir.deep) {
	            traverse(value);
	        }
	        bindings.push({
	            dir,
	            instance,
	            value,
	            oldValue: void 0,
	            arg,
	            modifiers
	        });
	    }
	    return vnode;
	}
	function invokeDirectiveHook(vnode, prevVNode, instance, name) {
	    const bindings = vnode.dirs;
	    const oldBindings = prevVNode && prevVNode.dirs;
	    for (let i = 0; i < bindings.length; i++) {
	        const binding = bindings[i];
	        if (oldBindings) {
	            binding.oldValue = oldBindings[i].value;
	        }
	        let hook = binding.dir[name];
	        if (hook) {
	            // disable tracking inside all lifecycle hooks
	            // since they can potentially be called inside effects.
	            pauseTracking();
	            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
	                vnode.el,
	                binding,
	                vnode,
	                prevVNode
	            ]);
	            resetTracking();
	        }
	    }
	}

	const COMPONENTS = 'components';
	const DIRECTIVES = 'directives';
	/**
	 * @private
	 */
	function resolveComponent(name, maybeSelfReference) {
	    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
	}
	const NULL_DYNAMIC_COMPONENT = Symbol();
	/**
	 * @private
	 */
	function resolveDynamicComponent(component) {
	    if (isString(component)) {
	        return resolveAsset(COMPONENTS, component, false) || component;
	    }
	    else {
	        // invalid types will fallthrough to createVNode and raise warning
	        return (component || NULL_DYNAMIC_COMPONENT);
	    }
	}
	/**
	 * @private
	 */
	function resolveDirective(name) {
	    return resolveAsset(DIRECTIVES, name);
	}
	// implementation
	function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
	    const instance = currentRenderingInstance || currentInstance;
	    if (instance) {
	        const Component = instance.type;
	        // explicit self name has highest priority
	        if (type === COMPONENTS) {
	            const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);
	            if (selfName &&
	                (selfName === name ||
	                    selfName === camelize(name) ||
	                    selfName === capitalize(camelize(name)))) {
	                return Component;
	            }
	        }
	        const res = 
	        // local registration
	        // check instance[type] first which is resolved for options API
	        resolve(instance[type] || Component[type], name) ||
	            // global registration
	            resolve(instance.appContext[type], name);
	        if (!res && maybeSelfReference) {
	            // fallback to implicit self-reference
	            return Component;
	        }
	        if (warnMissing && !res) {
	            const extra = type === COMPONENTS
	                ? `\nIf this is a native custom element, make sure to exclude it from ` +
	                    `component resolution via compilerOptions.isCustomElement.`
	                : ``;
	            warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
	        }
	        return res;
	    }
	    else {
	        warn$1(`resolve${capitalize(type.slice(0, -1))} ` +
	            `can only be used in render() or setup().`);
	    }
	}
	function resolve(registry, name) {
	    return (registry &&
	        (registry[name] ||
	            registry[camelize(name)] ||
	            registry[capitalize(camelize(name))]));
	}

	/**
	 * Actual implementation
	 */
	function renderList(source, renderItem, cache, index) {
	    let ret;
	    const cached = (cache && cache[index]);
	    if (isArray(source) || isString(source)) {
	        ret = new Array(source.length);
	        for (let i = 0, l = source.length; i < l; i++) {
	            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
	        }
	    }
	    else if (typeof source === 'number') {
	        if (!Number.isInteger(source)) {
	            warn$1(`The v-for range expect an integer value but got ${source}.`);
	        }
	        ret = new Array(source);
	        for (let i = 0; i < source; i++) {
	            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
	        }
	    }
	    else if (isObject(source)) {
	        if (source[Symbol.iterator]) {
	            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));
	        }
	        else {
	            const keys = Object.keys(source);
	            ret = new Array(keys.length);
	            for (let i = 0, l = keys.length; i < l; i++) {
	                const key = keys[i];
	                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
	            }
	        }
	    }
	    else {
	        ret = [];
	    }
	    if (cache) {
	        cache[index] = ret;
	    }
	    return ret;
	}

	/**
	 * Compiler runtime helper for creating dynamic slots object
	 * @private
	 */
	function createSlots(slots, dynamicSlots) {
	    for (let i = 0; i < dynamicSlots.length; i++) {
	        const slot = dynamicSlots[i];
	        // array of dynamic slot generated by <template v-for="..." #[...]>
	        if (isArray(slot)) {
	            for (let j = 0; j < slot.length; j++) {
	                slots[slot[j].name] = slot[j].fn;
	            }
	        }
	        else if (slot) {
	            // conditional single slot generated by <template v-if="..." #foo>
	            slots[slot.name] = slot.fn;
	        }
	    }
	    return slots;
	}

	/**
	 * Compiler runtime helper for rendering `<slot/>`
	 * @private
	 */
	function renderSlot(slots, name, props = {}, 
	// this is not a user-facing function, so the fallback is always generated by
	// the compiler and guaranteed to be a function returning an array
	fallback, noSlotted) {
	    if (currentRenderingInstance.isCE ||
	        (currentRenderingInstance.parent &&
	            isAsyncWrapper(currentRenderingInstance.parent) &&
	            currentRenderingInstance.parent.isCE)) {
	        return createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());
	    }
	    let slot = slots[name];
	    if (slot && slot.length > 1) {
	        warn$1(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
	            `function. You need to mark this component with $dynamic-slots in the ` +
	            `parent template.`);
	        slot = () => [];
	    }
	    // a compiled slot disables block tracking by default to avoid manual
	    // invocation interfering with template-based block tracking, but in
	    // `renderSlot` we can be sure that it's template-based so we can force
	    // enable it.
	    if (slot && slot._c) {
	        slot._d = false;
	    }
	    openBlock();
	    const validSlotContent = slot && ensureValidVNode(slot(props));
	    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
	        ? 64 /* STABLE_FRAGMENT */
	        : -2 /* BAIL */);
	    if (!noSlotted && rendered.scopeId) {
	        rendered.slotScopeIds = [rendered.scopeId + '-s'];
	    }
	    if (slot && slot._c) {
	        slot._d = true;
	    }
	    return rendered;
	}
	function ensureValidVNode(vnodes) {
	    return vnodes.some(child => {
	        if (!isVNode(child))
	            return true;
	        if (child.type === Comment)
	            return false;
	        if (child.type === Fragment &&
	            !ensureValidVNode(child.children))
	            return false;
	        return true;
	    })
	        ? vnodes
	        : null;
	}

	/**
	 * For prefixing keys in v-on="obj" with "on"
	 * @private
	 */
	function toHandlers(obj) {
	    const ret = {};
	    if (!isObject(obj)) {
	        warn$1(`v-on with no argument expects an object value.`);
	        return ret;
	    }
	    for (const key in obj) {
	        ret[toHandlerKey(key)] = obj[key];
	    }
	    return ret;
	}

	/**
	 * #2437 In Vue 3, functional components do not have a public instance proxy but
	 * they exist in the internal parent chain. For code that relies on traversing
	 * public $parent chains, skip functional ones and go to the parent instead.
	 */
	const getPublicInstance = (i) => {
	    if (!i)
	        return null;
	    if (isStatefulComponent(i))
	        return getExposeProxy(i) || i.proxy;
	    return getPublicInstance(i.parent);
	};
	const publicPropertiesMap = 
	// Move PURE marker to new line to workaround compiler discarding it
	// due to type annotation
	/*#__PURE__*/ extend(Object.create(null), {
	    $: i => i,
	    $el: i => i.vnode.el,
	    $data: i => i.data,
	    $props: i => (shallowReadonly(i.props) ),
	    $attrs: i => (shallowReadonly(i.attrs) ),
	    $slots: i => (shallowReadonly(i.slots) ),
	    $refs: i => (shallowReadonly(i.refs) ),
	    $parent: i => getPublicInstance(i.parent),
	    $root: i => getPublicInstance(i.root),
	    $emit: i => i.emit,
	    $options: i => (resolveMergedOptions(i) ),
	    $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),
	    $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),
	    $watch: i => (instanceWatch.bind(i) )
	});
	const isReservedPrefix = (key) => key === '_' || key === '$';
	const PublicInstanceProxyHandlers = {
	    get({ _: instance }, key) {
	        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
	        // for internal formatters to know that this is a Vue instance
	        if (key === '__isVue') {
	            return true;
	        }
	        // prioritize <script setup> bindings during dev.
	        // this allows even properties that start with _ or $ to be used - so that
	        // it aligns with the production behavior where the render fn is inlined and
	        // indeed has access to all declared variables.
	        if (setupState !== EMPTY_OBJ &&
	            setupState.__isScriptSetup &&
	            hasOwn(setupState, key)) {
	            return setupState[key];
	        }
	        // data / props / ctx
	        // This getter gets called for every property access on the render context
	        // during render and is a major hotspot. The most expensive part of this
	        // is the multiple hasOwn() calls. It's much faster to do a simple property
	        // access on a plain object, so we use an accessCache object (with null
	        // prototype) to memoize what access type a key corresponds to.
	        let normalizedProps;
	        if (key[0] !== '$') {
	            const n = accessCache[key];
	            if (n !== undefined) {
	                switch (n) {
	                    case 1 /* SETUP */:
	                        return setupState[key];
	                    case 2 /* DATA */:
	                        return data[key];
	                    case 4 /* CONTEXT */:
	                        return ctx[key];
	                    case 3 /* PROPS */:
	                        return props[key];
	                    // default: just fallthrough
	                }
	            }
	            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
	                accessCache[key] = 1 /* SETUP */;
	                return setupState[key];
	            }
	            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
	                accessCache[key] = 2 /* DATA */;
	                return data[key];
	            }
	            else if (
	            // only cache other properties when instance has declared (thus stable)
	            // props
	            (normalizedProps = instance.propsOptions[0]) &&
	                hasOwn(normalizedProps, key)) {
	                accessCache[key] = 3 /* PROPS */;
	                return props[key];
	            }
	            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
	                accessCache[key] = 4 /* CONTEXT */;
	                return ctx[key];
	            }
	            else if (shouldCacheAccess) {
	                accessCache[key] = 0 /* OTHER */;
	            }
	        }
	        const publicGetter = publicPropertiesMap[key];
	        let cssModule, globalProperties;
	        // public $xxx properties
	        if (publicGetter) {
	            if (key === '$attrs') {
	                track(instance, "get" /* GET */, key);
	                markAttrsAccessed();
	            }
	            return publicGetter(instance);
	        }
	        else if (
	        // css module (injected by vue-loader)
	        (cssModule = type.__cssModules) &&
	            (cssModule = cssModule[key])) {
	            return cssModule;
	        }
	        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
	            // user may set custom properties to `this` that start with `$`
	            accessCache[key] = 4 /* CONTEXT */;
	            return ctx[key];
	        }
	        else if (
	        // global properties
	        ((globalProperties = appContext.config.globalProperties),
	            hasOwn(globalProperties, key))) {
	            {
	                return globalProperties[key];
	            }
	        }
	        else if (currentRenderingInstance &&
	            (!isString(key) ||
	                // #1091 avoid internal isRef/isVNode checks on component instance leading
	                // to infinite warning loop
	                key.indexOf('__v') !== 0)) {
	            if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
	                warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
	                    `character ("$" or "_") and is not proxied on the render context.`);
	            }
	            else if (instance === currentRenderingInstance) {
	                warn$1(`Property ${JSON.stringify(key)} was accessed during render ` +
	                    `but is not defined on instance.`);
	            }
	        }
	    },
	    set({ _: instance }, key, value) {
	        const { data, setupState, ctx } = instance;
	        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
	            setupState[key] = value;
	            return true;
	        }
	        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
	            data[key] = value;
	            return true;
	        }
	        else if (hasOwn(instance.props, key)) {
	            warn$1(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
	            return false;
	        }
	        if (key[0] === '$' && key.slice(1) in instance) {
	            warn$1(`Attempting to mutate public property "${key}". ` +
	                    `Properties starting with $ are reserved and readonly.`, instance);
	            return false;
	        }
	        else {
	            if (key in instance.appContext.config.globalProperties) {
	                Object.defineProperty(ctx, key, {
	                    enumerable: true,
	                    configurable: true,
	                    value
	                });
	            }
	            else {
	                ctx[key] = value;
	            }
	        }
	        return true;
	    },
	    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
	        let normalizedProps;
	        return (!!accessCache[key] ||
	            (data !== EMPTY_OBJ && hasOwn(data, key)) ||
	            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||
	            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||
	            hasOwn(ctx, key) ||
	            hasOwn(publicPropertiesMap, key) ||
	            hasOwn(appContext.config.globalProperties, key));
	    },
	    defineProperty(target, key, descriptor) {
	        if (descriptor.get != null) {
	            // invalidate key cache of a getter based property #5417
	            target._.accessCache[key] = 0;
	        }
	        else if (hasOwn(descriptor, 'value')) {
	            this.set(target, key, descriptor.value, null);
	        }
	        return Reflect.defineProperty(target, key, descriptor);
	    }
	};
	{
	    PublicInstanceProxyHandlers.ownKeys = (target) => {
	        warn$1(`Avoid app logic that relies on enumerating keys on a component instance. ` +
	            `The keys will be empty in production mode to avoid performance overhead.`);
	        return Reflect.ownKeys(target);
	    };
	}
	const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ extend({}, PublicInstanceProxyHandlers, {
	    get(target, key) {
	        // fast path for unscopables when using `with` block
	        if (key === Symbol.unscopables) {
	            return;
	        }
	        return PublicInstanceProxyHandlers.get(target, key, target);
	    },
	    has(_, key) {
	        const has = key[0] !== '_' && !isGloballyWhitelisted(key);
	        if (!has && PublicInstanceProxyHandlers.has(_, key)) {
	            warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
	        }
	        return has;
	    }
	});
	// dev only
	// In dev mode, the proxy target exposes the same properties as seen on `this`
	// for easier console inspection. In prod mode it will be an empty object so
	// these properties definitions can be skipped.
	function createDevRenderContext(instance) {
	    const target = {};
	    // expose internal instance for proxy handlers
	    Object.defineProperty(target, `_`, {
	        configurable: true,
	        enumerable: false,
	        get: () => instance
	    });
	    // expose public properties
	    Object.keys(publicPropertiesMap).forEach(key => {
	        Object.defineProperty(target, key, {
	            configurable: true,
	            enumerable: false,
	            get: () => publicPropertiesMap[key](instance),
	            // intercepted by the proxy so no need for implementation,
	            // but needed to prevent set errors
	            set: NOOP
	        });
	    });
	    return target;
	}
	// dev only
	function exposePropsOnRenderContext(instance) {
	    const { ctx, propsOptions: [propsOptions] } = instance;
	    if (propsOptions) {
	        Object.keys(propsOptions).forEach(key => {
	            Object.defineProperty(ctx, key, {
	                enumerable: true,
	                configurable: true,
	                get: () => instance.props[key],
	                set: NOOP
	            });
	        });
	    }
	}
	// dev only
	function exposeSetupStateOnRenderContext(instance) {
	    const { ctx, setupState } = instance;
	    Object.keys(toRaw(setupState)).forEach(key => {
	        if (!setupState.__isScriptSetup) {
	            if (isReservedPrefix(key[0])) {
	                warn$1(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
	                    `which are reserved prefixes for Vue internals.`);
	                return;
	            }
	            Object.defineProperty(ctx, key, {
	                enumerable: true,
	                configurable: true,
	                get: () => setupState[key],
	                set: NOOP
	            });
	        }
	    });
	}

	function createDuplicateChecker() {
	    const cache = Object.create(null);
	    return (type, key) => {
	        if (cache[key]) {
	            warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
	        }
	        else {
	            cache[key] = type;
	        }
	    };
	}
	let shouldCacheAccess = true;
	function applyOptions(instance) {
	    const options = resolveMergedOptions(instance);
	    const publicThis = instance.proxy;
	    const ctx = instance.ctx;
	    // do not cache property access on public proxy during state initialization
	    shouldCacheAccess = false;
	    // call beforeCreate first before accessing other options since
	    // the hook may mutate resolved options (#2791)
	    if (options.beforeCreate) {
	        callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */);
	    }
	    const { 
	    // state
	    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
	    // lifecycle
	    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
	    // public API
	    expose, inheritAttrs, 
	    // assets
	    components, directives, filters } = options;
	    const checkDuplicateProperties = createDuplicateChecker() ;
	    {
	        const [propsOptions] = instance.propsOptions;
	        if (propsOptions) {
	            for (const key in propsOptions) {
	                checkDuplicateProperties("Props" /* PROPS */, key);
	            }
	        }
	    }
	    // options initialization order (to be consistent with Vue 2):
	    // - props (already done outside of this function)
	    // - inject
	    // - methods
	    // - data (deferred since it relies on `this` access)
	    // - computed
	    // - watch (deferred since it relies on `this` access)
	    if (injectOptions) {
	        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
	    }
	    if (methods) {
	        for (const key in methods) {
	            const methodHandler = methods[key];
	            if (isFunction(methodHandler)) {
	                // In dev mode, we use the `createRenderContext` function to define
	                // methods to the proxy target, and those are read-only but
	                // reconfigurable, so it needs to be redefined here
	                {
	                    Object.defineProperty(ctx, key, {
	                        value: methodHandler.bind(publicThis),
	                        configurable: true,
	                        enumerable: true,
	                        writable: true
	                    });
	                }
	                {
	                    checkDuplicateProperties("Methods" /* METHODS */, key);
	                }
	            }
	            else {
	                warn$1(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
	                    `Did you reference the function correctly?`);
	            }
	        }
	    }
	    if (dataOptions) {
	        if (!isFunction(dataOptions)) {
	            warn$1(`The data option must be a function. ` +
	                `Plain object usage is no longer supported.`);
	        }
	        const data = dataOptions.call(publicThis, publicThis);
	        if (isPromise(data)) {
	            warn$1(`data() returned a Promise - note data() cannot be async; If you ` +
	                `intend to perform data fetching before component renders, use ` +
	                `async setup() + <Suspense>.`);
	        }
	        if (!isObject(data)) {
	            warn$1(`data() should return an object.`);
	        }
	        else {
	            instance.data = reactive(data);
	            {
	                for (const key in data) {
	                    checkDuplicateProperties("Data" /* DATA */, key);
	                    // expose data on ctx during dev
	                    if (!isReservedPrefix(key[0])) {
	                        Object.defineProperty(ctx, key, {
	                            configurable: true,
	                            enumerable: true,
	                            get: () => data[key],
	                            set: NOOP
	                        });
	                    }
	                }
	            }
	        }
	    }
	    // state initialization complete at this point - start caching access
	    shouldCacheAccess = true;
	    if (computedOptions) {
	        for (const key in computedOptions) {
	            const opt = computedOptions[key];
	            const get = isFunction(opt)
	                ? opt.bind(publicThis, publicThis)
	                : isFunction(opt.get)
	                    ? opt.get.bind(publicThis, publicThis)
	                    : NOOP;
	            if (get === NOOP) {
	                warn$1(`Computed property "${key}" has no getter.`);
	            }
	            const set = !isFunction(opt) && isFunction(opt.set)
	                ? opt.set.bind(publicThis)
	                : () => {
	                        warn$1(`Write operation failed: computed property "${key}" is readonly.`);
	                    }
	                    ;
	            const c = computed$1({
	                get,
	                set
	            });
	            Object.defineProperty(ctx, key, {
	                enumerable: true,
	                configurable: true,
	                get: () => c.value,
	                set: v => (c.value = v)
	            });
	            {
	                checkDuplicateProperties("Computed" /* COMPUTED */, key);
	            }
	        }
	    }
	    if (watchOptions) {
	        for (const key in watchOptions) {
	            createWatcher(watchOptions[key], ctx, publicThis, key);
	        }
	    }
	    if (provideOptions) {
	        const provides = isFunction(provideOptions)
	            ? provideOptions.call(publicThis)
	            : provideOptions;
	        Reflect.ownKeys(provides).forEach(key => {
	            provide(key, provides[key]);
	        });
	    }
	    if (created) {
	        callHook(created, instance, "c" /* CREATED */);
	    }
	    function registerLifecycleHook(register, hook) {
	        if (isArray(hook)) {
	            hook.forEach(_hook => register(_hook.bind(publicThis)));
	        }
	        else if (hook) {
	            register(hook.bind(publicThis));
	        }
	    }
	    registerLifecycleHook(onBeforeMount, beforeMount);
	    registerLifecycleHook(onMounted, mounted);
	    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
	    registerLifecycleHook(onUpdated, updated);
	    registerLifecycleHook(onActivated, activated);
	    registerLifecycleHook(onDeactivated, deactivated);
	    registerLifecycleHook(onErrorCaptured, errorCaptured);
	    registerLifecycleHook(onRenderTracked, renderTracked);
	    registerLifecycleHook(onRenderTriggered, renderTriggered);
	    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
	    registerLifecycleHook(onUnmounted, unmounted);
	    registerLifecycleHook(onServerPrefetch, serverPrefetch);
	    if (isArray(expose)) {
	        if (expose.length) {
	            const exposed = instance.exposed || (instance.exposed = {});
	            expose.forEach(key => {
	                Object.defineProperty(exposed, key, {
	                    get: () => publicThis[key],
	                    set: val => (publicThis[key] = val)
	                });
	            });
	        }
	        else if (!instance.exposed) {
	            instance.exposed = {};
	        }
	    }
	    // options that are handled when creating the instance but also need to be
	    // applied from mixins
	    if (render && instance.render === NOOP) {
	        instance.render = render;
	    }
	    if (inheritAttrs != null) {
	        instance.inheritAttrs = inheritAttrs;
	    }
	    // asset options.
	    if (components)
	        instance.components = components;
	    if (directives)
	        instance.directives = directives;
	}
	function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
	    if (isArray(injectOptions)) {
	        injectOptions = normalizeInject(injectOptions);
	    }
	    for (const key in injectOptions) {
	        const opt = injectOptions[key];
	        let injected;
	        if (isObject(opt)) {
	            if ('default' in opt) {
	                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);
	            }
	            else {
	                injected = inject(opt.from || key);
	            }
	        }
	        else {
	            injected = inject(opt);
	        }
	        if (isRef(injected)) {
	            // TODO remove the check in 3.3
	            if (unwrapRef) {
	                Object.defineProperty(ctx, key, {
	                    enumerable: true,
	                    configurable: true,
	                    get: () => injected.value,
	                    set: v => (injected.value = v)
	                });
	            }
	            else {
	                {
	                    warn$1(`injected property "${key}" is a ref and will be auto-unwrapped ` +
	                        `and no longer needs \`.value\` in the next minor release. ` +
	                        `To opt-in to the new behavior now, ` +
	                        `set \`app.config.unwrapInjectedRef = true\` (this config is ` +
	                        `temporary and will not be needed in the future.)`);
	                }
	                ctx[key] = injected;
	            }
	        }
	        else {
	            ctx[key] = injected;
	        }
	        {
	            checkDuplicateProperties("Inject" /* INJECT */, key);
	        }
	    }
	}
	function callHook(hook, instance, type) {
	    callWithAsyncErrorHandling(isArray(hook)
	        ? hook.map(h => h.bind(instance.proxy))
	        : hook.bind(instance.proxy), instance, type);
	}
	function createWatcher(raw, ctx, publicThis, key) {
	    const getter = key.includes('.')
	        ? createPathGetter(publicThis, key)
	        : () => publicThis[key];
	    if (isString(raw)) {
	        const handler = ctx[raw];
	        if (isFunction(handler)) {
	            watch(getter, handler);
	        }
	        else {
	            warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
	        }
	    }
	    else if (isFunction(raw)) {
	        watch(getter, raw.bind(publicThis));
	    }
	    else if (isObject(raw)) {
	        if (isArray(raw)) {
	            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
	        }
	        else {
	            const handler = isFunction(raw.handler)
	                ? raw.handler.bind(publicThis)
	                : ctx[raw.handler];
	            if (isFunction(handler)) {
	                watch(getter, handler, raw);
	            }
	            else {
	                warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
	            }
	        }
	    }
	    else {
	        warn$1(`Invalid watch option: "${key}"`, raw);
	    }
	}
	/**
	 * Resolve merged options and cache it on the component.
	 * This is done only once per-component since the merging does not involve
	 * instances.
	 */
	function resolveMergedOptions(instance) {
	    const base = instance.type;
	    const { mixins, extends: extendsOptions } = base;
	    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
	    const cached = cache.get(base);
	    let resolved;
	    if (cached) {
	        resolved = cached;
	    }
	    else if (!globalMixins.length && !mixins && !extendsOptions) {
	        {
	            resolved = base;
	        }
	    }
	    else {
	        resolved = {};
	        if (globalMixins.length) {
	            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
	        }
	        mergeOptions(resolved, base, optionMergeStrategies);
	    }
	    cache.set(base, resolved);
	    return resolved;
	}
	function mergeOptions(to, from, strats, asMixin = false) {
	    const { mixins, extends: extendsOptions } = from;
	    if (extendsOptions) {
	        mergeOptions(to, extendsOptions, strats, true);
	    }
	    if (mixins) {
	        mixins.forEach((m) => mergeOptions(to, m, strats, true));
	    }
	    for (const key in from) {
	        if (asMixin && key === 'expose') {
	            warn$1(`"expose" option is ignored when declared in mixins or extends. ` +
	                    `It should only be declared in the base component itself.`);
	        }
	        else {
	            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
	            to[key] = strat ? strat(to[key], from[key]) : from[key];
	        }
	    }
	    return to;
	}
	const internalOptionMergeStrats = {
	    data: mergeDataFn,
	    props: mergeObjectOptions,
	    emits: mergeObjectOptions,
	    // objects
	    methods: mergeObjectOptions,
	    computed: mergeObjectOptions,
	    // lifecycle
	    beforeCreate: mergeAsArray,
	    created: mergeAsArray,
	    beforeMount: mergeAsArray,
	    mounted: mergeAsArray,
	    beforeUpdate: mergeAsArray,
	    updated: mergeAsArray,
	    beforeDestroy: mergeAsArray,
	    beforeUnmount: mergeAsArray,
	    destroyed: mergeAsArray,
	    unmounted: mergeAsArray,
	    activated: mergeAsArray,
	    deactivated: mergeAsArray,
	    errorCaptured: mergeAsArray,
	    serverPrefetch: mergeAsArray,
	    // assets
	    components: mergeObjectOptions,
	    directives: mergeObjectOptions,
	    // watch
	    watch: mergeWatchOptions,
	    // provide / inject
	    provide: mergeDataFn,
	    inject: mergeInject
	};
	function mergeDataFn(to, from) {
	    if (!from) {
	        return to;
	    }
	    if (!to) {
	        return from;
	    }
	    return function mergedDataFn() {
	        return (extend)(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
	    };
	}
	function mergeInject(to, from) {
	    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
	}
	function normalizeInject(raw) {
	    if (isArray(raw)) {
	        const res = {};
	        for (let i = 0; i < raw.length; i++) {
	            res[raw[i]] = raw[i];
	        }
	        return res;
	    }
	    return raw;
	}
	function mergeAsArray(to, from) {
	    return to ? [...new Set([].concat(to, from))] : from;
	}
	function mergeObjectOptions(to, from) {
	    return to ? extend(extend(Object.create(null), to), from) : from;
	}
	function mergeWatchOptions(to, from) {
	    if (!to)
	        return from;
	    if (!from)
	        return to;
	    const merged = extend(Object.create(null), to);
	    for (const key in from) {
	        merged[key] = mergeAsArray(to[key], from[key]);
	    }
	    return merged;
	}

	function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
	isSSR = false) {
	    const props = {};
	    const attrs = {};
	    def(attrs, InternalObjectKey, 1);
	    instance.propsDefaults = Object.create(null);
	    setFullProps(instance, rawProps, props, attrs);
	    // ensure all declared prop keys are present
	    for (const key in instance.propsOptions[0]) {
	        if (!(key in props)) {
	            props[key] = undefined;
	        }
	    }
	    // validation
	    {
	        validateProps(rawProps || {}, props, instance);
	    }
	    if (isStateful) {
	        // stateful
	        instance.props = isSSR ? props : shallowReactive(props);
	    }
	    else {
	        if (!instance.type.props) {
	            // functional w/ optional props, props === attrs
	            instance.props = attrs;
	        }
	        else {
	            // functional w/ declared props
	            instance.props = props;
	        }
	    }
	    instance.attrs = attrs;
	}
	function updateProps(instance, rawProps, rawPrevProps, optimized) {
	    const { props, attrs, vnode: { patchFlag } } = instance;
	    const rawCurrentProps = toRaw(props);
	    const [options] = instance.propsOptions;
	    let hasAttrsChanged = false;
	    if (
	    // always force full diff in dev
	    // - #1942 if hmr is enabled with sfc component
	    // - vite#872 non-sfc component used by sfc component
	    !((instance.type.__hmrId ||
	            (instance.parent && instance.parent.type.__hmrId))) &&
	        (optimized || patchFlag > 0) &&
	        !(patchFlag & 16 /* FULL_PROPS */)) {
	        if (patchFlag & 8 /* PROPS */) {
	            // Compiler-generated props & no keys change, just set the updated
	            // the props.
	            const propsToUpdate = instance.vnode.dynamicProps;
	            for (let i = 0; i < propsToUpdate.length; i++) {
	                let key = propsToUpdate[i];
	                // skip if the prop key is a declared emit event listener
	                if (isEmitListener(instance.emitsOptions, key)) {
	                    continue;
	                }
	                // PROPS flag guarantees rawProps to be non-null
	                const value = rawProps[key];
	                if (options) {
	                    // attr / props separation was done on init and will be consistent
	                    // in this code path, so just check if attrs have it.
	                    if (hasOwn(attrs, key)) {
	                        if (value !== attrs[key]) {
	                            attrs[key] = value;
	                            hasAttrsChanged = true;
	                        }
	                    }
	                    else {
	                        const camelizedKey = camelize(key);
	                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
	                    }
	                }
	                else {
	                    if (value !== attrs[key]) {
	                        attrs[key] = value;
	                        hasAttrsChanged = true;
	                    }
	                }
	            }
	        }
	    }
	    else {
	        // full props update.
	        if (setFullProps(instance, rawProps, props, attrs)) {
	            hasAttrsChanged = true;
	        }
	        // in case of dynamic props, check if we need to delete keys from
	        // the props object
	        let kebabKey;
	        for (const key in rawCurrentProps) {
	            if (!rawProps ||
	                // for camelCase
	                (!hasOwn(rawProps, key) &&
	                    // it's possible the original props was passed in as kebab-case
	                    // and converted to camelCase (#955)
	                    ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))) {
	                if (options) {
	                    if (rawPrevProps &&
	                        // for camelCase
	                        (rawPrevProps[key] !== undefined ||
	                            // for kebab-case
	                            rawPrevProps[kebabKey] !== undefined)) {
	                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
	                    }
	                }
	                else {
	                    delete props[key];
	                }
	            }
	        }
	        // in the case of functional component w/o props declaration, props and
	        // attrs point to the same object so it should already have been updated.
	        if (attrs !== rawCurrentProps) {
	            for (const key in attrs) {
	                if (!rawProps ||
	                    (!hasOwn(rawProps, key) &&
	                        (!false ))) {
	                    delete attrs[key];
	                    hasAttrsChanged = true;
	                }
	            }
	        }
	    }
	    // trigger updates for $attrs in case it's used in component slots
	    if (hasAttrsChanged) {
	        trigger(instance, "set" /* SET */, '$attrs');
	    }
	    {
	        validateProps(rawProps || {}, props, instance);
	    }
	}
	function setFullProps(instance, rawProps, props, attrs) {
	    const [options, needCastKeys] = instance.propsOptions;
	    let hasAttrsChanged = false;
	    let rawCastValues;
	    if (rawProps) {
	        for (let key in rawProps) {
	            // key, ref are reserved and never passed down
	            if (isReservedProp(key)) {
	                continue;
	            }
	            const value = rawProps[key];
	            // prop option names are camelized during normalization, so to support
	            // kebab -> camel conversion here we need to camelize the key.
	            let camelKey;
	            if (options && hasOwn(options, (camelKey = camelize(key)))) {
	                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
	                    props[camelKey] = value;
	                }
	                else {
	                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
	                }
	            }
	            else if (!isEmitListener(instance.emitsOptions, key)) {
	                if (!(key in attrs) || value !== attrs[key]) {
	                    attrs[key] = value;
	                    hasAttrsChanged = true;
	                }
	            }
	        }
	    }
	    if (needCastKeys) {
	        const rawCurrentProps = toRaw(props);
	        const castValues = rawCastValues || EMPTY_OBJ;
	        for (let i = 0; i < needCastKeys.length; i++) {
	            const key = needCastKeys[i];
	            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
	        }
	    }
	    return hasAttrsChanged;
	}
	function resolvePropValue(options, props, key, value, instance, isAbsent) {
	    const opt = options[key];
	    if (opt != null) {
	        const hasDefault = hasOwn(opt, 'default');
	        // default values
	        if (hasDefault && value === undefined) {
	            const defaultValue = opt.default;
	            if (opt.type !== Function && isFunction(defaultValue)) {
	                const { propsDefaults } = instance;
	                if (key in propsDefaults) {
	                    value = propsDefaults[key];
	                }
	                else {
	                    setCurrentInstance(instance);
	                    value = propsDefaults[key] = defaultValue.call(null, props);
	                    unsetCurrentInstance();
	                }
	            }
	            else {
	                value = defaultValue;
	            }
	        }
	        // boolean casting
	        if (opt[0 /* shouldCast */]) {
	            if (isAbsent && !hasDefault) {
	                value = false;
	            }
	            else if (opt[1 /* shouldCastTrue */] &&
	                (value === '' || value === hyphenate(key))) {
	                value = true;
	            }
	        }
	    }
	    return value;
	}
	function normalizePropsOptions(comp, appContext, asMixin = false) {
	    const cache = appContext.propsCache;
	    const cached = cache.get(comp);
	    if (cached) {
	        return cached;
	    }
	    const raw = comp.props;
	    const normalized = {};
	    const needCastKeys = [];
	    // apply mixin/extends props
	    let hasExtends = false;
	    if (!isFunction(comp)) {
	        const extendProps = (raw) => {
	            hasExtends = true;
	            const [props, keys] = normalizePropsOptions(raw, appContext, true);
	            extend(normalized, props);
	            if (keys)
	                needCastKeys.push(...keys);
	        };
	        if (!asMixin && appContext.mixins.length) {
	            appContext.mixins.forEach(extendProps);
	        }
	        if (comp.extends) {
	            extendProps(comp.extends);
	        }
	        if (comp.mixins) {
	            comp.mixins.forEach(extendProps);
	        }
	    }
	    if (!raw && !hasExtends) {
	        cache.set(comp, EMPTY_ARR);
	        return EMPTY_ARR;
	    }
	    if (isArray(raw)) {
	        for (let i = 0; i < raw.length; i++) {
	            if (!isString(raw[i])) {
	                warn$1(`props must be strings when using array syntax.`, raw[i]);
	            }
	            const normalizedKey = camelize(raw[i]);
	            if (validatePropName(normalizedKey)) {
	                normalized[normalizedKey] = EMPTY_OBJ;
	            }
	        }
	    }
	    else if (raw) {
	        if (!isObject(raw)) {
	            warn$1(`invalid props options`, raw);
	        }
	        for (const key in raw) {
	            const normalizedKey = camelize(key);
	            if (validatePropName(normalizedKey)) {
	                const opt = raw[key];
	                const prop = (normalized[normalizedKey] =
	                    isArray(opt) || isFunction(opt) ? { type: opt } : opt);
	                if (prop) {
	                    const booleanIndex = getTypeIndex(Boolean, prop.type);
	                    const stringIndex = getTypeIndex(String, prop.type);
	                    prop[0 /* shouldCast */] = booleanIndex > -1;
	                    prop[1 /* shouldCastTrue */] =
	                        stringIndex < 0 || booleanIndex < stringIndex;
	                    // if the prop needs boolean casting or default value
	                    if (booleanIndex > -1 || hasOwn(prop, 'default')) {
	                        needCastKeys.push(normalizedKey);
	                    }
	                }
	            }
	        }
	    }
	    const res = [normalized, needCastKeys];
	    cache.set(comp, res);
	    return res;
	}
	function validatePropName(key) {
	    if (key[0] !== '$') {
	        return true;
	    }
	    else {
	        warn$1(`Invalid prop name: "${key}" is a reserved property.`);
	    }
	    return false;
	}
	// use function string name to check type constructors
	// so that it works across vms / iframes.
	function getType(ctor) {
	    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
	    return match ? match[1] : ctor === null ? 'null' : '';
	}
	function isSameType(a, b) {
	    return getType(a) === getType(b);
	}
	function getTypeIndex(type, expectedTypes) {
	    if (isArray(expectedTypes)) {
	        return expectedTypes.findIndex(t => isSameType(t, type));
	    }
	    else if (isFunction(expectedTypes)) {
	        return isSameType(expectedTypes, type) ? 0 : -1;
	    }
	    return -1;
	}
	/**
	 * dev only
	 */
	function validateProps(rawProps, props, instance) {
	    const resolvedValues = toRaw(props);
	    const options = instance.propsOptions[0];
	    for (const key in options) {
	        let opt = options[key];
	        if (opt == null)
	            continue;
	        validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
	    }
	}
	/**
	 * dev only
	 */
	function validateProp(name, value, prop, isAbsent) {
	    const { type, required, validator } = prop;
	    // required!
	    if (required && isAbsent) {
	        warn$1('Missing required prop: "' + name + '"');
	        return;
	    }
	    // missing but optional
	    if (value == null && !prop.required) {
	        return;
	    }
	    // type check
	    if (type != null && type !== true) {
	        let isValid = false;
	        const types = isArray(type) ? type : [type];
	        const expectedTypes = [];
	        // value is valid as long as one of the specified types match
	        for (let i = 0; i < types.length && !isValid; i++) {
	            const { valid, expectedType } = assertType(value, types[i]);
	            expectedTypes.push(expectedType || '');
	            isValid = valid;
	        }
	        if (!isValid) {
	            warn$1(getInvalidTypeMessage(name, value, expectedTypes));
	            return;
	        }
	    }
	    // custom validator
	    if (validator && !validator(value)) {
	        warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
	    }
	}
	const isSimpleType = /*#__PURE__*/ makeMap('String,Number,Boolean,Function,Symbol,BigInt');
	/**
	 * dev only
	 */
	function assertType(value, type) {
	    let valid;
	    const expectedType = getType(type);
	    if (isSimpleType(expectedType)) {
	        const t = typeof value;
	        valid = t === expectedType.toLowerCase();
	        // for primitive wrapper objects
	        if (!valid && t === 'object') {
	            valid = value instanceof type;
	        }
	    }
	    else if (expectedType === 'Object') {
	        valid = isObject(value);
	    }
	    else if (expectedType === 'Array') {
	        valid = isArray(value);
	    }
	    else if (expectedType === 'null') {
	        valid = value === null;
	    }
	    else {
	        valid = value instanceof type;
	    }
	    return {
	        valid,
	        expectedType
	    };
	}
	/**
	 * dev only
	 */
	function getInvalidTypeMessage(name, value, expectedTypes) {
	    let message = `Invalid prop: type check failed for prop "${name}".` +
	        ` Expected ${expectedTypes.map(capitalize).join(' | ')}`;
	    const expectedType = expectedTypes[0];
	    const receivedType = toRawType(value);
	    const expectedValue = styleValue(value, expectedType);
	    const receivedValue = styleValue(value, receivedType);
	    // check if we need to specify expected value
	    if (expectedTypes.length === 1 &&
	        isExplicable(expectedType) &&
	        !isBoolean(expectedType, receivedType)) {
	        message += ` with value ${expectedValue}`;
	    }
	    message += `, got ${receivedType} `;
	    // check if we need to specify received value
	    if (isExplicable(receivedType)) {
	        message += `with value ${receivedValue}.`;
	    }
	    return message;
	}
	/**
	 * dev only
	 */
	function styleValue(value, type) {
	    if (type === 'String') {
	        return `"${value}"`;
	    }
	    else if (type === 'Number') {
	        return `${Number(value)}`;
	    }
	    else {
	        return `${value}`;
	    }
	}
	/**
	 * dev only
	 */
	function isExplicable(type) {
	    const explicitTypes = ['string', 'number', 'boolean'];
	    return explicitTypes.some(elem => type.toLowerCase() === elem);
	}
	/**
	 * dev only
	 */
	function isBoolean(...args) {
	    return args.some(elem => elem.toLowerCase() === 'boolean');
	}

	const isInternalKey = (key) => key[0] === '_' || key === '$stable';
	const normalizeSlotValue = (value) => isArray(value)
	    ? value.map(normalizeVNode)
	    : [normalizeVNode(value)];
	const normalizeSlot = (key, rawSlot, ctx) => {
	    if (rawSlot._n) {
	        // already normalized - #5353
	        return rawSlot;
	    }
	    const normalized = withCtx((...args) => {
	        if (currentInstance) {
	            warn$1(`Slot "${key}" invoked outside of the render function: ` +
	                `this will not track dependencies used in the slot. ` +
	                `Invoke the slot function inside the render function instead.`);
	        }
	        return normalizeSlotValue(rawSlot(...args));
	    }, ctx);
	    normalized._c = false;
	    return normalized;
	};
	const normalizeObjectSlots = (rawSlots, slots, instance) => {
	    const ctx = rawSlots._ctx;
	    for (const key in rawSlots) {
	        if (isInternalKey(key))
	            continue;
	        const value = rawSlots[key];
	        if (isFunction(value)) {
	            slots[key] = normalizeSlot(key, value, ctx);
	        }
	        else if (value != null) {
	            {
	                warn$1(`Non-function value encountered for slot "${key}". ` +
	                    `Prefer function slots for better performance.`);
	            }
	            const normalized = normalizeSlotValue(value);
	            slots[key] = () => normalized;
	        }
	    }
	};
	const normalizeVNodeSlots = (instance, children) => {
	    if (!isKeepAlive(instance.vnode) &&
	        !(false )) {
	        warn$1(`Non-function value encountered for default slot. ` +
	            `Prefer function slots for better performance.`);
	    }
	    const normalized = normalizeSlotValue(children);
	    instance.slots.default = () => normalized;
	};
	const initSlots = (instance, children) => {
	    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
	        const type = children._;
	        if (type) {
	            // users can get the shallow readonly version of the slots object through `this.$slots`,
	            // we should avoid the proxy object polluting the slots of the internal instance
	            instance.slots = toRaw(children);
	            // make compiler marker non-enumerable
	            def(children, '_', type);
	        }
	        else {
	            normalizeObjectSlots(children, (instance.slots = {}));
	        }
	    }
	    else {
	        instance.slots = {};
	        if (children) {
	            normalizeVNodeSlots(instance, children);
	        }
	    }
	    def(instance.slots, InternalObjectKey, 1);
	};
	const updateSlots = (instance, children, optimized) => {
	    const { vnode, slots } = instance;
	    let needDeletionCheck = true;
	    let deletionComparisonTarget = EMPTY_OBJ;
	    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
	        const type = children._;
	        if (type) {
	            // compiled slots.
	            if (isHmrUpdating) {
	                // Parent was HMR updated so slot content may have changed.
	                // force update slots and mark instance for hmr as well
	                extend(slots, children);
	            }
	            else if (optimized && type === 1 /* STABLE */) {
	                // compiled AND stable.
	                // no need to update, and skip stale slots removal.
	                needDeletionCheck = false;
	            }
	            else {
	                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
	                // normalization.
	                extend(slots, children);
	                // #2893
	                // when rendering the optimized slots by manually written render function,
	                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
	                // i.e. let the `renderSlot` create the bailed Fragment
	                if (!optimized && type === 1 /* STABLE */) {
	                    delete slots._;
	                }
	            }
	        }
	        else {
	            needDeletionCheck = !children.$stable;
	            normalizeObjectSlots(children, slots);
	        }
	        deletionComparisonTarget = children;
	    }
	    else if (children) {
	        // non slot object children (direct value) passed to a component
	        normalizeVNodeSlots(instance, children);
	        deletionComparisonTarget = { default: 1 };
	    }
	    // delete stale slots
	    if (needDeletionCheck) {
	        for (const key in slots) {
	            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
	                delete slots[key];
	            }
	        }
	    }
	};

	function createAppContext() {
	    return {
	        app: null,
	        config: {
	            isNativeTag: NO,
	            performance: false,
	            globalProperties: {},
	            optionMergeStrategies: {},
	            errorHandler: undefined,
	            warnHandler: undefined,
	            compilerOptions: {}
	        },
	        mixins: [],
	        components: {},
	        directives: {},
	        provides: Object.create(null),
	        optionsCache: new WeakMap(),
	        propsCache: new WeakMap(),
	        emitsCache: new WeakMap()
	    };
	}
	let uid = 0;
	function createAppAPI(render, hydrate) {
	    return function createApp(rootComponent, rootProps = null) {
	        if (!isFunction(rootComponent)) {
	            rootComponent = Object.assign({}, rootComponent);
	        }
	        if (rootProps != null && !isObject(rootProps)) {
	            warn$1(`root props passed to app.mount() must be an object.`);
	            rootProps = null;
	        }
	        const context = createAppContext();
	        const installedPlugins = new Set();
	        let isMounted = false;
	        const app = (context.app = {
	            _uid: uid++,
	            _component: rootComponent,
	            _props: rootProps,
	            _container: null,
	            _context: context,
	            _instance: null,
	            version,
	            get config() {
	                return context.config;
	            },
	            set config(v) {
	                {
	                    warn$1(`app.config cannot be replaced. Modify individual options instead.`);
	                }
	            },
	            use(plugin, ...options) {
	                if (installedPlugins.has(plugin)) {
	                    warn$1(`Plugin has already been applied to target app.`);
	                }
	                else if (plugin && isFunction(plugin.install)) {
	                    installedPlugins.add(plugin);
	                    plugin.install(app, ...options);
	                }
	                else if (isFunction(plugin)) {
	                    installedPlugins.add(plugin);
	                    plugin(app, ...options);
	                }
	                else {
	                    warn$1(`A plugin must either be a function or an object with an "install" ` +
	                        `function.`);
	                }
	                return app;
	            },
	            mixin(mixin) {
	                {
	                    if (!context.mixins.includes(mixin)) {
	                        context.mixins.push(mixin);
	                    }
	                    else {
	                        warn$1('Mixin has already been applied to target app' +
	                            (mixin.name ? `: ${mixin.name}` : ''));
	                    }
	                }
	                return app;
	            },
	            component(name, component) {
	                {
	                    validateComponentName(name, context.config);
	                }
	                if (!component) {
	                    return context.components[name];
	                }
	                if (context.components[name]) {
	                    warn$1(`Component "${name}" has already been registered in target app.`);
	                }
	                context.components[name] = component;
	                return app;
	            },
	            directive(name, directive) {
	                {
	                    validateDirectiveName(name);
	                }
	                if (!directive) {
	                    return context.directives[name];
	                }
	                if (context.directives[name]) {
	                    warn$1(`Directive "${name}" has already been registered in target app.`);
	                }
	                context.directives[name] = directive;
	                return app;
	            },
	            mount(rootContainer, isHydrate, isSVG) {
	                if (!isMounted) {
	                    // #5571
	                    if (rootContainer.__vue_app__) {
	                        warn$1(`There is already an app instance mounted on the host container.\n` +
	                            ` If you want to mount another app on the same host container,` +
	                            ` you need to unmount the previous app by calling \`app.unmount()\` first.`);
	                    }
	                    const vnode = createVNode(rootComponent, rootProps);
	                    // store app context on the root VNode.
	                    // this will be set on the root instance on initial mount.
	                    vnode.appContext = context;
	                    // HMR root reload
	                    {
	                        context.reload = () => {
	                            render(cloneVNode(vnode), rootContainer, isSVG);
	                        };
	                    }
	                    if (isHydrate && hydrate) {
	                        hydrate(vnode, rootContainer);
	                    }
	                    else {
	                        render(vnode, rootContainer, isSVG);
	                    }
	                    isMounted = true;
	                    app._container = rootContainer;
	                    rootContainer.__vue_app__ = app;
	                    {
	                        app._instance = vnode.component;
	                        devtoolsInitApp(app, version);
	                    }
	                    return getExposeProxy(vnode.component) || vnode.component.proxy;
	                }
	                else {
	                    warn$1(`App has already been mounted.\n` +
	                        `If you want to remount the same app, move your app creation logic ` +
	                        `into a factory function and create fresh app instances for each ` +
	                        `mount - e.g. \`const createMyApp = () => createApp(App)\``);
	                }
	            },
	            unmount() {
	                if (isMounted) {
	                    render(null, app._container);
	                    {
	                        app._instance = null;
	                        devtoolsUnmountApp(app);
	                    }
	                    delete app._container.__vue_app__;
	                }
	                else {
	                    warn$1(`Cannot unmount an app that is not mounted.`);
	                }
	            },
	            provide(key, value) {
	                if (key in context.provides) {
	                    warn$1(`App already provides property with key "${String(key)}". ` +
	                        `It will be overwritten with the new value.`);
	                }
	                context.provides[key] = value;
	                return app;
	            }
	        });
	        return app;
	    };
	}

	/**
	 * Function for handling a template ref
	 */
	function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
	    if (isArray(rawRef)) {
	        rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
	        return;
	    }
	    if (isAsyncWrapper(vnode) && !isUnmount) {
	        // when mounting async components, nothing needs to be done,
	        // because the template ref is forwarded to inner component
	        return;
	    }
	    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
	        ? getExposeProxy(vnode.component) || vnode.component.proxy
	        : vnode.el;
	    const value = isUnmount ? null : refValue;
	    const { i: owner, r: ref } = rawRef;
	    if (!owner) {
	        warn$1(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
	            `A vnode with ref must be created inside the render function.`);
	        return;
	    }
	    const oldRef = oldRawRef && oldRawRef.r;
	    const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
	    const setupState = owner.setupState;
	    // dynamic ref changed. unset old ref
	    if (oldRef != null && oldRef !== ref) {
	        if (isString(oldRef)) {
	            refs[oldRef] = null;
	            if (hasOwn(setupState, oldRef)) {
	                setupState[oldRef] = null;
	            }
	        }
	        else if (isRef(oldRef)) {
	            oldRef.value = null;
	        }
	    }
	    if (isFunction(ref)) {
	        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
	    }
	    else {
	        const _isString = isString(ref);
	        const _isRef = isRef(ref);
	        if (_isString || _isRef) {
	            const doSet = () => {
	                if (rawRef.f) {
	                    const existing = _isString ? refs[ref] : ref.value;
	                    if (isUnmount) {
	                        isArray(existing) && remove(existing, refValue);
	                    }
	                    else {
	                        if (!isArray(existing)) {
	                            if (_isString) {
	                                refs[ref] = [refValue];
	                                if (hasOwn(setupState, ref)) {
	                                    setupState[ref] = refs[ref];
	                                }
	                            }
	                            else {
	                                ref.value = [refValue];
	                                if (rawRef.k)
	                                    refs[rawRef.k] = ref.value;
	                            }
	                        }
	                        else if (!existing.includes(refValue)) {
	                            existing.push(refValue);
	                        }
	                    }
	                }
	                else if (_isString) {
	                    refs[ref] = value;
	                    if (hasOwn(setupState, ref)) {
	                        setupState[ref] = value;
	                    }
	                }
	                else if (_isRef) {
	                    ref.value = value;
	                    if (rawRef.k)
	                        refs[rawRef.k] = value;
	                }
	                else {
	                    warn$1('Invalid template ref type:', ref, `(${typeof ref})`);
	                }
	            };
	            if (value) {
	                doSet.id = -1;
	                queuePostRenderEffect(doSet, parentSuspense);
	            }
	            else {
	                doSet();
	            }
	        }
	        else {
	            warn$1('Invalid template ref type:', ref, `(${typeof ref})`);
	        }
	    }
	}

	let hasMismatch = false;
	const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
	const isComment = (node) => node.nodeType === 8 /* COMMENT */;
	// Note: hydration is DOM-specific
	// But we have to place it in core due to tight coupling with core - splitting
	// it out creates a ton of unnecessary complexity.
	// Hydration also depends on some renderer internal logic which needs to be
	// passed in via arguments.
	function createHydrationFunctions(rendererInternals) {
	    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
	    const hydrate = (vnode, container) => {
	        if (!container.hasChildNodes()) {
	            warn$1(`Attempting to hydrate existing markup but container is empty. ` +
	                    `Performing full mount instead.`);
	            patch(null, vnode, container);
	            flushPostFlushCbs();
	            container._vnode = vnode;
	            return;
	        }
	        hasMismatch = false;
	        hydrateNode(container.firstChild, vnode, null, null, null);
	        flushPostFlushCbs();
	        container._vnode = vnode;
	        if (hasMismatch && !false) {
	            // this error should show up in production
	            console.error(`Hydration completed but contains mismatches.`);
	        }
	    };
	    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
	        const isFragmentStart = isComment(node) && node.data === '[';
	        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
	        const { type, ref, shapeFlag, patchFlag } = vnode;
	        const domType = node.nodeType;
	        vnode.el = node;
	        if (patchFlag === -2 /* BAIL */) {
	            optimized = false;
	            vnode.dynamicChildren = null;
	        }
	        let nextNode = null;
	        switch (type) {
	            case Text:
	                if (domType !== 3 /* TEXT */) {
	                    // #5728 empty text node inside a slot can cause hydration failure
	                    // because the server rendered HTML won't contain a text node
	                    if (vnode.children === '') {
	                        insert((vnode.el = createText('')), parentNode(node), node);
	                        nextNode = node;
	                    }
	                    else {
	                        nextNode = onMismatch();
	                    }
	                }
	                else {
	                    if (node.data !== vnode.children) {
	                        hasMismatch = true;
	                        warn$1(`Hydration text mismatch:` +
	                                `\n- Client: ${JSON.stringify(node.data)}` +
	                                `\n- Server: ${JSON.stringify(vnode.children)}`);
	                        node.data = vnode.children;
	                    }
	                    nextNode = nextSibling(node);
	                }
	                break;
	            case Comment:
	                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
	                    nextNode = onMismatch();
	                }
	                else {
	                    nextNode = nextSibling(node);
	                }
	                break;
	            case Static:
	                if (domType !== 1 /* ELEMENT */ && domType !== 3 /* TEXT */) {
	                    nextNode = onMismatch();
	                }
	                else {
	                    // determine anchor, adopt content
	                    nextNode = node;
	                    // if the static vnode has its content stripped during build,
	                    // adopt it from the server-rendered HTML.
	                    const needToAdoptContent = !vnode.children.length;
	                    for (let i = 0; i < vnode.staticCount; i++) {
	                        if (needToAdoptContent)
	                            vnode.children +=
	                                nextNode.nodeType === 1 /* ELEMENT */
	                                    ? nextNode.outerHTML
	                                    : nextNode.data;
	                        if (i === vnode.staticCount - 1) {
	                            vnode.anchor = nextNode;
	                        }
	                        nextNode = nextSibling(nextNode);
	                    }
	                    return nextNode;
	                }
	                break;
	            case Fragment:
	                if (!isFragmentStart) {
	                    nextNode = onMismatch();
	                }
	                else {
	                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
	                }
	                break;
	            default:
	                if (shapeFlag & 1 /* ELEMENT */) {
	                    if (domType !== 1 /* ELEMENT */ ||
	                        vnode.type.toLowerCase() !==
	                            node.tagName.toLowerCase()) {
	                        nextNode = onMismatch();
	                    }
	                    else {
	                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
	                    }
	                }
	                else if (shapeFlag & 6 /* COMPONENT */) {
	                    // when setting up the render effect, if the initial vnode already
	                    // has .el set, the component will perform hydration instead of mount
	                    // on its sub-tree.
	                    vnode.slotScopeIds = slotScopeIds;
	                    const container = parentNode(node);
	                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
	                    // component may be async, so in the case of fragments we cannot rely
	                    // on component's rendered output to determine the end of the fragment
	                    // instead, we do a lookahead to find the end anchor node.
	                    nextNode = isFragmentStart
	                        ? locateClosingAsyncAnchor(node)
	                        : nextSibling(node);
	                    // #4293 teleport as component root
	                    if (nextNode &&
	                        isComment(nextNode) &&
	                        nextNode.data === 'teleport end') {
	                        nextNode = nextSibling(nextNode);
	                    }
	                    // #3787
	                    // if component is async, it may get moved / unmounted before its
	                    // inner component is loaded, so we need to give it a placeholder
	                    // vnode that matches its adopted DOM.
	                    if (isAsyncWrapper(vnode)) {
	                        let subTree;
	                        if (isFragmentStart) {
	                            subTree = createVNode(Fragment);
	                            subTree.anchor = nextNode
	                                ? nextNode.previousSibling
	                                : container.lastChild;
	                        }
	                        else {
	                            subTree =
	                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');
	                        }
	                        subTree.el = node;
	                        vnode.component.subTree = subTree;
	                    }
	                }
	                else if (shapeFlag & 64 /* TELEPORT */) {
	                    if (domType !== 8 /* COMMENT */) {
	                        nextNode = onMismatch();
	                    }
	                    else {
	                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
	                    }
	                }
	                else if (shapeFlag & 128 /* SUSPENSE */) {
	                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
	                }
	                else {
	                    warn$1('Invalid HostVNode type:', type, `(${typeof type})`);
	                }
	        }
	        if (ref != null) {
	            setRef(ref, null, parentSuspense, vnode);
	        }
	        return nextNode;
	    };
	    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
	        optimized = optimized || !!vnode.dynamicChildren;
	        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
	        // #4006 for form elements with non-string v-model value bindings
	        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
	        const forcePatchValue = (type === 'input' && dirs) || type === 'option';
	        // skip props & children if this is hoisted static nodes
	        // #5405 in dev, always hydrate children for HMR
	        {
	            if (dirs) {
	                invokeDirectiveHook(vnode, null, parentComponent, 'created');
	            }
	            // props
	            if (props) {
	                if (forcePatchValue ||
	                    !optimized ||
	                    patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {
	                    for (const key in props) {
	                        if ((forcePatchValue && key.endsWith('value')) ||
	                            (isOn(key) && !isReservedProp(key))) {
	                            patchProp(el, key, null, props[key], false, undefined, parentComponent);
	                        }
	                    }
	                }
	                else if (props.onClick) {
	                    // Fast path for click listeners (which is most often) to avoid
	                    // iterating through props.
	                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
	                }
	            }
	            // vnode / directive hooks
	            let vnodeHooks;
	            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
	                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
	            }
	            if (dirs) {
	                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
	            }
	            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
	                queueEffectWithSuspense(() => {
	                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
	                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
	                }, parentSuspense);
	            }
	            // children
	            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
	                // skip if element has innerHTML / textContent
	                !(props && (props.innerHTML || props.textContent))) {
	                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
	                let hasWarned = false;
	                while (next) {
	                    hasMismatch = true;
	                    if (!hasWarned) {
	                        warn$1(`Hydration children mismatch in <${vnode.type}>: ` +
	                            `server rendered element contains more child nodes than client vdom.`);
	                        hasWarned = true;
	                    }
	                    // The SSRed DOM contains more nodes than it should. Remove them.
	                    const cur = next;
	                    next = next.nextSibling;
	                    remove(cur);
	                }
	            }
	            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
	                if (el.textContent !== vnode.children) {
	                    hasMismatch = true;
	                    warn$1(`Hydration text content mismatch in <${vnode.type}>:\n` +
	                            `- Client: ${el.textContent}\n` +
	                            `- Server: ${vnode.children}`);
	                    el.textContent = vnode.children;
	                }
	            }
	        }
	        return el.nextSibling;
	    };
	    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
	        optimized = optimized || !!parentVNode.dynamicChildren;
	        const children = parentVNode.children;
	        const l = children.length;
	        let hasWarned = false;
	        for (let i = 0; i < l; i++) {
	            const vnode = optimized
	                ? children[i]
	                : (children[i] = normalizeVNode(children[i]));
	            if (node) {
	                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
	            }
	            else if (vnode.type === Text && !vnode.children) {
	                continue;
	            }
	            else {
	                hasMismatch = true;
	                if (!hasWarned) {
	                    warn$1(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
	                        `server rendered element contains fewer child nodes than client vdom.`);
	                    hasWarned = true;
	                }
	                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
	                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
	            }
	        }
	        return node;
	    };
	    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
	        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
	        if (fragmentSlotScopeIds) {
	            slotScopeIds = slotScopeIds
	                ? slotScopeIds.concat(fragmentSlotScopeIds)
	                : fragmentSlotScopeIds;
	        }
	        const container = parentNode(node);
	        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
	        if (next && isComment(next) && next.data === ']') {
	            return nextSibling((vnode.anchor = next));
	        }
	        else {
	            // fragment didn't hydrate successfully, since we didn't get a end anchor
	            // back. This should have led to node/children mismatch warnings.
	            hasMismatch = true;
	            // since the anchor is missing, we need to create one and insert it
	            insert((vnode.anchor = createComment(`]`)), container, next);
	            return next;
	        }
	    };
	    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
	        hasMismatch = true;
	        warn$1(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */
	                ? `(text)`
	                : isComment(node) && node.data === '['
	                    ? `(start of fragment)`
	                    : ``);
	        vnode.el = null;
	        if (isFragment) {
	            // remove excessive fragment nodes
	            const end = locateClosingAsyncAnchor(node);
	            while (true) {
	                const next = nextSibling(node);
	                if (next && next !== end) {
	                    remove(next);
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        const next = nextSibling(node);
	        const container = parentNode(node);
	        remove(node);
	        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
	        return next;
	    };
	    const locateClosingAsyncAnchor = (node) => {
	        let match = 0;
	        while (node) {
	            node = nextSibling(node);
	            if (node && isComment(node)) {
	                if (node.data === '[')
	                    match++;
	                if (node.data === ']') {
	                    if (match === 0) {
	                        return nextSibling(node);
	                    }
	                    else {
	                        match--;
	                    }
	                }
	            }
	        }
	        return node;
	    };
	    return [hydrate, hydrateNode];
	}

	/* eslint-disable no-restricted-globals */
	let supported;
	let perf;
	function startMeasure(instance, type) {
	    if (instance.appContext.config.performance && isSupported()) {
	        perf.mark(`vue-${type}-${instance.uid}`);
	    }
	    {
	        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
	    }
	}
	function endMeasure(instance, type) {
	    if (instance.appContext.config.performance && isSupported()) {
	        const startTag = `vue-${type}-${instance.uid}`;
	        const endTag = startTag + `:end`;
	        perf.mark(endTag);
	        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
	        perf.clearMarks(startTag);
	        perf.clearMarks(endTag);
	    }
	    {
	        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
	    }
	}
	function isSupported() {
	    if (supported !== undefined) {
	        return supported;
	    }
	    if (typeof window !== 'undefined' && window.performance) {
	        supported = true;
	        perf = window.performance;
	    }
	    else {
	        supported = false;
	    }
	    return supported;
	}

	const queuePostRenderEffect = queueEffectWithSuspense
	    ;
	/**
	 * The createRenderer function accepts two generic arguments:
	 * HostNode and HostElement, corresponding to Node and Element types in the
	 * host environment. For example, for runtime-dom, HostNode would be the DOM
	 * `Node` interface and HostElement would be the DOM `Element` interface.
	 *
	 * Custom renderers can pass in the platform specific types like this:
	 *
	 * ``` js
	 * const { render, createApp } = createRenderer<Node, Element>({
	 *   patchProp,
	 *   ...nodeOps
	 * })
	 * ```
	 */
	function createRenderer(options) {
	    return baseCreateRenderer(options);
	}
	// Separate API for creating hydration-enabled renderer.
	// Hydration logic is only used when calling this function, making it
	// tree-shakable.
	function createHydrationRenderer(options) {
	    return baseCreateRenderer(options, createHydrationFunctions);
	}
	// implementation
	function baseCreateRenderer(options, createHydrationFns) {
	    const target = getGlobalThis();
	    target.__VUE__ = true;
	    {
	        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
	    }
	    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
	    // Note: functions inside this closure should use `const xxx = () => {}`
	    // style in order to prevent being inlined by minifiers.
	    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
	        if (n1 === n2) {
	            return;
	        }
	        // patching & not same type, unmount old tree
	        if (n1 && !isSameVNodeType(n1, n2)) {
	            anchor = getNextHostNode(n1);
	            unmount(n1, parentComponent, parentSuspense, true);
	            n1 = null;
	        }
	        if (n2.patchFlag === -2 /* BAIL */) {
	            optimized = false;
	            n2.dynamicChildren = null;
	        }
	        const { type, ref, shapeFlag } = n2;
	        switch (type) {
	            case Text:
	                processText(n1, n2, container, anchor);
	                break;
	            case Comment:
	                processCommentNode(n1, n2, container, anchor);
	                break;
	            case Static:
	                if (n1 == null) {
	                    mountStaticNode(n2, container, anchor, isSVG);
	                }
	                else {
	                    patchStaticNode(n1, n2, container, isSVG);
	                }
	                break;
	            case Fragment:
	                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                break;
	            default:
	                if (shapeFlag & 1 /* ELEMENT */) {
	                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                }
	                else if (shapeFlag & 6 /* COMPONENT */) {
	                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                }
	                else if (shapeFlag & 64 /* TELEPORT */) {
	                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
	                }
	                else if (shapeFlag & 128 /* SUSPENSE */) {
	                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
	                }
	                else {
	                    warn$1('Invalid VNode type:', type, `(${typeof type})`);
	                }
	        }
	        // set ref
	        if (ref != null && parentComponent) {
	            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
	        }
	    };
	    const processText = (n1, n2, container, anchor) => {
	        if (n1 == null) {
	            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
	        }
	        else {
	            const el = (n2.el = n1.el);
	            if (n2.children !== n1.children) {
	                hostSetText(el, n2.children);
	            }
	        }
	    };
	    const processCommentNode = (n1, n2, container, anchor) => {
	        if (n1 == null) {
	            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
	        }
	        else {
	            // there's no support for dynamic comments
	            n2.el = n1.el;
	        }
	    };
	    const mountStaticNode = (n2, container, anchor, isSVG) => {
	        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
	    };
	    /**
	     * Dev / HMR only
	     */
	    const patchStaticNode = (n1, n2, container, isSVG) => {
	        // static nodes are only patched during dev for HMR
	        if (n2.children !== n1.children) {
	            const anchor = hostNextSibling(n1.anchor);
	            // remove existing
	            removeStaticNode(n1);
	            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
	        }
	        else {
	            n2.el = n1.el;
	            n2.anchor = n1.anchor;
	        }
	    };
	    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
	        let next;
	        while (el && el !== anchor) {
	            next = hostNextSibling(el);
	            hostInsert(el, container, nextSibling);
	            el = next;
	        }
	        hostInsert(anchor, container, nextSibling);
	    };
	    const removeStaticNode = ({ el, anchor }) => {
	        let next;
	        while (el && el !== anchor) {
	            next = hostNextSibling(el);
	            hostRemove(el);
	            el = next;
	        }
	        hostRemove(anchor);
	    };
	    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
	        isSVG = isSVG || n2.type === 'svg';
	        if (n1 == null) {
	            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	        }
	        else {
	            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	        }
	    };
	    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
	        let el;
	        let vnodeHook;
	        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
	        {
	            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
	            // mount children first, since some props may rely on child content
	            // being already rendered, e.g. `<select value>`
	            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
	                hostSetElementText(el, vnode.children);
	            }
	            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
	                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
	            }
	            if (dirs) {
	                invokeDirectiveHook(vnode, null, parentComponent, 'created');
	            }
	            // props
	            if (props) {
	                for (const key in props) {
	                    if (key !== 'value' && !isReservedProp(key)) {
	                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
	                    }
	                }
	                /**
	                 * Special case for setting value on DOM elements:
	                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
	                 * - it needs to be forced (#1471)
	                 * #2353 proposes adding another renderer option to configure this, but
	                 * the properties affects are so finite it is worth special casing it
	                 * here to reduce the complexity. (Special casing it also should not
	                 * affect non-DOM renderers)
	                 */
	                if ('value' in props) {
	                    hostPatchProp(el, 'value', null, props.value);
	                }
	                if ((vnodeHook = props.onVnodeBeforeMount)) {
	                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
	                }
	            }
	            // scopeId
	            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
	        }
	        {
	            Object.defineProperty(el, '__vnode', {
	                value: vnode,
	                enumerable: false
	            });
	            Object.defineProperty(el, '__vueParentComponent', {
	                value: parentComponent,
	                enumerable: false
	            });
	        }
	        if (dirs) {
	            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
	        }
	        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
	        // #1689 For inside suspense + suspense resolved case, just call it
	        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
	            transition &&
	            !transition.persisted;
	        if (needCallTransitionHooks) {
	            transition.beforeEnter(el);
	        }
	        hostInsert(el, container, anchor);
	        if ((vnodeHook = props && props.onVnodeMounted) ||
	            needCallTransitionHooks ||
	            dirs) {
	            queuePostRenderEffect(() => {
	                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
	                needCallTransitionHooks && transition.enter(el);
	                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
	            }, parentSuspense);
	        }
	    };
	    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
	        if (scopeId) {
	            hostSetScopeId(el, scopeId);
	        }
	        if (slotScopeIds) {
	            for (let i = 0; i < slotScopeIds.length; i++) {
	                hostSetScopeId(el, slotScopeIds[i]);
	            }
	        }
	        if (parentComponent) {
	            let subTree = parentComponent.subTree;
	            if (subTree.patchFlag > 0 &&
	                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
	                subTree =
	                    filterSingleRoot(subTree.children) || subTree;
	            }
	            if (vnode === subTree) {
	                const parentVNode = parentComponent.vnode;
	                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
	            }
	        }
	    };
	    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
	        for (let i = start; i < children.length; i++) {
	            const child = (children[i] = optimized
	                ? cloneIfMounted(children[i])
	                : normalizeVNode(children[i]));
	            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	        }
	    };
	    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
	        const el = (n2.el = n1.el);
	        let { patchFlag, dynamicChildren, dirs } = n2;
	        // #1426 take the old vnode's patch flag into account since user may clone a
	        // compiler-generated vnode, which de-opts to FULL_PROPS
	        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
	        const oldProps = n1.props || EMPTY_OBJ;
	        const newProps = n2.props || EMPTY_OBJ;
	        let vnodeHook;
	        // disable recurse in beforeUpdate hooks
	        parentComponent && toggleRecurse(parentComponent, false);
	        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
	            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
	        }
	        if (dirs) {
	            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
	        }
	        parentComponent && toggleRecurse(parentComponent, true);
	        if (isHmrUpdating) {
	            // HMR updated, force full diff
	            patchFlag = 0;
	            optimized = false;
	            dynamicChildren = null;
	        }
	        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
	        if (dynamicChildren) {
	            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
	            if (parentComponent && parentComponent.type.__hmrId) {
	                traverseStaticChildren(n1, n2);
	            }
	        }
	        else if (!optimized) {
	            // full diff
	            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
	        }
	        if (patchFlag > 0) {
	            // the presence of a patchFlag means this element's render code was
	            // generated by the compiler and can take the fast path.
	            // in this path old node and new node are guaranteed to have the same shape
	            // (i.e. at the exact same position in the source template)
	            if (patchFlag & 16 /* FULL_PROPS */) {
	                // element props contain dynamic keys, full diff needed
	                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
	            }
	            else {
	                // class
	                // this flag is matched when the element has dynamic class bindings.
	                if (patchFlag & 2 /* CLASS */) {
	                    if (oldProps.class !== newProps.class) {
	                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
	                    }
	                }
	                // style
	                // this flag is matched when the element has dynamic style bindings
	                if (patchFlag & 4 /* STYLE */) {
	                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
	                }
	                // props
	                // This flag is matched when the element has dynamic prop/attr bindings
	                // other than class and style. The keys of dynamic prop/attrs are saved for
	                // faster iteration.
	                // Note dynamic keys like :[foo]="bar" will cause this optimization to
	                // bail out and go through a full diff because we need to unset the old key
	                if (patchFlag & 8 /* PROPS */) {
	                    // if the flag is present then dynamicProps must be non-null
	                    const propsToUpdate = n2.dynamicProps;
	                    for (let i = 0; i < propsToUpdate.length; i++) {
	                        const key = propsToUpdate[i];
	                        const prev = oldProps[key];
	                        const next = newProps[key];
	                        // #1471 force patch value
	                        if (next !== prev || key === 'value') {
	                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
	                        }
	                    }
	                }
	            }
	            // text
	            // This flag is matched when the element has only dynamic text children.
	            if (patchFlag & 1 /* TEXT */) {
	                if (n1.children !== n2.children) {
	                    hostSetElementText(el, n2.children);
	                }
	            }
	        }
	        else if (!optimized && dynamicChildren == null) {
	            // unoptimized, full diff
	            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
	        }
	        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
	            queuePostRenderEffect(() => {
	                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
	                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
	            }, parentSuspense);
	        }
	    };
	    // The fast path for blocks.
	    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
	        for (let i = 0; i < newChildren.length; i++) {
	            const oldVNode = oldChildren[i];
	            const newVNode = newChildren[i];
	            // Determine the container (parent element) for the patch.
	            const container = 
	            // oldVNode may be an errored async setup() component inside Suspense
	            // which will not have a mounted element
	            oldVNode.el &&
	                // - In the case of a Fragment, we need to provide the actual parent
	                // of the Fragment itself so it can move its children.
	                (oldVNode.type === Fragment ||
	                    // - In the case of different nodes, there is going to be a replacement
	                    // which also requires the correct parent container
	                    !isSameVNodeType(oldVNode, newVNode) ||
	                    // - In the case of a component, it could contain anything.
	                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))
	                ? hostParentNode(oldVNode.el)
	                : // In other cases, the parent container is not actually used so we
	                    // just pass the block element here to avoid a DOM parentNode call.
	                    fallbackContainer;
	            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
	        }
	    };
	    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
	        if (oldProps !== newProps) {
	            for (const key in newProps) {
	                // empty string is not valid prop
	                if (isReservedProp(key))
	                    continue;
	                const next = newProps[key];
	                const prev = oldProps[key];
	                // defer patching value
	                if (next !== prev && key !== 'value') {
	                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
	                }
	            }
	            if (oldProps !== EMPTY_OBJ) {
	                for (const key in oldProps) {
	                    if (!isReservedProp(key) && !(key in newProps)) {
	                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
	                    }
	                }
	            }
	            if ('value' in newProps) {
	                hostPatchProp(el, 'value', oldProps.value, newProps.value);
	            }
	        }
	    };
	    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
	        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
	        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
	        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
	        if (// #5523 dev root fragment may inherit directives
	            (isHmrUpdating || patchFlag & 2048 /* DEV_ROOT_FRAGMENT */)) {
	            // HMR updated / Dev root fragment (w/ comments), force full diff
	            patchFlag = 0;
	            optimized = false;
	            dynamicChildren = null;
	        }
	        // check if this is a slot fragment with :slotted scope ids
	        if (fragmentSlotScopeIds) {
	            slotScopeIds = slotScopeIds
	                ? slotScopeIds.concat(fragmentSlotScopeIds)
	                : fragmentSlotScopeIds;
	        }
	        if (n1 == null) {
	            hostInsert(fragmentStartAnchor, container, anchor);
	            hostInsert(fragmentEndAnchor, container, anchor);
	            // a fragment can only have array children
	            // since they are either generated by the compiler, or implicitly created
	            // from arrays.
	            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	        }
	        else {
	            if (patchFlag > 0 &&
	                patchFlag & 64 /* STABLE_FRAGMENT */ &&
	                dynamicChildren &&
	                // #2715 the previous fragment could've been a BAILed one as a result
	                // of renderSlot() with no valid children
	                n1.dynamicChildren) {
	                // a stable fragment (template root or <template v-for>) doesn't need to
	                // patch children order, but it may contain dynamicChildren.
	                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
	                if (parentComponent && parentComponent.type.__hmrId) {
	                    traverseStaticChildren(n1, n2);
	                }
	                else if (
	                // #2080 if the stable fragment has a key, it's a <template v-for> that may
	                //  get moved around. Make sure all root level vnodes inherit el.
	                // #2134 or if it's a component root, it may also get moved around
	                // as the component is being moved.
	                n2.key != null ||
	                    (parentComponent && n2 === parentComponent.subTree)) {
	                    traverseStaticChildren(n1, n2, true /* shallow */);
	                }
	            }
	            else {
	                // keyed / unkeyed, or manual fragments.
	                // for keyed & unkeyed, since they are compiler generated from v-for,
	                // each child is guaranteed to be a block so the fragment will never
	                // have dynamicChildren.
	                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	            }
	        }
	    };
	    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
	        n2.slotScopeIds = slotScopeIds;
	        if (n1 == null) {
	            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
	                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
	            }
	            else {
	                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
	            }
	        }
	        else {
	            updateComponent(n1, n2, optimized);
	        }
	    };
	    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
	        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
	        if (instance.type.__hmrId) {
	            registerHMR(instance);
	        }
	        {
	            pushWarningContext(initialVNode);
	            startMeasure(instance, `mount`);
	        }
	        // inject renderer internals for keepAlive
	        if (isKeepAlive(initialVNode)) {
	            instance.ctx.renderer = internals;
	        }
	        // resolve props and slots for setup context
	        {
	            {
	                startMeasure(instance, `init`);
	            }
	            setupComponent(instance);
	            {
	                endMeasure(instance, `init`);
	            }
	        }
	        // setup() is async. This component relies on async logic to be resolved
	        // before proceeding
	        if (instance.asyncDep) {
	            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
	            // Give it a placeholder if this is not hydration
	            // TODO handle self-defined fallback
	            if (!initialVNode.el) {
	                const placeholder = (instance.subTree = createVNode(Comment));
	                processCommentNode(null, placeholder, container, anchor);
	            }
	            return;
	        }
	        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
	        {
	            popWarningContext();
	            endMeasure(instance, `mount`);
	        }
	    };
	    const updateComponent = (n1, n2, optimized) => {
	        const instance = (n2.component = n1.component);
	        if (shouldUpdateComponent(n1, n2, optimized)) {
	            if (instance.asyncDep &&
	                !instance.asyncResolved) {
	                // async & still pending - just update props and slots
	                // since the component's reactive effect for render isn't set-up yet
	                {
	                    pushWarningContext(n2);
	                }
	                updateComponentPreRender(instance, n2, optimized);
	                {
	                    popWarningContext();
	                }
	                return;
	            }
	            else {
	                // normal update
	                instance.next = n2;
	                // in case the child component is also queued, remove it to avoid
	                // double updating the same child component in the same flush.
	                invalidateJob(instance.update);
	                // instance.update is the reactive effect.
	                instance.update();
	            }
	        }
	        else {
	            // no update needed. just copy over properties
	            n2.el = n1.el;
	            instance.vnode = n2;
	        }
	    };
	    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
	        const componentUpdateFn = () => {
	            if (!instance.isMounted) {
	                let vnodeHook;
	                const { el, props } = initialVNode;
	                const { bm, m, parent } = instance;
	                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
	                toggleRecurse(instance, false);
	                // beforeMount hook
	                if (bm) {
	                    invokeArrayFns(bm);
	                }
	                // onVnodeBeforeMount
	                if (!isAsyncWrapperVNode &&
	                    (vnodeHook = props && props.onVnodeBeforeMount)) {
	                    invokeVNodeHook(vnodeHook, parent, initialVNode);
	                }
	                toggleRecurse(instance, true);
	                if (el && hydrateNode) {
	                    // vnode has adopted host node - perform hydration instead of mount.
	                    const hydrateSubTree = () => {
	                        {
	                            startMeasure(instance, `render`);
	                        }
	                        instance.subTree = renderComponentRoot(instance);
	                        {
	                            endMeasure(instance, `render`);
	                        }
	                        {
	                            startMeasure(instance, `hydrate`);
	                        }
	                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
	                        {
	                            endMeasure(instance, `hydrate`);
	                        }
	                    };
	                    if (isAsyncWrapperVNode) {
	                        initialVNode.type.__asyncLoader().then(
	                        // note: we are moving the render call into an async callback,
	                        // which means it won't track dependencies - but it's ok because
	                        // a server-rendered async wrapper is already in resolved state
	                        // and it will never need to change.
	                        () => !instance.isUnmounted && hydrateSubTree());
	                    }
	                    else {
	                        hydrateSubTree();
	                    }
	                }
	                else {
	                    {
	                        startMeasure(instance, `render`);
	                    }
	                    const subTree = (instance.subTree = renderComponentRoot(instance));
	                    {
	                        endMeasure(instance, `render`);
	                    }
	                    {
	                        startMeasure(instance, `patch`);
	                    }
	                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
	                    {
	                        endMeasure(instance, `patch`);
	                    }
	                    initialVNode.el = subTree.el;
	                }
	                // mounted hook
	                if (m) {
	                    queuePostRenderEffect(m, parentSuspense);
	                }
	                // onVnodeMounted
	                if (!isAsyncWrapperVNode &&
	                    (vnodeHook = props && props.onVnodeMounted)) {
	                    const scopedInitialVNode = initialVNode;
	                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
	                }
	                // activated hook for keep-alive roots.
	                // #1742 activated hook must be accessed after first render
	                // since the hook may be injected by a child keep-alive
	                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ||
	                    (parent &&
	                        isAsyncWrapper(parent.vnode) &&
	                        parent.vnode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */)) {
	                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
	                }
	                instance.isMounted = true;
	                {
	                    devtoolsComponentAdded(instance);
	                }
	                // #2458: deference mount-only object parameters to prevent memleaks
	                initialVNode = container = anchor = null;
	            }
	            else {
	                // updateComponent
	                // This is triggered by mutation of component's own state (next: null)
	                // OR parent calling processComponent (next: VNode)
	                let { next, bu, u, parent, vnode } = instance;
	                let originNext = next;
	                let vnodeHook;
	                {
	                    pushWarningContext(next || instance.vnode);
	                }
	                // Disallow component effect recursion during pre-lifecycle hooks.
	                toggleRecurse(instance, false);
	                if (next) {
	                    next.el = vnode.el;
	                    updateComponentPreRender(instance, next, optimized);
	                }
	                else {
	                    next = vnode;
	                }
	                // beforeUpdate hook
	                if (bu) {
	                    invokeArrayFns(bu);
	                }
	                // onVnodeBeforeUpdate
	                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
	                    invokeVNodeHook(vnodeHook, parent, next, vnode);
	                }
	                toggleRecurse(instance, true);
	                // render
	                {
	                    startMeasure(instance, `render`);
	                }
	                const nextTree = renderComponentRoot(instance);
	                {
	                    endMeasure(instance, `render`);
	                }
	                const prevTree = instance.subTree;
	                instance.subTree = nextTree;
	                {
	                    startMeasure(instance, `patch`);
	                }
	                patch(prevTree, nextTree, 
	                // parent may have changed if it's in a teleport
	                hostParentNode(prevTree.el), 
	                // anchor may have changed if it's in a fragment
	                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
	                {
	                    endMeasure(instance, `patch`);
	                }
	                next.el = nextTree.el;
	                if (originNext === null) {
	                    // self-triggered update. In case of HOC, update parent component
	                    // vnode el. HOC is indicated by parent instance's subTree pointing
	                    // to child component's vnode
	                    updateHOCHostEl(instance, nextTree.el);
	                }
	                // updated hook
	                if (u) {
	                    queuePostRenderEffect(u, parentSuspense);
	                }
	                // onVnodeUpdated
	                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
	                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
	                }
	                {
	                    devtoolsComponentUpdated(instance);
	                }
	                {
	                    popWarningContext();
	                }
	            }
	        };
	        // create reactive effect for rendering
	        const effect = (instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope
	        ));
	        const update = (instance.update = () => effect.run());
	        update.id = instance.uid;
	        // allowRecurse
	        // #1801, #2043 component render effects should allow recursive updates
	        toggleRecurse(instance, true);
	        {
	            effect.onTrack = instance.rtc
	                ? e => invokeArrayFns(instance.rtc, e)
	                : void 0;
	            effect.onTrigger = instance.rtg
	                ? e => invokeArrayFns(instance.rtg, e)
	                : void 0;
	            update.ownerInstance = instance;
	        }
	        update();
	    };
	    const updateComponentPreRender = (instance, nextVNode, optimized) => {
	        nextVNode.component = instance;
	        const prevProps = instance.vnode.props;
	        instance.vnode = nextVNode;
	        instance.next = null;
	        updateProps(instance, nextVNode.props, prevProps, optimized);
	        updateSlots(instance, nextVNode.children, optimized);
	        pauseTracking();
	        // props update may have triggered pre-flush watchers.
	        // flush them before the render update.
	        flushPreFlushCbs(undefined, instance.update);
	        resetTracking();
	    };
	    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
	        const c1 = n1 && n1.children;
	        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
	        const c2 = n2.children;
	        const { patchFlag, shapeFlag } = n2;
	        // fast path
	        if (patchFlag > 0) {
	            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
	                // this could be either fully-keyed or mixed (some keyed some not)
	                // presence of patchFlag means children are guaranteed to be arrays
	                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                return;
	            }
	            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
	                // unkeyed
	                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                return;
	            }
	        }
	        // children has 3 possibilities: text, array or no children.
	        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
	            // text children fast path
	            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
	                unmountChildren(c1, parentComponent, parentSuspense);
	            }
	            if (c2 !== c1) {
	                hostSetElementText(container, c2);
	            }
	        }
	        else {
	            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
	                // prev children was array
	                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
	                    // two arrays, cannot assume anything, do full diff
	                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                }
	                else {
	                    // no new children, just unmount old
	                    unmountChildren(c1, parentComponent, parentSuspense, true);
	                }
	            }
	            else {
	                // prev children was text OR null
	                // new children is array OR null
	                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
	                    hostSetElementText(container, '');
	                }
	                // mount new if array
	                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
	                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                }
	            }
	        }
	    };
	    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
	        c1 = c1 || EMPTY_ARR;
	        c2 = c2 || EMPTY_ARR;
	        const oldLength = c1.length;
	        const newLength = c2.length;
	        const commonLength = Math.min(oldLength, newLength);
	        let i;
	        for (i = 0; i < commonLength; i++) {
	            const nextChild = (c2[i] = optimized
	                ? cloneIfMounted(c2[i])
	                : normalizeVNode(c2[i]));
	            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	        }
	        if (oldLength > newLength) {
	            // remove old
	            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
	        }
	        else {
	            // mount new
	            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
	        }
	    };
	    // can be all-keyed or mixed
	    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
	        let i = 0;
	        const l2 = c2.length;
	        let e1 = c1.length - 1; // prev ending index
	        let e2 = l2 - 1; // next ending index
	        // 1. sync from start
	        // (a b) c
	        // (a b) d e
	        while (i <= e1 && i <= e2) {
	            const n1 = c1[i];
	            const n2 = (c2[i] = optimized
	                ? cloneIfMounted(c2[i])
	                : normalizeVNode(c2[i]));
	            if (isSameVNodeType(n1, n2)) {
	                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	            }
	            else {
	                break;
	            }
	            i++;
	        }
	        // 2. sync from end
	        // a (b c)
	        // d e (b c)
	        while (i <= e1 && i <= e2) {
	            const n1 = c1[e1];
	            const n2 = (c2[e2] = optimized
	                ? cloneIfMounted(c2[e2])
	                : normalizeVNode(c2[e2]));
	            if (isSameVNodeType(n1, n2)) {
	                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	            }
	            else {
	                break;
	            }
	            e1--;
	            e2--;
	        }
	        // 3. common sequence + mount
	        // (a b)
	        // (a b) c
	        // i = 2, e1 = 1, e2 = 2
	        // (a b)
	        // c (a b)
	        // i = 0, e1 = -1, e2 = 0
	        if (i > e1) {
	            if (i <= e2) {
	                const nextPos = e2 + 1;
	                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
	                while (i <= e2) {
	                    patch(null, (c2[i] = optimized
	                        ? cloneIfMounted(c2[i])
	                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                    i++;
	                }
	            }
	        }
	        // 4. common sequence + unmount
	        // (a b) c
	        // (a b)
	        // i = 2, e1 = 2, e2 = 1
	        // a (b c)
	        // (b c)
	        // i = 0, e1 = 0, e2 = -1
	        else if (i > e2) {
	            while (i <= e1) {
	                unmount(c1[i], parentComponent, parentSuspense, true);
	                i++;
	            }
	        }
	        // 5. unknown sequence
	        // [i ... e1 + 1]: a b [c d e] f g
	        // [i ... e2 + 1]: a b [e d c h] f g
	        // i = 2, e1 = 4, e2 = 5
	        else {
	            const s1 = i; // prev starting index
	            const s2 = i; // next starting index
	            // 5.1 build key:index map for newChildren
	            const keyToNewIndexMap = new Map();
	            for (i = s2; i <= e2; i++) {
	                const nextChild = (c2[i] = optimized
	                    ? cloneIfMounted(c2[i])
	                    : normalizeVNode(c2[i]));
	                if (nextChild.key != null) {
	                    if (keyToNewIndexMap.has(nextChild.key)) {
	                        warn$1(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
	                    }
	                    keyToNewIndexMap.set(nextChild.key, i);
	                }
	            }
	            // 5.2 loop through old children left to be patched and try to patch
	            // matching nodes & remove nodes that are no longer present
	            let j;
	            let patched = 0;
	            const toBePatched = e2 - s2 + 1;
	            let moved = false;
	            // used to track whether any node has moved
	            let maxNewIndexSoFar = 0;
	            // works as Map<newIndex, oldIndex>
	            // Note that oldIndex is offset by +1
	            // and oldIndex = 0 is a special value indicating the new node has
	            // no corresponding old node.
	            // used for determining longest stable subsequence
	            const newIndexToOldIndexMap = new Array(toBePatched);
	            for (i = 0; i < toBePatched; i++)
	                newIndexToOldIndexMap[i] = 0;
	            for (i = s1; i <= e1; i++) {
	                const prevChild = c1[i];
	                if (patched >= toBePatched) {
	                    // all new children have been patched so this can only be a removal
	                    unmount(prevChild, parentComponent, parentSuspense, true);
	                    continue;
	                }
	                let newIndex;
	                if (prevChild.key != null) {
	                    newIndex = keyToNewIndexMap.get(prevChild.key);
	                }
	                else {
	                    // key-less node, try to locate a key-less node of the same type
	                    for (j = s2; j <= e2; j++) {
	                        if (newIndexToOldIndexMap[j - s2] === 0 &&
	                            isSameVNodeType(prevChild, c2[j])) {
	                            newIndex = j;
	                            break;
	                        }
	                    }
	                }
	                if (newIndex === undefined) {
	                    unmount(prevChild, parentComponent, parentSuspense, true);
	                }
	                else {
	                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
	                    if (newIndex >= maxNewIndexSoFar) {
	                        maxNewIndexSoFar = newIndex;
	                    }
	                    else {
	                        moved = true;
	                    }
	                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                    patched++;
	                }
	            }
	            // 5.3 move and mount
	            // generate longest stable subsequence only when nodes have moved
	            const increasingNewIndexSequence = moved
	                ? getSequence(newIndexToOldIndexMap)
	                : EMPTY_ARR;
	            j = increasingNewIndexSequence.length - 1;
	            // looping backwards so that we can use last patched node as anchor
	            for (i = toBePatched - 1; i >= 0; i--) {
	                const nextIndex = s2 + i;
	                const nextChild = c2[nextIndex];
	                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
	                if (newIndexToOldIndexMap[i] === 0) {
	                    // mount new
	                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                }
	                else if (moved) {
	                    // move if:
	                    // There is no stable subsequence (e.g. a reverse)
	                    // OR current node is not among the stable sequence
	                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
	                        move(nextChild, container, anchor, 2 /* REORDER */);
	                    }
	                    else {
	                        j--;
	                    }
	                }
	            }
	        }
	    };
	    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
	        const { el, type, transition, children, shapeFlag } = vnode;
	        if (shapeFlag & 6 /* COMPONENT */) {
	            move(vnode.component.subTree, container, anchor, moveType);
	            return;
	        }
	        if (shapeFlag & 128 /* SUSPENSE */) {
	            vnode.suspense.move(container, anchor, moveType);
	            return;
	        }
	        if (shapeFlag & 64 /* TELEPORT */) {
	            type.move(vnode, container, anchor, internals);
	            return;
	        }
	        if (type === Fragment) {
	            hostInsert(el, container, anchor);
	            for (let i = 0; i < children.length; i++) {
	                move(children[i], container, anchor, moveType);
	            }
	            hostInsert(vnode.anchor, container, anchor);
	            return;
	        }
	        if (type === Static) {
	            moveStaticNode(vnode, container, anchor);
	            return;
	        }
	        // single nodes
	        const needTransition = moveType !== 2 /* REORDER */ &&
	            shapeFlag & 1 /* ELEMENT */ &&
	            transition;
	        if (needTransition) {
	            if (moveType === 0 /* ENTER */) {
	                transition.beforeEnter(el);
	                hostInsert(el, container, anchor);
	                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
	            }
	            else {
	                const { leave, delayLeave, afterLeave } = transition;
	                const remove = () => hostInsert(el, container, anchor);
	                const performLeave = () => {
	                    leave(el, () => {
	                        remove();
	                        afterLeave && afterLeave();
	                    });
	                };
	                if (delayLeave) {
	                    delayLeave(el, remove, performLeave);
	                }
	                else {
	                    performLeave();
	                }
	            }
	        }
	        else {
	            hostInsert(el, container, anchor);
	        }
	    };
	    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
	        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
	        // unset ref
	        if (ref != null) {
	            setRef(ref, null, parentSuspense, vnode, true);
	        }
	        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
	            parentComponent.ctx.deactivate(vnode);
	            return;
	        }
	        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
	        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
	        let vnodeHook;
	        if (shouldInvokeVnodeHook &&
	            (vnodeHook = props && props.onVnodeBeforeUnmount)) {
	            invokeVNodeHook(vnodeHook, parentComponent, vnode);
	        }
	        if (shapeFlag & 6 /* COMPONENT */) {
	            unmountComponent(vnode.component, parentSuspense, doRemove);
	        }
	        else {
	            if (shapeFlag & 128 /* SUSPENSE */) {
	                vnode.suspense.unmount(parentSuspense, doRemove);
	                return;
	            }
	            if (shouldInvokeDirs) {
	                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
	            }
	            if (shapeFlag & 64 /* TELEPORT */) {
	                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
	            }
	            else if (dynamicChildren &&
	                // #1153: fast path should not be taken for non-stable (v-for) fragments
	                (type !== Fragment ||
	                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
	                // fast path for block nodes: only need to unmount dynamic children.
	                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
	            }
	            else if ((type === Fragment &&
	                patchFlag &
	                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||
	                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
	                unmountChildren(children, parentComponent, parentSuspense);
	            }
	            if (doRemove) {
	                remove(vnode);
	            }
	        }
	        if ((shouldInvokeVnodeHook &&
	            (vnodeHook = props && props.onVnodeUnmounted)) ||
	            shouldInvokeDirs) {
	            queuePostRenderEffect(() => {
	                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
	                shouldInvokeDirs &&
	                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
	            }, parentSuspense);
	        }
	    };
	    const remove = vnode => {
	        const { type, el, anchor, transition } = vnode;
	        if (type === Fragment) {
	            if (vnode.patchFlag > 0 &&
	                vnode.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */ &&
	                transition &&
	                !transition.persisted) {
	                vnode.children.forEach(child => {
	                    if (child.type === Comment) {
	                        hostRemove(child.el);
	                    }
	                    else {
	                        remove(child);
	                    }
	                });
	            }
	            else {
	                removeFragment(el, anchor);
	            }
	            return;
	        }
	        if (type === Static) {
	            removeStaticNode(vnode);
	            return;
	        }
	        const performRemove = () => {
	            hostRemove(el);
	            if (transition && !transition.persisted && transition.afterLeave) {
	                transition.afterLeave();
	            }
	        };
	        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
	            transition &&
	            !transition.persisted) {
	            const { leave, delayLeave } = transition;
	            const performLeave = () => leave(el, performRemove);
	            if (delayLeave) {
	                delayLeave(vnode.el, performRemove, performLeave);
	            }
	            else {
	                performLeave();
	            }
	        }
	        else {
	            performRemove();
	        }
	    };
	    const removeFragment = (cur, end) => {
	        // For fragments, directly remove all contained DOM nodes.
	        // (fragment child nodes cannot have transition)
	        let next;
	        while (cur !== end) {
	            next = hostNextSibling(cur);
	            hostRemove(cur);
	            cur = next;
	        }
	        hostRemove(end);
	    };
	    const unmountComponent = (instance, parentSuspense, doRemove) => {
	        if (instance.type.__hmrId) {
	            unregisterHMR(instance);
	        }
	        const { bum, scope, update, subTree, um } = instance;
	        // beforeUnmount hook
	        if (bum) {
	            invokeArrayFns(bum);
	        }
	        // stop effects in component scope
	        scope.stop();
	        // update may be null if a component is unmounted before its async
	        // setup has resolved.
	        if (update) {
	            // so that scheduler will no longer invoke it
	            update.active = false;
	            unmount(subTree, instance, parentSuspense, doRemove);
	        }
	        // unmounted hook
	        if (um) {
	            queuePostRenderEffect(um, parentSuspense);
	        }
	        queuePostRenderEffect(() => {
	            instance.isUnmounted = true;
	        }, parentSuspense);
	        // A component with async dep inside a pending suspense is unmounted before
	        // its async dep resolves. This should remove the dep from the suspense, and
	        // cause the suspense to resolve immediately if that was the last dep.
	        if (parentSuspense &&
	            parentSuspense.pendingBranch &&
	            !parentSuspense.isUnmounted &&
	            instance.asyncDep &&
	            !instance.asyncResolved &&
	            instance.suspenseId === parentSuspense.pendingId) {
	            parentSuspense.deps--;
	            if (parentSuspense.deps === 0) {
	                parentSuspense.resolve();
	            }
	        }
	        {
	            devtoolsComponentRemoved(instance);
	        }
	    };
	    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
	        for (let i = start; i < children.length; i++) {
	            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
	        }
	    };
	    const getNextHostNode = vnode => {
	        if (vnode.shapeFlag & 6 /* COMPONENT */) {
	            return getNextHostNode(vnode.component.subTree);
	        }
	        if (vnode.shapeFlag & 128 /* SUSPENSE */) {
	            return vnode.suspense.next();
	        }
	        return hostNextSibling((vnode.anchor || vnode.el));
	    };
	    const render = (vnode, container, isSVG) => {
	        if (vnode == null) {
	            if (container._vnode) {
	                unmount(container._vnode, null, null, true);
	            }
	        }
	        else {
	            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
	        }
	        flushPostFlushCbs();
	        container._vnode = vnode;
	    };
	    const internals = {
	        p: patch,
	        um: unmount,
	        m: move,
	        r: remove,
	        mt: mountComponent,
	        mc: mountChildren,
	        pc: patchChildren,
	        pbc: patchBlockChildren,
	        n: getNextHostNode,
	        o: options
	    };
	    let hydrate;
	    let hydrateNode;
	    if (createHydrationFns) {
	        [hydrate, hydrateNode] = createHydrationFns(internals);
	    }
	    return {
	        render,
	        hydrate,
	        createApp: createAppAPI(render, hydrate)
	    };
	}
	function toggleRecurse({ effect, update }, allowed) {
	    effect.allowRecurse = update.allowRecurse = allowed;
	}
	/**
	 * #1156
	 * When a component is HMR-enabled, we need to make sure that all static nodes
	 * inside a block also inherit the DOM element from the previous tree so that
	 * HMR updates (which are full updates) can retrieve the element for patching.
	 *
	 * #2080
	 * Inside keyed `template` fragment static children, if a fragment is moved,
	 * the children will always be moved. Therefore, in order to ensure correct move
	 * position, el should be inherited from previous nodes.
	 */
	function traverseStaticChildren(n1, n2, shallow = false) {
	    const ch1 = n1.children;
	    const ch2 = n2.children;
	    if (isArray(ch1) && isArray(ch2)) {
	        for (let i = 0; i < ch1.length; i++) {
	            // this is only called in the optimized path so array children are
	            // guaranteed to be vnodes
	            const c1 = ch1[i];
	            let c2 = ch2[i];
	            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
	                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
	                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
	                    c2.el = c1.el;
	                }
	                if (!shallow)
	                    traverseStaticChildren(c1, c2);
	            }
	            // also inherit for comment nodes, but not placeholders (e.g. v-if which
	            // would have received .el during block patch)
	            if (c2.type === Comment && !c2.el) {
	                c2.el = c1.el;
	            }
	        }
	    }
	}
	// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
	function getSequence(arr) {
	    const p = arr.slice();
	    const result = [0];
	    let i, j, u, v, c;
	    const len = arr.length;
	    for (i = 0; i < len; i++) {
	        const arrI = arr[i];
	        if (arrI !== 0) {
	            j = result[result.length - 1];
	            if (arr[j] < arrI) {
	                p[i] = j;
	                result.push(i);
	                continue;
	            }
	            u = 0;
	            v = result.length - 1;
	            while (u < v) {
	                c = (u + v) >> 1;
	                if (arr[result[c]] < arrI) {
	                    u = c + 1;
	                }
	                else {
	                    v = c;
	                }
	            }
	            if (arrI < arr[result[u]]) {
	                if (u > 0) {
	                    p[i] = result[u - 1];
	                }
	                result[u] = i;
	            }
	        }
	    }
	    u = result.length;
	    v = result[u - 1];
	    while (u-- > 0) {
	        result[u] = v;
	        v = p[v];
	    }
	    return result;
	}

	const isTeleport = (type) => type.__isTeleport;
	const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
	const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
	const resolveTarget = (props, select) => {
	    const targetSelector = props && props.to;
	    if (isString(targetSelector)) {
	        if (!select) {
	            warn$1(`Current renderer does not support string target for Teleports. ` +
	                    `(missing querySelector renderer option)`);
	            return null;
	        }
	        else {
	            const target = select(targetSelector);
	            if (!target) {
	                warn$1(`Failed to locate Teleport target with selector "${targetSelector}". ` +
	                        `Note the target element must exist before the component is mounted - ` +
	                        `i.e. the target cannot be rendered by the component itself, and ` +
	                        `ideally should be outside of the entire Vue component tree.`);
	            }
	            return target;
	        }
	    }
	    else {
	        if (!targetSelector && !isTeleportDisabled(props)) {
	            warn$1(`Invalid Teleport target: ${targetSelector}`);
	        }
	        return targetSelector;
	    }
	};
	const TeleportImpl = {
	    __isTeleport: true,
	    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
	        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
	        const disabled = isTeleportDisabled(n2.props);
	        let { shapeFlag, children, dynamicChildren } = n2;
	        // #3302
	        // HMR updated, force full diff
	        if (isHmrUpdating) {
	            optimized = false;
	            dynamicChildren = null;
	        }
	        if (n1 == null) {
	            // insert anchors in the main view
	            const placeholder = (n2.el = createComment('teleport start')
	                );
	            const mainAnchor = (n2.anchor = createComment('teleport end')
	                );
	            insert(placeholder, container, anchor);
	            insert(mainAnchor, container, anchor);
	            const target = (n2.target = resolveTarget(n2.props, querySelector));
	            const targetAnchor = (n2.targetAnchor = createText(''));
	            if (target) {
	                insert(targetAnchor, target);
	                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
	                isSVG = isSVG || isTargetSVG(target);
	            }
	            else if (!disabled) {
	                warn$1('Invalid Teleport target on mount:', target, `(${typeof target})`);
	            }
	            const mount = (container, anchor) => {
	                // Teleport *always* has Array children. This is enforced in both the
	                // compiler and vnode children normalization.
	                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
	                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
	                }
	            };
	            if (disabled) {
	                mount(container, mainAnchor);
	            }
	            else if (target) {
	                mount(target, targetAnchor);
	            }
	        }
	        else {
	            // update content
	            n2.el = n1.el;
	            const mainAnchor = (n2.anchor = n1.anchor);
	            const target = (n2.target = n1.target);
	            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
	            const wasDisabled = isTeleportDisabled(n1.props);
	            const currentContainer = wasDisabled ? container : target;
	            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
	            isSVG = isSVG || isTargetSVG(target);
	            if (dynamicChildren) {
	                // fast path when the teleport happens to be a block root
	                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
	                // even in block tree mode we need to make sure all root-level nodes
	                // in the teleport inherit previous DOM references so that they can
	                // be moved in future patches.
	                traverseStaticChildren(n1, n2, true);
	            }
	            else if (!optimized) {
	                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
	            }
	            if (disabled) {
	                if (!wasDisabled) {
	                    // enabled -> disabled
	                    // move into main container
	                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
	                }
	            }
	            else {
	                // target changed
	                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
	                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
	                    if (nextTarget) {
	                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
	                    }
	                    else {
	                        warn$1('Invalid Teleport target on update:', target, `(${typeof target})`);
	                    }
	                }
	                else if (wasDisabled) {
	                    // disabled -> enabled
	                    // move into teleport target
	                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
	                }
	            }
	        }
	    },
	    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
	        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
	        if (target) {
	            hostRemove(targetAnchor);
	        }
	        // an unmounted teleport should always remove its children if not disabled
	        if (doRemove || !isTeleportDisabled(props)) {
	            hostRemove(anchor);
	            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
	                for (let i = 0; i < children.length; i++) {
	                    const child = children[i];
	                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
	                }
	            }
	        }
	    },
	    move: moveTeleport,
	    hydrate: hydrateTeleport
	};
	function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
	    // move target anchor if this is a target change.
	    if (moveType === 0 /* TARGET_CHANGE */) {
	        insert(vnode.targetAnchor, container, parentAnchor);
	    }
	    const { el, anchor, shapeFlag, children, props } = vnode;
	    const isReorder = moveType === 2 /* REORDER */;
	    // move main view anchor if this is a re-order.
	    if (isReorder) {
	        insert(el, container, parentAnchor);
	    }
	    // if this is a re-order and teleport is enabled (content is in target)
	    // do not move children. So the opposite is: only move children if this
	    // is not a reorder, or the teleport is disabled
	    if (!isReorder || isTeleportDisabled(props)) {
	        // Teleport has either Array children or no children.
	        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
	            for (let i = 0; i < children.length; i++) {
	                move(children[i], container, parentAnchor, 2 /* REORDER */);
	            }
	        }
	    }
	    // move main view anchor if this is a re-order.
	    if (isReorder) {
	        insert(anchor, container, parentAnchor);
	    }
	}
	function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
	    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
	    if (target) {
	        // if multiple teleports rendered to the same target element, we need to
	        // pick up from where the last teleport finished instead of the first node
	        const targetNode = target._lpa || target.firstChild;
	        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
	            if (isTeleportDisabled(vnode.props)) {
	                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
	                vnode.targetAnchor = targetNode;
	            }
	            else {
	                vnode.anchor = nextSibling(node);
	                // lookahead until we find the target anchor
	                // we cannot rely on return value of hydrateChildren() because there
	                // could be nested teleports
	                let targetAnchor = targetNode;
	                while (targetAnchor) {
	                    targetAnchor = nextSibling(targetAnchor);
	                    if (targetAnchor &&
	                        targetAnchor.nodeType === 8 &&
	                        targetAnchor.data === 'teleport anchor') {
	                        vnode.targetAnchor = targetAnchor;
	                        target._lpa =
	                            vnode.targetAnchor && nextSibling(vnode.targetAnchor);
	                        break;
	                    }
	                }
	                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
	            }
	        }
	    }
	    return vnode.anchor && nextSibling(vnode.anchor);
	}
	// Force-casted public typing for h and TSX props inference
	const Teleport = TeleportImpl;

	const Fragment = Symbol('Fragment' );
	const Text = Symbol('Text' );
	const Comment = Symbol('Comment' );
	const Static = Symbol('Static' );
	// Since v-if and v-for are the two possible ways node structure can dynamically
	// change, once we consider v-if branches and each v-for fragment a block, we
	// can divide a template into nested blocks, and within each block the node
	// structure would be stable. This allows us to skip most children diffing
	// and only worry about the dynamic nodes (indicated by patch flags).
	const blockStack = [];
	let currentBlock = null;
	/**
	 * Open a block.
	 * This must be called before `createBlock`. It cannot be part of `createBlock`
	 * because the children of the block are evaluated before `createBlock` itself
	 * is called. The generated code typically looks like this:
	 *
	 * ```js
	 * function render() {
	 *   return (openBlock(),createBlock('div', null, [...]))
	 * }
	 * ```
	 * disableTracking is true when creating a v-for fragment block, since a v-for
	 * fragment always diffs its children.
	 *
	 * @private
	 */
	function openBlock(disableTracking = false) {
	    blockStack.push((currentBlock = disableTracking ? null : []));
	}
	function closeBlock() {
	    blockStack.pop();
	    currentBlock = blockStack[blockStack.length - 1] || null;
	}
	// Whether we should be tracking dynamic child nodes inside a block.
	// Only tracks when this value is > 0
	// We are not using a simple boolean because this value may need to be
	// incremented/decremented by nested usage of v-once (see below)
	let isBlockTreeEnabled = 1;
	/**
	 * Block tracking sometimes needs to be disabled, for example during the
	 * creation of a tree that needs to be cached by v-once. The compiler generates
	 * code like this:
	 *
	 * ``` js
	 * _cache[1] || (
	 *   setBlockTracking(-1),
	 *   _cache[1] = createVNode(...),
	 *   setBlockTracking(1),
	 *   _cache[1]
	 * )
	 * ```
	 *
	 * @private
	 */
	function setBlockTracking(value) {
	    isBlockTreeEnabled += value;
	}
	function setupBlock(vnode) {
	    // save current block children on the block vnode
	    vnode.dynamicChildren =
	        isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
	    // close block
	    closeBlock();
	    // a block is always going to be patched, so track it as a child of its
	    // parent block
	    if (isBlockTreeEnabled > 0 && currentBlock) {
	        currentBlock.push(vnode);
	    }
	    return vnode;
	}
	/**
	 * @private
	 */
	function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
	    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));
	}
	/**
	 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
	 * A block root keeps track of dynamic nodes within the block in the
	 * `dynamicChildren` array.
	 *
	 * @private
	 */
	function createBlock(type, props, children, patchFlag, dynamicProps) {
	    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));
	}
	function isVNode(value) {
	    return value ? value.__v_isVNode === true : false;
	}
	function isSameVNodeType(n1, n2) {
	    if (n2.shapeFlag & 6 /* COMPONENT */ &&
	        hmrDirtyComponents.has(n2.type)) {
	        // HMR only: if the component has been hot-updated, force a reload.
	        return false;
	    }
	    return n1.type === n2.type && n1.key === n2.key;
	}
	let vnodeArgsTransformer;
	/**
	 * Internal API for registering an arguments transform for createVNode
	 * used for creating stubs in the test-utils
	 * It is *internal* but needs to be exposed for test-utils to pick up proper
	 * typings
	 */
	function transformVNodeArgs(transformer) {
	    vnodeArgsTransformer = transformer;
	}
	const createVNodeWithArgsTransform = (...args) => {
	    return _createVNode(...(vnodeArgsTransformer
	        ? vnodeArgsTransformer(args, currentRenderingInstance)
	        : args));
	};
	const InternalObjectKey = `__vInternal`;
	const normalizeKey = ({ key }) => key != null ? key : null;
	const normalizeRef = ({ ref, ref_key, ref_for }) => {
	    return (ref != null
	        ? isString(ref) || isRef(ref) || isFunction(ref)
	            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }
	            : ref
	        : null);
	};
	function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
	    const vnode = {
	        __v_isVNode: true,
	        __v_skip: true,
	        type,
	        props,
	        key: props && normalizeKey(props),
	        ref: props && normalizeRef(props),
	        scopeId: currentScopeId,
	        slotScopeIds: null,
	        children,
	        component: null,
	        suspense: null,
	        ssContent: null,
	        ssFallback: null,
	        dirs: null,
	        transition: null,
	        el: null,
	        anchor: null,
	        target: null,
	        targetAnchor: null,
	        staticCount: 0,
	        shapeFlag,
	        patchFlag,
	        dynamicProps,
	        dynamicChildren: null,
	        appContext: null
	    };
	    if (needFullChildrenNormalization) {
	        normalizeChildren(vnode, children);
	        // normalize suspense children
	        if (shapeFlag & 128 /* SUSPENSE */) {
	            type.normalize(vnode);
	        }
	    }
	    else if (children) {
	        // compiled element vnode - if children is passed, only possible types are
	        // string or Array.
	        vnode.shapeFlag |= isString(children)
	            ? 8 /* TEXT_CHILDREN */
	            : 16 /* ARRAY_CHILDREN */;
	    }
	    // validate key
	    if (vnode.key !== vnode.key) {
	        warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
	    }
	    // track vnode for block tree
	    if (isBlockTreeEnabled > 0 &&
	        // avoid a block node from tracking itself
	        !isBlockNode &&
	        // has current parent block
	        currentBlock &&
	        // presence of a patch flag indicates this node needs patching on updates.
	        // component nodes also should always be patched, because even if the
	        // component doesn't need to update, it needs to persist the instance on to
	        // the next vnode so that it can be properly unmounted later.
	        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
	        // the EVENTS flag is only for hydration and if it is the only flag, the
	        // vnode should not be considered dynamic due to handler caching.
	        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {
	        currentBlock.push(vnode);
	    }
	    return vnode;
	}
	const createVNode = (createVNodeWithArgsTransform );
	function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
	    if (!type || type === NULL_DYNAMIC_COMPONENT) {
	        if (!type) {
	            warn$1(`Invalid vnode type when creating vnode: ${type}.`);
	        }
	        type = Comment;
	    }
	    if (isVNode(type)) {
	        // createVNode receiving an existing vnode. This happens in cases like
	        // <component :is="vnode"/>
	        // #2078 make sure to merge refs during the clone instead of overwriting it
	        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
	        if (children) {
	            normalizeChildren(cloned, children);
	        }
	        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
	            if (cloned.shapeFlag & 6 /* COMPONENT */) {
	                currentBlock[currentBlock.indexOf(type)] = cloned;
	            }
	            else {
	                currentBlock.push(cloned);
	            }
	        }
	        cloned.patchFlag |= -2 /* BAIL */;
	        return cloned;
	    }
	    // class component normalization.
	    if (isClassComponent(type)) {
	        type = type.__vccOpts;
	    }
	    // class & style normalization.
	    if (props) {
	        // for reactive or proxy objects, we need to clone it to enable mutation.
	        props = guardReactiveProps(props);
	        let { class: klass, style } = props;
	        if (klass && !isString(klass)) {
	            props.class = normalizeClass(klass);
	        }
	        if (isObject(style)) {
	            // reactive state objects need to be cloned since they are likely to be
	            // mutated
	            if (isProxy(style) && !isArray(style)) {
	                style = extend({}, style);
	            }
	            props.style = normalizeStyle(style);
	        }
	    }
	    // encode the vnode type information into a bitmap
	    const shapeFlag = isString(type)
	        ? 1 /* ELEMENT */
	        : isSuspense(type)
	            ? 128 /* SUSPENSE */
	            : isTeleport(type)
	                ? 64 /* TELEPORT */
	                : isObject(type)
	                    ? 4 /* STATEFUL_COMPONENT */
	                    : isFunction(type)
	                        ? 2 /* FUNCTIONAL_COMPONENT */
	                        : 0;
	    if (shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {
	        type = toRaw(type);
	        warn$1(`Vue received a Component which was made a reactive object. This can ` +
	            `lead to unnecessary performance overhead, and should be avoided by ` +
	            `marking the component with \`markRaw\` or using \`shallowRef\` ` +
	            `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
	    }
	    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
	}
	function guardReactiveProps(props) {
	    if (!props)
	        return null;
	    return isProxy(props) || InternalObjectKey in props
	        ? extend({}, props)
	        : props;
	}
	function cloneVNode(vnode, extraProps, mergeRef = false) {
	    // This is intentionally NOT using spread or extend to avoid the runtime
	    // key enumeration cost.
	    const { props, ref, patchFlag, children } = vnode;
	    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
	    const cloned = {
	        __v_isVNode: true,
	        __v_skip: true,
	        type: vnode.type,
	        props: mergedProps,
	        key: mergedProps && normalizeKey(mergedProps),
	        ref: extraProps && extraProps.ref
	            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
	                // if the vnode itself already has a ref, cloneVNode will need to merge
	                // the refs so the single vnode can be set on multiple refs
	                mergeRef && ref
	                    ? isArray(ref)
	                        ? ref.concat(normalizeRef(extraProps))
	                        : [ref, normalizeRef(extraProps)]
	                    : normalizeRef(extraProps)
	            : ref,
	        scopeId: vnode.scopeId,
	        slotScopeIds: vnode.slotScopeIds,
	        children: patchFlag === -1 /* HOISTED */ && isArray(children)
	            ? children.map(deepCloneVNode)
	            : children,
	        target: vnode.target,
	        targetAnchor: vnode.targetAnchor,
	        staticCount: vnode.staticCount,
	        shapeFlag: vnode.shapeFlag,
	        // if the vnode is cloned with extra props, we can no longer assume its
	        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
	        // note: preserve flag for fragments since they use the flag for children
	        // fast paths only.
	        patchFlag: extraProps && vnode.type !== Fragment
	            ? patchFlag === -1 // hoisted node
	                ? 16 /* FULL_PROPS */
	                : patchFlag | 16 /* FULL_PROPS */
	            : patchFlag,
	        dynamicProps: vnode.dynamicProps,
	        dynamicChildren: vnode.dynamicChildren,
	        appContext: vnode.appContext,
	        dirs: vnode.dirs,
	        transition: vnode.transition,
	        // These should technically only be non-null on mounted VNodes. However,
	        // they *should* be copied for kept-alive vnodes. So we just always copy
	        // them since them being non-null during a mount doesn't affect the logic as
	        // they will simply be overwritten.
	        component: vnode.component,
	        suspense: vnode.suspense,
	        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
	        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
	        el: vnode.el,
	        anchor: vnode.anchor
	    };
	    return cloned;
	}
	/**
	 * Dev only, for HMR of hoisted vnodes reused in v-for
	 * https://github.com/vitejs/vite/issues/2022
	 */
	function deepCloneVNode(vnode) {
	    const cloned = cloneVNode(vnode);
	    if (isArray(vnode.children)) {
	        cloned.children = vnode.children.map(deepCloneVNode);
	    }
	    return cloned;
	}
	/**
	 * @private
	 */
	function createTextVNode(text = ' ', flag = 0) {
	    return createVNode(Text, null, text, flag);
	}
	/**
	 * @private
	 */
	function createStaticVNode(content, numberOfNodes) {
	    // A static vnode can contain multiple stringified elements, and the number
	    // of elements is necessary for hydration.
	    const vnode = createVNode(Static, null, content);
	    vnode.staticCount = numberOfNodes;
	    return vnode;
	}
	/**
	 * @private
	 */
	function createCommentVNode(text = '', 
	// when used as the v-else branch, the comment node must be created as a
	// block to ensure correct updates.
	asBlock = false) {
	    return asBlock
	        ? (openBlock(), createBlock(Comment, null, text))
	        : createVNode(Comment, null, text);
	}
	function normalizeVNode(child) {
	    if (child == null || typeof child === 'boolean') {
	        // empty placeholder
	        return createVNode(Comment);
	    }
	    else if (isArray(child)) {
	        // fragment
	        return createVNode(Fragment, null, 
	        // #3666, avoid reference pollution when reusing vnode
	        child.slice());
	    }
	    else if (typeof child === 'object') {
	        // already vnode, this should be the most common since compiled templates
	        // always produce all-vnode children arrays
	        return cloneIfMounted(child);
	    }
	    else {
	        // strings and numbers
	        return createVNode(Text, null, String(child));
	    }
	}
	// optimized normalization for template-compiled render fns
	function cloneIfMounted(child) {
	    return child.el === null || child.memo ? child : cloneVNode(child);
	}
	function normalizeChildren(vnode, children) {
	    let type = 0;
	    const { shapeFlag } = vnode;
	    if (children == null) {
	        children = null;
	    }
	    else if (isArray(children)) {
	        type = 16 /* ARRAY_CHILDREN */;
	    }
	    else if (typeof children === 'object') {
	        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {
	            // Normalize slot to plain children for plain element and Teleport
	            const slot = children.default;
	            if (slot) {
	                // _c marker is added by withCtx() indicating this is a compiled slot
	                slot._c && (slot._d = false);
	                normalizeChildren(vnode, slot());
	                slot._c && (slot._d = true);
	            }
	            return;
	        }
	        else {
	            type = 32 /* SLOTS_CHILDREN */;
	            const slotFlag = children._;
	            if (!slotFlag && !(InternalObjectKey in children)) {
	                children._ctx = currentRenderingInstance;
	            }
	            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
	                // a child component receives forwarded slots from the parent.
	                // its slot type is determined by its parent's slot type.
	                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
	                    children._ = 1 /* STABLE */;
	                }
	                else {
	                    children._ = 2 /* DYNAMIC */;
	                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
	                }
	            }
	        }
	    }
	    else if (isFunction(children)) {
	        children = { default: children, _ctx: currentRenderingInstance };
	        type = 32 /* SLOTS_CHILDREN */;
	    }
	    else {
	        children = String(children);
	        // force teleport children to array so it can be moved around
	        if (shapeFlag & 64 /* TELEPORT */) {
	            type = 16 /* ARRAY_CHILDREN */;
	            children = [createTextVNode(children)];
	        }
	        else {
	            type = 8 /* TEXT_CHILDREN */;
	        }
	    }
	    vnode.children = children;
	    vnode.shapeFlag |= type;
	}
	function mergeProps(...args) {
	    const ret = {};
	    for (let i = 0; i < args.length; i++) {
	        const toMerge = args[i];
	        for (const key in toMerge) {
	            if (key === 'class') {
	                if (ret.class !== toMerge.class) {
	                    ret.class = normalizeClass([ret.class, toMerge.class]);
	                }
	            }
	            else if (key === 'style') {
	                ret.style = normalizeStyle([ret.style, toMerge.style]);
	            }
	            else if (isOn(key)) {
	                const existing = ret[key];
	                const incoming = toMerge[key];
	                if (incoming &&
	                    existing !== incoming &&
	                    !(isArray(existing) && existing.includes(incoming))) {
	                    ret[key] = existing
	                        ? [].concat(existing, incoming)
	                        : incoming;
	                }
	            }
	            else if (key !== '') {
	                ret[key] = toMerge[key];
	            }
	        }
	    }
	    return ret;
	}
	function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
	    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
	        vnode,
	        prevVNode
	    ]);
	}

	const emptyAppContext = createAppContext();
	let uid$1 = 0;
	function createComponentInstance(vnode, parent, suspense) {
	    const type = vnode.type;
	    // inherit parent app context - or - if root, adopt from root vnode
	    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
	    const instance = {
	        uid: uid$1++,
	        vnode,
	        type,
	        parent,
	        appContext,
	        root: null,
	        next: null,
	        subTree: null,
	        effect: null,
	        update: null,
	        scope: new EffectScope(true /* detached */),
	        render: null,
	        proxy: null,
	        exposed: null,
	        exposeProxy: null,
	        withProxy: null,
	        provides: parent ? parent.provides : Object.create(appContext.provides),
	        accessCache: null,
	        renderCache: [],
	        // local resolved assets
	        components: null,
	        directives: null,
	        // resolved props and emits options
	        propsOptions: normalizePropsOptions(type, appContext),
	        emitsOptions: normalizeEmitsOptions(type, appContext),
	        // emit
	        emit: null,
	        emitted: null,
	        // props default value
	        propsDefaults: EMPTY_OBJ,
	        // inheritAttrs
	        inheritAttrs: type.inheritAttrs,
	        // state
	        ctx: EMPTY_OBJ,
	        data: EMPTY_OBJ,
	        props: EMPTY_OBJ,
	        attrs: EMPTY_OBJ,
	        slots: EMPTY_OBJ,
	        refs: EMPTY_OBJ,
	        setupState: EMPTY_OBJ,
	        setupContext: null,
	        // suspense related
	        suspense,
	        suspenseId: suspense ? suspense.pendingId : 0,
	        asyncDep: null,
	        asyncResolved: false,
	        // lifecycle hooks
	        // not using enums here because it results in computed properties
	        isMounted: false,
	        isUnmounted: false,
	        isDeactivated: false,
	        bc: null,
	        c: null,
	        bm: null,
	        m: null,
	        bu: null,
	        u: null,
	        um: null,
	        bum: null,
	        da: null,
	        a: null,
	        rtg: null,
	        rtc: null,
	        ec: null,
	        sp: null
	    };
	    {
	        instance.ctx = createDevRenderContext(instance);
	    }
	    instance.root = parent ? parent.root : instance;
	    instance.emit = emit$1.bind(null, instance);
	    // apply custom element special handling
	    if (vnode.ce) {
	        vnode.ce(instance);
	    }
	    return instance;
	}
	let currentInstance = null;
	const getCurrentInstance = () => currentInstance || currentRenderingInstance;
	const setCurrentInstance = (instance) => {
	    currentInstance = instance;
	    instance.scope.on();
	};
	const unsetCurrentInstance = () => {
	    currentInstance && currentInstance.scope.off();
	    currentInstance = null;
	};
	const isBuiltInTag = /*#__PURE__*/ makeMap('slot,component');
	function validateComponentName(name, config) {
	    const appIsNativeTag = config.isNativeTag || NO;
	    if (isBuiltInTag(name) || appIsNativeTag(name)) {
	        warn$1('Do not use built-in or reserved HTML elements as component id: ' + name);
	    }
	}
	function isStatefulComponent(instance) {
	    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
	}
	let isInSSRComponentSetup = false;
	function setupComponent(instance, isSSR = false) {
	    isInSSRComponentSetup = isSSR;
	    const { props, children } = instance.vnode;
	    const isStateful = isStatefulComponent(instance);
	    initProps(instance, props, isStateful, isSSR);
	    initSlots(instance, children);
	    const setupResult = isStateful
	        ? setupStatefulComponent(instance, isSSR)
	        : undefined;
	    isInSSRComponentSetup = false;
	    return setupResult;
	}
	function setupStatefulComponent(instance, isSSR) {
	    var _a;
	    const Component = instance.type;
	    {
	        if (Component.name) {
	            validateComponentName(Component.name, instance.appContext.config);
	        }
	        if (Component.components) {
	            const names = Object.keys(Component.components);
	            for (let i = 0; i < names.length; i++) {
	                validateComponentName(names[i], instance.appContext.config);
	            }
	        }
	        if (Component.directives) {
	            const names = Object.keys(Component.directives);
	            for (let i = 0; i < names.length; i++) {
	                validateDirectiveName(names[i]);
	            }
	        }
	        if (Component.compilerOptions && isRuntimeOnly()) {
	            warn$1(`"compilerOptions" is only supported when using a build of Vue that ` +
	                `includes the runtime compiler. Since you are using a runtime-only ` +
	                `build, the options should be passed via your build tool config instead.`);
	        }
	    }
	    // 0. create render proxy property access cache
	    instance.accessCache = Object.create(null);
	    // 1. create public instance / render proxy
	    // also mark it raw so it's never observed
	    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
	    {
	        exposePropsOnRenderContext(instance);
	    }
	    // 2. call setup()
	    const { setup } = Component;
	    if (setup) {
	        const setupContext = (instance.setupContext =
	            setup.length > 1 ? createSetupContext(instance) : null);
	        setCurrentInstance(instance);
	        pauseTracking();
	        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [shallowReadonly(instance.props) , setupContext]);
	        resetTracking();
	        unsetCurrentInstance();
	        if (isPromise(setupResult)) {
	            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
	            if (isSSR) {
	                // return the promise so server-renderer can wait on it
	                return setupResult
	                    .then((resolvedResult) => {
	                    handleSetupResult(instance, resolvedResult, isSSR);
	                })
	                    .catch(e => {
	                    handleError(e, instance, 0 /* SETUP_FUNCTION */);
	                });
	            }
	            else {
	                // async setup returned Promise.
	                // bail here and wait for re-entry.
	                instance.asyncDep = setupResult;
	                if (!instance.suspense) {
	                    const name = (_a = Component.name) !== null && _a !== void 0 ? _a : 'Anonymous';
	                    warn$1(`Component <${name}>: setup function returned a promise, but no ` +
	                        `<Suspense> boundary was found in the parent component tree. ` +
	                        `A component with async setup() must be nested in a <Suspense> ` +
	                        `in order to be rendered.`);
	                }
	            }
	        }
	        else {
	            handleSetupResult(instance, setupResult, isSSR);
	        }
	    }
	    else {
	        finishComponentSetup(instance, isSSR);
	    }
	}
	function handleSetupResult(instance, setupResult, isSSR) {
	    if (isFunction(setupResult)) {
	        // setup returned an inline render function
	        {
	            instance.render = setupResult;
	        }
	    }
	    else if (isObject(setupResult)) {
	        if (isVNode(setupResult)) {
	            warn$1(`setup() should not return VNodes directly - ` +
	                `return a render function instead.`);
	        }
	        // setup returned bindings.
	        // assuming a render function compiled from template is present.
	        {
	            instance.devtoolsRawSetupState = setupResult;
	        }
	        instance.setupState = proxyRefs(setupResult);
	        {
	            exposeSetupStateOnRenderContext(instance);
	        }
	    }
	    else if (setupResult !== undefined) {
	        warn$1(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
	    }
	    finishComponentSetup(instance, isSSR);
	}
	let compile;
	let installWithProxy;
	/**
	 * For runtime-dom to register the compiler.
	 * Note the exported method uses any to avoid d.ts relying on the compiler types.
	 */
	function registerRuntimeCompiler(_compile) {
	    compile = _compile;
	    installWithProxy = i => {
	        if (i.render._rc) {
	            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
	        }
	    };
	}
	// dev only
	const isRuntimeOnly = () => !compile;
	function finishComponentSetup(instance, isSSR, skipOptions) {
	    const Component = instance.type;
	    // template / render function normalization
	    // could be already set when returned from setup()
	    if (!instance.render) {
	        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
	        // is done by server-renderer
	        if (!isSSR && compile && !Component.render) {
	            const template = Component.template;
	            if (template) {
	                {
	                    startMeasure(instance, `compile`);
	                }
	                const { isCustomElement, compilerOptions } = instance.appContext.config;
	                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
	                const finalCompilerOptions = extend(extend({
	                    isCustomElement,
	                    delimiters
	                }, compilerOptions), componentCompilerOptions);
	                Component.render = compile(template, finalCompilerOptions);
	                {
	                    endMeasure(instance, `compile`);
	                }
	            }
	        }
	        instance.render = (Component.render || NOOP);
	        // for runtime-compiled render functions using `with` blocks, the render
	        // proxy used needs a different `has` handler which is more performant and
	        // also only allows a whitelist of globals to fallthrough.
	        if (installWithProxy) {
	            installWithProxy(instance);
	        }
	    }
	    // support for 2.x options
	    {
	        setCurrentInstance(instance);
	        pauseTracking();
	        applyOptions(instance);
	        resetTracking();
	        unsetCurrentInstance();
	    }
	    // warn missing template/render
	    // the runtime compilation of template in SSR is done by server-render
	    if (!Component.render && instance.render === NOOP && !isSSR) {
	        /* istanbul ignore if */
	        if (!compile && Component.template) {
	            warn$1(`Component provided template option but ` +
	                `runtime compilation is not supported in this build of Vue.` +
	                (` Use "vue.esm-browser.js" instead.`
	                        ) /* should not happen */);
	        }
	        else {
	            warn$1(`Component is missing template or render function.`);
	        }
	    }
	}
	function createAttrsProxy(instance) {
	    return new Proxy(instance.attrs, {
	            get(target, key) {
	                markAttrsAccessed();
	                track(instance, "get" /* GET */, '$attrs');
	                return target[key];
	            },
	            set() {
	                warn$1(`setupContext.attrs is readonly.`);
	                return false;
	            },
	            deleteProperty() {
	                warn$1(`setupContext.attrs is readonly.`);
	                return false;
	            }
	        }
	        );
	}
	function createSetupContext(instance) {
	    const expose = exposed => {
	        if (instance.exposed) {
	            warn$1(`expose() should be called only once per setup().`);
	        }
	        instance.exposed = exposed || {};
	    };
	    let attrs;
	    {
	        // We use getters in dev in case libs like test-utils overwrite instance
	        // properties (overwrites should not be done in prod)
	        return Object.freeze({
	            get attrs() {
	                return attrs || (attrs = createAttrsProxy(instance));
	            },
	            get slots() {
	                return shallowReadonly(instance.slots);
	            },
	            get emit() {
	                return (event, ...args) => instance.emit(event, ...args);
	            },
	            expose
	        });
	    }
	}
	function getExposeProxy(instance) {
	    if (instance.exposed) {
	        return (instance.exposeProxy ||
	            (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
	                get(target, key) {
	                    if (key in target) {
	                        return target[key];
	                    }
	                    else if (key in publicPropertiesMap) {
	                        return publicPropertiesMap[key](instance);
	                    }
	                }
	            })));
	    }
	}
	const classifyRE = /(?:^|[-_])(\w)/g;
	const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
	function getComponentName(Component, includeInferred = true) {
	    return isFunction(Component)
	        ? Component.displayName || Component.name
	        : Component.name || (includeInferred && Component.__name);
	}
	/* istanbul ignore next */
	function formatComponentName(instance, Component, isRoot = false) {
	    let name = getComponentName(Component);
	    if (!name && Component.__file) {
	        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
	        if (match) {
	            name = match[1];
	        }
	    }
	    if (!name && instance && instance.parent) {
	        // try to infer the name based on reverse resolution
	        const inferFromRegistry = (registry) => {
	            for (const key in registry) {
	                if (registry[key] === Component) {
	                    return key;
	                }
	            }
	        };
	        name =
	            inferFromRegistry(instance.components ||
	                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
	    }
	    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
	}
	function isClassComponent(value) {
	    return isFunction(value) && '__vccOpts' in value;
	}

	const computed$1 = ((getterOrOptions, debugOptions) => {
	    // @ts-ignore
	    return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
	});

	// dev only
	const warnRuntimeUsage = (method) => warn$1(`${method}() is a compiler-hint helper that is only usable inside ` +
	    `<script setup> of a single file component. Its arguments should be ` +
	    `compiled away and passing it at runtime has no effect.`);
	// implementation
	function defineProps() {
	    {
	        warnRuntimeUsage(`defineProps`);
	    }
	    return null;
	}
	// implementation
	function defineEmits() {
	    {
	        warnRuntimeUsage(`defineEmits`);
	    }
	    return null;
	}
	/**
	 * Vue `<script setup>` compiler macro for declaring a component's exposed
	 * instance properties when it is accessed by a parent component via template
	 * refs.
	 *
	 * `<script setup>` components are closed by default - i.e. variables inside
	 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
	 * via `defineExpose`.
	 *
	 * This is only usable inside `<script setup>`, is compiled away in the
	 * output and should **not** be actually called at runtime.
	 */
	function defineExpose(exposed) {
	    {
	        warnRuntimeUsage(`defineExpose`);
	    }
	}
	/**
	 * Vue `<script setup>` compiler macro for providing props default values when
	 * using type-based `defineProps` declaration.
	 *
	 * Example usage:
	 * ```ts
	 * withDefaults(defineProps<{
	 *   size?: number
	 *   labels?: string[]
	 * }>(), {
	 *   size: 3,
	 *   labels: () => ['default label']
	 * })
	 * ```
	 *
	 * This is only usable inside `<script setup>`, is compiled away in the output
	 * and should **not** be actually called at runtime.
	 */
	function withDefaults(props, defaults) {
	    {
	        warnRuntimeUsage(`withDefaults`);
	    }
	    return null;
	}
	function useSlots() {
	    return getContext().slots;
	}
	function useAttrs() {
	    return getContext().attrs;
	}
	function getContext() {
	    const i = getCurrentInstance();
	    if (!i) {
	        warn$1(`useContext() called without active instance.`);
	    }
	    return i.setupContext || (i.setupContext = createSetupContext(i));
	}
	/**
	 * Runtime helper for merging default declarations. Imported by compiled code
	 * only.
	 * @internal
	 */
	function mergeDefaults(raw, defaults) {
	    const props = isArray(raw)
	        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
	        : raw;
	    for (const key in defaults) {
	        const opt = props[key];
	        if (opt) {
	            if (isArray(opt) || isFunction(opt)) {
	                props[key] = { type: opt, default: defaults[key] };
	            }
	            else {
	                opt.default = defaults[key];
	            }
	        }
	        else if (opt === null) {
	            props[key] = { default: defaults[key] };
	        }
	        else {
	            warn$1(`props default key "${key}" has no corresponding declaration.`);
	        }
	    }
	    return props;
	}
	/**
	 * Used to create a proxy for the rest element when destructuring props with
	 * defineProps().
	 * @internal
	 */
	function createPropsRestProxy(props, excludedKeys) {
	    const ret = {};
	    for (const key in props) {
	        if (!excludedKeys.includes(key)) {
	            Object.defineProperty(ret, key, {
	                enumerable: true,
	                get: () => props[key]
	            });
	        }
	    }
	    return ret;
	}
	/**
	 * `<script setup>` helper for persisting the current instance context over
	 * async/await flows.
	 *
	 * `@vue/compiler-sfc` converts the following:
	 *
	 * ```ts
	 * const x = await foo()
	 * ```
	 *
	 * into:
	 *
	 * ```ts
	 * let __temp, __restore
	 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
	 * ```
	 * @internal
	 */
	function withAsyncContext(getAwaitable) {
	    const ctx = getCurrentInstance();
	    if (!ctx) {
	        warn$1(`withAsyncContext called without active current instance. ` +
	            `This is likely a bug.`);
	    }
	    let awaitable = getAwaitable();
	    unsetCurrentInstance();
	    if (isPromise(awaitable)) {
	        awaitable = awaitable.catch(e => {
	            setCurrentInstance(ctx);
	            throw e;
	        });
	    }
	    return [awaitable, () => setCurrentInstance(ctx)];
	}

	// Actual implementation
	function h(type, propsOrChildren, children) {
	    const l = arguments.length;
	    if (l === 2) {
	        if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
	            // single vnode without props
	            if (isVNode(propsOrChildren)) {
	                return createVNode(type, null, [propsOrChildren]);
	            }
	            // props without children
	            return createVNode(type, propsOrChildren);
	        }
	        else {
	            // omit props
	            return createVNode(type, null, propsOrChildren);
	        }
	    }
	    else {
	        if (l > 3) {
	            children = Array.prototype.slice.call(arguments, 2);
	        }
	        else if (l === 3 && isVNode(children)) {
	            children = [children];
	        }
	        return createVNode(type, propsOrChildren, children);
	    }
	}

	const ssrContextKey = Symbol(`ssrContext` );
	const useSSRContext = () => {
	    {
	        const ctx = inject(ssrContextKey);
	        if (!ctx) {
	            warn$1(`Server rendering context not provided. Make sure to only call ` +
	                `useSSRContext() conditionally in the server build.`);
	        }
	        return ctx;
	    }
	};

	function initCustomFormatter() {
	    /* eslint-disable no-restricted-globals */
	    if (typeof window === 'undefined') {
	        return;
	    }
	    const vueStyle = { style: 'color:#3ba776' };
	    const numberStyle = { style: 'color:#0b1bc9' };
	    const stringStyle = { style: 'color:#b62e24' };
	    const keywordStyle = { style: 'color:#9d288c' };
	    // custom formatter for Chrome
	    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
	    const formatter = {
	        header(obj) {
	            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
	            if (!isObject(obj)) {
	                return null;
	            }
	            if (obj.__isVue) {
	                return ['div', vueStyle, `VueInstance`];
	            }
	            else if (isRef(obj)) {
	                return [
	                    'div',
	                    {},
	                    ['span', vueStyle, genRefFlag(obj)],
	                    '<',
	                    formatValue(obj.value),
	                    `>`
	                ];
	            }
	            else if (isReactive(obj)) {
	                return [
	                    'div',
	                    {},
	                    ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],
	                    '<',
	                    formatValue(obj),
	                    `>${isReadonly(obj) ? ` (readonly)` : ``}`
	                ];
	            }
	            else if (isReadonly(obj)) {
	                return [
	                    'div',
	                    {},
	                    ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],
	                    '<',
	                    formatValue(obj),
	                    '>'
	                ];
	            }
	            return null;
	        },
	        hasBody(obj) {
	            return obj && obj.__isVue;
	        },
	        body(obj) {
	            if (obj && obj.__isVue) {
	                return [
	                    'div',
	                    {},
	                    ...formatInstance(obj.$)
	                ];
	            }
	        }
	    };
	    function formatInstance(instance) {
	        const blocks = [];
	        if (instance.type.props && instance.props) {
	            blocks.push(createInstanceBlock('props', toRaw(instance.props)));
	        }
	        if (instance.setupState !== EMPTY_OBJ) {
	            blocks.push(createInstanceBlock('setup', instance.setupState));
	        }
	        if (instance.data !== EMPTY_OBJ) {
	            blocks.push(createInstanceBlock('data', toRaw(instance.data)));
	        }
	        const computed = extractKeys(instance, 'computed');
	        if (computed) {
	            blocks.push(createInstanceBlock('computed', computed));
	        }
	        const injected = extractKeys(instance, 'inject');
	        if (injected) {
	            blocks.push(createInstanceBlock('injected', injected));
	        }
	        blocks.push([
	            'div',
	            {},
	            [
	                'span',
	                {
	                    style: keywordStyle.style + ';opacity:0.66'
	                },
	                '$ (internal): '
	            ],
	            ['object', { object: instance }]
	        ]);
	        return blocks;
	    }
	    function createInstanceBlock(type, target) {
	        target = extend({}, target);
	        if (!Object.keys(target).length) {
	            return ['span', {}];
	        }
	        return [
	            'div',
	            { style: 'line-height:1.25em;margin-bottom:0.6em' },
	            [
	                'div',
	                {
	                    style: 'color:#476582'
	                },
	                type
	            ],
	            [
	                'div',
	                {
	                    style: 'padding-left:1.25em'
	                },
	                ...Object.keys(target).map(key => {
	                    return [
	                        'div',
	                        {},
	                        ['span', keywordStyle, key + ': '],
	                        formatValue(target[key], false)
	                    ];
	                })
	            ]
	        ];
	    }
	    function formatValue(v, asRaw = true) {
	        if (typeof v === 'number') {
	            return ['span', numberStyle, v];
	        }
	        else if (typeof v === 'string') {
	            return ['span', stringStyle, JSON.stringify(v)];
	        }
	        else if (typeof v === 'boolean') {
	            return ['span', keywordStyle, v];
	        }
	        else if (isObject(v)) {
	            return ['object', { object: asRaw ? toRaw(v) : v }];
	        }
	        else {
	            return ['span', stringStyle, String(v)];
	        }
	    }
	    function extractKeys(instance, type) {
	        const Comp = instance.type;
	        if (isFunction(Comp)) {
	            return;
	        }
	        const extracted = {};
	        for (const key in instance.ctx) {
	            if (isKeyOfType(Comp, key, type)) {
	                extracted[key] = instance.ctx[key];
	            }
	        }
	        return extracted;
	    }
	    function isKeyOfType(Comp, key, type) {
	        const opts = Comp[type];
	        if ((isArray(opts) && opts.includes(key)) ||
	            (isObject(opts) && key in opts)) {
	            return true;
	        }
	        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
	            return true;
	        }
	        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
	            return true;
	        }
	    }
	    function genRefFlag(v) {
	        if (isShallow(v)) {
	            return `ShallowRef`;
	        }
	        if (v.effect) {
	            return `ComputedRef`;
	        }
	        return `Ref`;
	    }
	    if (window.devtoolsFormatters) {
	        window.devtoolsFormatters.push(formatter);
	    }
	    else {
	        window.devtoolsFormatters = [formatter];
	    }
	}

	function withMemo(memo, render, cache, index) {
	    const cached = cache[index];
	    if (cached && isMemoSame(cached, memo)) {
	        return cached;
	    }
	    const ret = render();
	    // shallow clone
	    ret.memo = memo.slice();
	    return (cache[index] = ret);
	}
	function isMemoSame(cached, memo) {
	    const prev = cached.memo;
	    if (prev.length != memo.length) {
	        return false;
	    }
	    for (let i = 0; i < prev.length; i++) {
	        if (hasChanged(prev[i], memo[i])) {
	            return false;
	        }
	    }
	    // make sure to let parent block track it when returning cached
	    if (isBlockTreeEnabled > 0 && currentBlock) {
	        currentBlock.push(cached);
	    }
	    return true;
	}

	// Core API ------------------------------------------------------------------
	const version = "3.2.37";
	/**
	 * SSR utils for \@vue/server-renderer. Only exposed in ssr-possible builds.
	 * @internal
	 */
	const ssrUtils = (null);
	/**
	 * @internal only exposed in compat builds
	 */
	const resolveFilter = null;
	/**
	 * @internal only exposed in compat builds.
	 */
	const compatUtils = (null);

	const svgNS = 'http://www.w3.org/2000/svg';
	const doc = (typeof document !== 'undefined' ? document : null);
	const templateContainer = doc && /*#__PURE__*/ doc.createElement('template');
	const nodeOps = {
	    insert: (child, parent, anchor) => {
	        parent.insertBefore(child, anchor || null);
	    },
	    remove: child => {
	        const parent = child.parentNode;
	        if (parent) {
	            parent.removeChild(child);
	        }
	    },
	    createElement: (tag, isSVG, is, props) => {
	        const el = isSVG
	            ? doc.createElementNS(svgNS, tag)
	            : doc.createElement(tag, is ? { is } : undefined);
	        if (tag === 'select' && props && props.multiple != null) {
	            el.setAttribute('multiple', props.multiple);
	        }
	        return el;
	    },
	    createText: text => doc.createTextNode(text),
	    createComment: text => doc.createComment(text),
	    setText: (node, text) => {
	        node.nodeValue = text;
	    },
	    setElementText: (el, text) => {
	        el.textContent = text;
	    },
	    parentNode: node => node.parentNode,
	    nextSibling: node => node.nextSibling,
	    querySelector: selector => doc.querySelector(selector),
	    setScopeId(el, id) {
	        el.setAttribute(id, '');
	    },
	    cloneNode(el) {
	        const cloned = el.cloneNode(true);
	        // #3072
	        // - in `patchDOMProp`, we store the actual value in the `el._value` property.
	        // - normally, elements using `:value` bindings will not be hoisted, but if
	        //   the bound value is a constant, e.g. `:value="true"` - they do get
	        //   hoisted.
	        // - in production, hoisted nodes are cloned when subsequent inserts, but
	        //   cloneNode() does not copy the custom property we attached.
	        // - This may need to account for other custom DOM properties we attach to
	        //   elements in addition to `_value` in the future.
	        if (`_value` in el) {
	            cloned._value = el._value;
	        }
	        return cloned;
	    },
	    // __UNSAFE__
	    // Reason: innerHTML.
	    // Static content here can only come from compiled templates.
	    // As long as the user only uses trusted templates, this is safe.
	    insertStaticContent(content, parent, anchor, isSVG, start, end) {
	        // <parent> before | first ... last | anchor </parent>
	        const before = anchor ? anchor.previousSibling : parent.lastChild;
	        // #5308 can only take cached path if:
	        // - has a single root node
	        // - nextSibling info is still available
	        if (start && (start === end || start.nextSibling)) {
	            // cached
	            while (true) {
	                parent.insertBefore(start.cloneNode(true), anchor);
	                if (start === end || !(start = start.nextSibling))
	                    break;
	            }
	        }
	        else {
	            // fresh insert
	            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
	            const template = templateContainer.content;
	            if (isSVG) {
	                // remove outer svg wrapper
	                const wrapper = template.firstChild;
	                while (wrapper.firstChild) {
	                    template.appendChild(wrapper.firstChild);
	                }
	                template.removeChild(wrapper);
	            }
	            parent.insertBefore(template, anchor);
	        }
	        return [
	            // first
	            before ? before.nextSibling : parent.firstChild,
	            // last
	            anchor ? anchor.previousSibling : parent.lastChild
	        ];
	    }
	};

	// compiler should normalize class + :class bindings on the same element
	// into a single binding ['staticClass', dynamic]
	function patchClass(el, value, isSVG) {
	    // directly setting className should be faster than setAttribute in theory
	    // if this is an element during a transition, take the temporary transition
	    // classes into account.
	    const transitionClasses = el._vtc;
	    if (transitionClasses) {
	        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
	    }
	    if (value == null) {
	        el.removeAttribute('class');
	    }
	    else if (isSVG) {
	        el.setAttribute('class', value);
	    }
	    else {
	        el.className = value;
	    }
	}

	function patchStyle(el, prev, next) {
	    const style = el.style;
	    const isCssString = isString(next);
	    if (next && !isCssString) {
	        for (const key in next) {
	            setStyle(style, key, next[key]);
	        }
	        if (prev && !isString(prev)) {
	            for (const key in prev) {
	                if (next[key] == null) {
	                    setStyle(style, key, '');
	                }
	            }
	        }
	    }
	    else {
	        const currentDisplay = style.display;
	        if (isCssString) {
	            if (prev !== next) {
	                style.cssText = next;
	            }
	        }
	        else if (prev) {
	            el.removeAttribute('style');
	        }
	        // indicates that the `display` of the element is controlled by `v-show`,
	        // so we always keep the current `display` value regardless of the `style`
	        // value, thus handing over control to `v-show`.
	        if ('_vod' in el) {
	            style.display = currentDisplay;
	        }
	    }
	}
	const importantRE = /\s*!important$/;
	function setStyle(style, name, val) {
	    if (isArray(val)) {
	        val.forEach(v => setStyle(style, name, v));
	    }
	    else {
	        if (val == null)
	            val = '';
	        if (name.startsWith('--')) {
	            // custom property definition
	            style.setProperty(name, val);
	        }
	        else {
	            const prefixed = autoPrefix(style, name);
	            if (importantRE.test(val)) {
	                // !important
	                style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');
	            }
	            else {
	                style[prefixed] = val;
	            }
	        }
	    }
	}
	const prefixes = ['Webkit', 'Moz', 'ms'];
	const prefixCache = {};
	function autoPrefix(style, rawName) {
	    const cached = prefixCache[rawName];
	    if (cached) {
	        return cached;
	    }
	    let name = camelize(rawName);
	    if (name !== 'filter' && name in style) {
	        return (prefixCache[rawName] = name);
	    }
	    name = capitalize(name);
	    for (let i = 0; i < prefixes.length; i++) {
	        const prefixed = prefixes[i] + name;
	        if (prefixed in style) {
	            return (prefixCache[rawName] = prefixed);
	        }
	    }
	    return rawName;
	}

	const xlinkNS = 'http://www.w3.org/1999/xlink';
	function patchAttr(el, key, value, isSVG, instance) {
	    if (isSVG && key.startsWith('xlink:')) {
	        if (value == null) {
	            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
	        }
	        else {
	            el.setAttributeNS(xlinkNS, key, value);
	        }
	    }
	    else {
	        // note we are only checking boolean attributes that don't have a
	        // corresponding dom prop of the same name here.
	        const isBoolean = isSpecialBooleanAttr(key);
	        if (value == null || (isBoolean && !includeBooleanAttr(value))) {
	            el.removeAttribute(key);
	        }
	        else {
	            el.setAttribute(key, isBoolean ? '' : value);
	        }
	    }
	}

	// __UNSAFE__
	// functions. The user is responsible for using them with only trusted content.
	function patchDOMProp(el, key, value, 
	// the following args are passed only due to potential innerHTML/textContent
	// overriding existing VNodes, in which case the old tree must be properly
	// unmounted.
	prevChildren, parentComponent, parentSuspense, unmountChildren) {
	    if (key === 'innerHTML' || key === 'textContent') {
	        if (prevChildren) {
	            unmountChildren(prevChildren, parentComponent, parentSuspense);
	        }
	        el[key] = value == null ? '' : value;
	        return;
	    }
	    if (key === 'value' &&
	        el.tagName !== 'PROGRESS' &&
	        // custom elements may use _value internally
	        !el.tagName.includes('-')) {
	        // store value as _value as well since
	        // non-string values will be stringified.
	        el._value = value;
	        const newValue = value == null ? '' : value;
	        if (el.value !== newValue ||
	            // #4956: always set for OPTION elements because its value falls back to
	            // textContent if no value attribute is present. And setting .value for
	            // OPTION has no side effect
	            el.tagName === 'OPTION') {
	            el.value = newValue;
	        }
	        if (value == null) {
	            el.removeAttribute(key);
	        }
	        return;
	    }
	    let needRemove = false;
	    if (value === '' || value == null) {
	        const type = typeof el[key];
	        if (type === 'boolean') {
	            // e.g. <select multiple> compiles to { multiple: '' }
	            value = includeBooleanAttr(value);
	        }
	        else if (value == null && type === 'string') {
	            // e.g. <div :id="null">
	            value = '';
	            needRemove = true;
	        }
	        else if (type === 'number') {
	            // e.g. <img :width="null">
	            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
	            value = 0;
	            needRemove = true;
	        }
	    }
	    // some properties perform value validation and throw,
	    // some properties has getter, no setter, will error in 'use strict'
	    // eg. <select :type="null"></select> <select :willValidate="null"></select>
	    try {
	        el[key] = value;
	    }
	    catch (e) {
	        {
	            warn$1(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
	                `value ${value} is invalid.`, e);
	        }
	    }
	    needRemove && el.removeAttribute(key);
	}

	// Async edge case fix requires storing an event listener's attach timestamp.
	const [_getNow, skipTimestampCheck] = /*#__PURE__*/ (() => {
	    let _getNow = Date.now;
	    let skipTimestampCheck = false;
	    if (typeof window !== 'undefined') {
	        // Determine what event timestamp the browser is using. Annoyingly, the
	        // timestamp can either be hi-res (relative to page load) or low-res
	        // (relative to UNIX epoch), so in order to compare time we have to use the
	        // same timestamp type when saving the flush timestamp.
	        if (Date.now() > document.createEvent('Event').timeStamp) {
	            // if the low-res timestamp which is bigger than the event timestamp
	            // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
	            // and we need to use the hi-res version for event listeners as well.
	            _getNow = performance.now.bind(performance);
	        }
	        // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
	        // and does not fire microtasks in between event propagation, so safe to exclude.
	        const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
	        skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
	    }
	    return [_getNow, skipTimestampCheck];
	})();
	// To avoid the overhead of repeatedly calling performance.now(), we cache
	// and use the same timestamp for all event listeners attached in the same tick.
	let cachedNow = 0;
	const p = /*#__PURE__*/ Promise.resolve();
	const reset = () => {
	    cachedNow = 0;
	};
	const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
	function addEventListener(el, event, handler, options) {
	    el.addEventListener(event, handler, options);
	}
	function removeEventListener(el, event, handler, options) {
	    el.removeEventListener(event, handler, options);
	}
	function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
	    // vei = vue event invokers
	    const invokers = el._vei || (el._vei = {});
	    const existingInvoker = invokers[rawName];
	    if (nextValue && existingInvoker) {
	        // patch
	        existingInvoker.value = nextValue;
	    }
	    else {
	        const [name, options] = parseName(rawName);
	        if (nextValue) {
	            // add
	            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
	            addEventListener(el, name, invoker, options);
	        }
	        else if (existingInvoker) {
	            // remove
	            removeEventListener(el, name, existingInvoker, options);
	            invokers[rawName] = undefined;
	        }
	    }
	}
	const optionsModifierRE = /(?:Once|Passive|Capture)$/;
	function parseName(name) {
	    let options;
	    if (optionsModifierRE.test(name)) {
	        options = {};
	        let m;
	        while ((m = name.match(optionsModifierRE))) {
	            name = name.slice(0, name.length - m[0].length);
	            options[m[0].toLowerCase()] = true;
	        }
	    }
	    return [hyphenate(name.slice(2)), options];
	}
	function createInvoker(initialValue, instance) {
	    const invoker = (e) => {
	        // async edge case #6566: inner click event triggers patch, event handler
	        // attached to outer element during patch, and triggered again. This
	        // happens because browsers fire microtask ticks between event propagation.
	        // the solution is simple: we save the timestamp when a handler is attached,
	        // and the handler would only fire if the event passed to it was fired
	        // AFTER it was attached.
	        const timeStamp = e.timeStamp || _getNow();
	        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
	            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
	        }
	    };
	    invoker.value = initialValue;
	    invoker.attached = getNow();
	    return invoker;
	}
	function patchStopImmediatePropagation(e, value) {
	    if (isArray(value)) {
	        const originalStop = e.stopImmediatePropagation;
	        e.stopImmediatePropagation = () => {
	            originalStop.call(e);
	            e._stopped = true;
	        };
	        return value.map(fn => (e) => !e._stopped && fn && fn(e));
	    }
	    else {
	        return value;
	    }
	}

	const nativeOnRE = /^on[a-z]/;
	const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
	    if (key === 'class') {
	        patchClass(el, nextValue, isSVG);
	    }
	    else if (key === 'style') {
	        patchStyle(el, prevValue, nextValue);
	    }
	    else if (isOn(key)) {
	        // ignore v-model listeners
	        if (!isModelListener(key)) {
	            patchEvent(el, key, prevValue, nextValue, parentComponent);
	        }
	    }
	    else if (key[0] === '.'
	        ? ((key = key.slice(1)), true)
	        : key[0] === '^'
	            ? ((key = key.slice(1)), false)
	            : shouldSetAsProp(el, key, nextValue, isSVG)) {
	        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
	    }
	    else {
	        // special case for <input v-model type="checkbox"> with
	        // :true-value & :false-value
	        // store value as dom properties since non-string values will be
	        // stringified.
	        if (key === 'true-value') {
	            el._trueValue = nextValue;
	        }
	        else if (key === 'false-value') {
	            el._falseValue = nextValue;
	        }
	        patchAttr(el, key, nextValue, isSVG);
	    }
	};
	function shouldSetAsProp(el, key, value, isSVG) {
	    if (isSVG) {
	        // most keys must be set as attribute on svg elements to work
	        // ...except innerHTML & textContent
	        if (key === 'innerHTML' || key === 'textContent') {
	            return true;
	        }
	        // or native onclick with function values
	        if (key in el && nativeOnRE.test(key) && isFunction(value)) {
	            return true;
	        }
	        return false;
	    }
	    // these are enumerated attrs, however their corresponding DOM properties
	    // are actually booleans - this leads to setting it with a string "false"
	    // value leading it to be coerced to `true`, so we need to always treat
	    // them as attributes.
	    // Note that `contentEditable` doesn't have this problem: its DOM
	    // property is also enumerated string values.
	    if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {
	        return false;
	    }
	    // #1787, #2840 form property on form elements is readonly and must be set as
	    // attribute.
	    if (key === 'form') {
	        return false;
	    }
	    // #1526 <input list> must be set as attribute
	    if (key === 'list' && el.tagName === 'INPUT') {
	        return false;
	    }
	    // #2766 <textarea type> must be set as attribute
	    if (key === 'type' && el.tagName === 'TEXTAREA') {
	        return false;
	    }
	    // native onclick with string value, must be set as attribute
	    if (nativeOnRE.test(key) && isString(value)) {
	        return false;
	    }
	    return key in el;
	}

	function defineCustomElement(options, hydrate) {
	    const Comp = defineComponent(options);
	    class VueCustomElement extends VueElement {
	        constructor(initialProps) {
	            super(Comp, initialProps, hydrate);
	        }
	    }
	    VueCustomElement.def = Comp;
	    return VueCustomElement;
	}
	const defineSSRCustomElement = ((options) => {
	    // @ts-ignore
	    return defineCustomElement(options, hydrate);
	});
	const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {
	});
	class VueElement extends BaseClass {
	    constructor(_def, _props = {}, hydrate) {
	        super();
	        this._def = _def;
	        this._props = _props;
	        /**
	         * @internal
	         */
	        this._instance = null;
	        this._connected = false;
	        this._resolved = false;
	        this._numberProps = null;
	        if (this.shadowRoot && hydrate) {
	            hydrate(this._createVNode(), this.shadowRoot);
	        }
	        else {
	            if (this.shadowRoot) {
	                warn$1(`Custom element has pre-rendered declarative shadow root but is not ` +
	                    `defined as hydratable. Use \`defineSSRCustomElement\`.`);
	            }
	            this.attachShadow({ mode: 'open' });
	        }
	    }
	    connectedCallback() {
	        this._connected = true;
	        if (!this._instance) {
	            this._resolveDef();
	        }
	    }
	    disconnectedCallback() {
	        this._connected = false;
	        nextTick(() => {
	            if (!this._connected) {
	                render$l(null, this.shadowRoot);
	                this._instance = null;
	            }
	        });
	    }
	    /**
	     * resolve inner component definition (handle possible async component)
	     */
	    _resolveDef() {
	        if (this._resolved) {
	            return;
	        }
	        this._resolved = true;
	        // set initial attrs
	        for (let i = 0; i < this.attributes.length; i++) {
	            this._setAttr(this.attributes[i].name);
	        }
	        // watch future attr changes
	        new MutationObserver(mutations => {
	            for (const m of mutations) {
	                this._setAttr(m.attributeName);
	            }
	        }).observe(this, { attributes: true });
	        const resolve = (def) => {
	            const { props, styles } = def;
	            const hasOptions = !isArray(props);
	            const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];
	            // cast Number-type props set before resolve
	            let numberProps;
	            if (hasOptions) {
	                for (const key in this._props) {
	                    const opt = props[key];
	                    if (opt === Number || (opt && opt.type === Number)) {
	                        this._props[key] = toNumber(this._props[key]);
	                        (numberProps || (numberProps = Object.create(null)))[key] = true;
	                    }
	                }
	            }
	            this._numberProps = numberProps;
	            // check if there are props set pre-upgrade or connect
	            for (const key of Object.keys(this)) {
	                if (key[0] !== '_') {
	                    this._setProp(key, this[key], true, false);
	                }
	            }
	            // defining getter/setters on prototype
	            for (const key of rawKeys.map(camelize)) {
	                Object.defineProperty(this, key, {
	                    get() {
	                        return this._getProp(key);
	                    },
	                    set(val) {
	                        this._setProp(key, val);
	                    }
	                });
	            }
	            // apply CSS
	            this._applyStyles(styles);
	            // initial render
	            this._update();
	        };
	        const asyncDef = this._def.__asyncLoader;
	        if (asyncDef) {
	            asyncDef().then(resolve);
	        }
	        else {
	            resolve(this._def);
	        }
	    }
	    _setAttr(key) {
	        let value = this.getAttribute(key);
	        if (this._numberProps && this._numberProps[key]) {
	            value = toNumber(value);
	        }
	        this._setProp(camelize(key), value, false);
	    }
	    /**
	     * @internal
	     */
	    _getProp(key) {
	        return this._props[key];
	    }
	    /**
	     * @internal
	     */
	    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
	        if (val !== this._props[key]) {
	            this._props[key] = val;
	            if (shouldUpdate && this._instance) {
	                this._update();
	            }
	            // reflect
	            if (shouldReflect) {
	                if (val === true) {
	                    this.setAttribute(hyphenate(key), '');
	                }
	                else if (typeof val === 'string' || typeof val === 'number') {
	                    this.setAttribute(hyphenate(key), val + '');
	                }
	                else if (!val) {
	                    this.removeAttribute(hyphenate(key));
	                }
	            }
	        }
	    }
	    _update() {
	        render$l(this._createVNode(), this.shadowRoot);
	    }
	    _createVNode() {
	        const vnode = createVNode(this._def, extend({}, this._props));
	        if (!this._instance) {
	            vnode.ce = instance => {
	                this._instance = instance;
	                instance.isCE = true;
	                // HMR
	                {
	                    instance.ceReload = newStyles => {
	                        // always reset styles
	                        if (this._styles) {
	                            this._styles.forEach(s => this.shadowRoot.removeChild(s));
	                            this._styles.length = 0;
	                        }
	                        this._applyStyles(newStyles);
	                        // if this is an async component, ceReload is called from the inner
	                        // component so no need to reload the async wrapper
	                        if (!this._def.__asyncLoader) {
	                            // reload
	                            this._instance = null;
	                            this._update();
	                        }
	                    };
	                }
	                // intercept emit
	                instance.emit = (event, ...args) => {
	                    this.dispatchEvent(new CustomEvent(event, {
	                        detail: args
	                    }));
	                };
	                // locate nearest Vue custom element parent for provide/inject
	                let parent = this;
	                while ((parent =
	                    parent && (parent.parentNode || parent.host))) {
	                    if (parent instanceof VueElement) {
	                        instance.parent = parent._instance;
	                        break;
	                    }
	                }
	            };
	        }
	        return vnode;
	    }
	    _applyStyles(styles) {
	        if (styles) {
	            styles.forEach(css => {
	                const s = document.createElement('style');
	                s.textContent = css;
	                this.shadowRoot.appendChild(s);
	                // record for HMR
	                {
	                    (this._styles || (this._styles = [])).push(s);
	                }
	            });
	        }
	    }
	}

	function useCssModule(name = '$style') {
	    /* istanbul ignore else */
	    {
	        const instance = getCurrentInstance();
	        if (!instance) {
	            warn$1(`useCssModule must be called inside setup()`);
	            return EMPTY_OBJ;
	        }
	        const modules = instance.type.__cssModules;
	        if (!modules) {
	            warn$1(`Current instance does not have CSS modules injected.`);
	            return EMPTY_OBJ;
	        }
	        const mod = modules[name];
	        if (!mod) {
	            warn$1(`Current instance does not have CSS module named "${name}".`);
	            return EMPTY_OBJ;
	        }
	        return mod;
	    }
	}

	/**
	 * Runtime helper for SFC's CSS variable injection feature.
	 * @private
	 */
	function useCssVars(getter) {
	    const instance = getCurrentInstance();
	    /* istanbul ignore next */
	    if (!instance) {
	        warn$1(`useCssVars is called without current active component instance.`);
	        return;
	    }
	    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
	    watchPostEffect(setVars);
	    onMounted(() => {
	        const ob = new MutationObserver(setVars);
	        ob.observe(instance.subTree.el.parentNode, { childList: true });
	        onUnmounted(() => ob.disconnect());
	    });
	}
	function setVarsOnVNode(vnode, vars) {
	    if (vnode.shapeFlag & 128 /* SUSPENSE */) {
	        const suspense = vnode.suspense;
	        vnode = suspense.activeBranch;
	        if (suspense.pendingBranch && !suspense.isHydrating) {
	            suspense.effects.push(() => {
	                setVarsOnVNode(suspense.activeBranch, vars);
	            });
	        }
	    }
	    // drill down HOCs until it's a non-component vnode
	    while (vnode.component) {
	        vnode = vnode.component.subTree;
	    }
	    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
	        setVarsOnNode(vnode.el, vars);
	    }
	    else if (vnode.type === Fragment) {
	        vnode.children.forEach(c => setVarsOnVNode(c, vars));
	    }
	    else if (vnode.type === Static) {
	        let { el, anchor } = vnode;
	        while (el) {
	            setVarsOnNode(el, vars);
	            if (el === anchor)
	                break;
	            el = el.nextSibling;
	        }
	    }
	}
	function setVarsOnNode(el, vars) {
	    if (el.nodeType === 1) {
	        const style = el.style;
	        for (const key in vars) {
	            style.setProperty(`--${key}`, vars[key]);
	        }
	    }
	}

	const TRANSITION = 'transition';
	const ANIMATION = 'animation';
	// DOM Transition is a higher-order-component based on the platform-agnostic
	// base Transition component, with DOM-specific logic.
	const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
	Transition.displayName = 'Transition';
	const DOMTransitionPropsValidators = {
	    name: String,
	    type: String,
	    css: {
	        type: Boolean,
	        default: true
	    },
	    duration: [String, Number, Object],
	    enterFromClass: String,
	    enterActiveClass: String,
	    enterToClass: String,
	    appearFromClass: String,
	    appearActiveClass: String,
	    appearToClass: String,
	    leaveFromClass: String,
	    leaveActiveClass: String,
	    leaveToClass: String
	};
	const TransitionPropsValidators = (Transition.props =
	    /*#__PURE__*/ extend({}, BaseTransition.props, DOMTransitionPropsValidators));
	/**
	 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
	 * with custom HOCs.
	 */
	const callHook$1 = (hook, args = []) => {
	    if (isArray(hook)) {
	        hook.forEach(h => h(...args));
	    }
	    else if (hook) {
	        hook(...args);
	    }
	};
	/**
	 * Check if a hook expects a callback (2nd arg), which means the user
	 * intends to explicitly control the end of the transition.
	 */
	const hasExplicitCallback = (hook) => {
	    return hook
	        ? isArray(hook)
	            ? hook.some(h => h.length > 1)
	            : hook.length > 1
	        : false;
	};
	function resolveTransitionProps(rawProps) {
	    const baseProps = {};
	    for (const key in rawProps) {
	        if (!(key in DOMTransitionPropsValidators)) {
	            baseProps[key] = rawProps[key];
	        }
	    }
	    if (rawProps.css === false) {
	        return baseProps;
	    }
	    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
	    const durations = normalizeDuration(duration);
	    const enterDuration = durations && durations[0];
	    const leaveDuration = durations && durations[1];
	    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
	    const finishEnter = (el, isAppear, done) => {
	        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
	        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
	        done && done();
	    };
	    const finishLeave = (el, done) => {
	        el._isLeaving = false;
	        removeTransitionClass(el, leaveFromClass);
	        removeTransitionClass(el, leaveToClass);
	        removeTransitionClass(el, leaveActiveClass);
	        done && done();
	    };
	    const makeEnterHook = (isAppear) => {
	        return (el, done) => {
	            const hook = isAppear ? onAppear : onEnter;
	            const resolve = () => finishEnter(el, isAppear, done);
	            callHook$1(hook, [el, resolve]);
	            nextFrame(() => {
	                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
	                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
	                if (!hasExplicitCallback(hook)) {
	                    whenTransitionEnds(el, type, enterDuration, resolve);
	                }
	            });
	        };
	    };
	    return extend(baseProps, {
	        onBeforeEnter(el) {
	            callHook$1(onBeforeEnter, [el]);
	            addTransitionClass(el, enterFromClass);
	            addTransitionClass(el, enterActiveClass);
	        },
	        onBeforeAppear(el) {
	            callHook$1(onBeforeAppear, [el]);
	            addTransitionClass(el, appearFromClass);
	            addTransitionClass(el, appearActiveClass);
	        },
	        onEnter: makeEnterHook(false),
	        onAppear: makeEnterHook(true),
	        onLeave(el, done) {
	            el._isLeaving = true;
	            const resolve = () => finishLeave(el, done);
	            addTransitionClass(el, leaveFromClass);
	            // force reflow so *-leave-from classes immediately take effect (#2593)
	            forceReflow();
	            addTransitionClass(el, leaveActiveClass);
	            nextFrame(() => {
	                if (!el._isLeaving) {
	                    // cancelled
	                    return;
	                }
	                removeTransitionClass(el, leaveFromClass);
	                addTransitionClass(el, leaveToClass);
	                if (!hasExplicitCallback(onLeave)) {
	                    whenTransitionEnds(el, type, leaveDuration, resolve);
	                }
	            });
	            callHook$1(onLeave, [el, resolve]);
	        },
	        onEnterCancelled(el) {
	            finishEnter(el, false);
	            callHook$1(onEnterCancelled, [el]);
	        },
	        onAppearCancelled(el) {
	            finishEnter(el, true);
	            callHook$1(onAppearCancelled, [el]);
	        },
	        onLeaveCancelled(el) {
	            finishLeave(el);
	            callHook$1(onLeaveCancelled, [el]);
	        }
	    });
	}
	function normalizeDuration(duration) {
	    if (duration == null) {
	        return null;
	    }
	    else if (isObject(duration)) {
	        return [NumberOf(duration.enter), NumberOf(duration.leave)];
	    }
	    else {
	        const n = NumberOf(duration);
	        return [n, n];
	    }
	}
	function NumberOf(val) {
	    const res = toNumber(val);
	    validateDuration(res);
	    return res;
	}
	function validateDuration(val) {
	    if (typeof val !== 'number') {
	        warn$1(`<transition> explicit duration is not a valid number - ` +
	            `got ${JSON.stringify(val)}.`);
	    }
	    else if (isNaN(val)) {
	        warn$1(`<transition> explicit duration is NaN - ` +
	            'the duration expression might be incorrect.');
	    }
	}
	function addTransitionClass(el, cls) {
	    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
	    (el._vtc ||
	        (el._vtc = new Set())).add(cls);
	}
	function removeTransitionClass(el, cls) {
	    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
	    const { _vtc } = el;
	    if (_vtc) {
	        _vtc.delete(cls);
	        if (!_vtc.size) {
	            el._vtc = undefined;
	        }
	    }
	}
	function nextFrame(cb) {
	    requestAnimationFrame(() => {
	        requestAnimationFrame(cb);
	    });
	}
	let endId = 0;
	function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
	    const id = (el._endId = ++endId);
	    const resolveIfNotStale = () => {
	        if (id === el._endId) {
	            resolve();
	        }
	    };
	    if (explicitTimeout) {
	        return setTimeout(resolveIfNotStale, explicitTimeout);
	    }
	    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
	    if (!type) {
	        return resolve();
	    }
	    const endEvent = type + 'end';
	    let ended = 0;
	    const end = () => {
	        el.removeEventListener(endEvent, onEnd);
	        resolveIfNotStale();
	    };
	    const onEnd = (e) => {
	        if (e.target === el && ++ended >= propCount) {
	            end();
	        }
	    };
	    setTimeout(() => {
	        if (ended < propCount) {
	            end();
	        }
	    }, timeout + 1);
	    el.addEventListener(endEvent, onEnd);
	}
	function getTransitionInfo(el, expectedType) {
	    const styles = window.getComputedStyle(el);
	    // JSDOM may return undefined for transition properties
	    const getStyleProperties = (key) => (styles[key] || '').split(', ');
	    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
	    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
	    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
	    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
	    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
	    const animationTimeout = getTimeout(animationDelays, animationDurations);
	    let type = null;
	    let timeout = 0;
	    let propCount = 0;
	    /* istanbul ignore if */
	    if (expectedType === TRANSITION) {
	        if (transitionTimeout > 0) {
	            type = TRANSITION;
	            timeout = transitionTimeout;
	            propCount = transitionDurations.length;
	        }
	    }
	    else if (expectedType === ANIMATION) {
	        if (animationTimeout > 0) {
	            type = ANIMATION;
	            timeout = animationTimeout;
	            propCount = animationDurations.length;
	        }
	    }
	    else {
	        timeout = Math.max(transitionTimeout, animationTimeout);
	        type =
	            timeout > 0
	                ? transitionTimeout > animationTimeout
	                    ? TRANSITION
	                    : ANIMATION
	                : null;
	        propCount = type
	            ? type === TRANSITION
	                ? transitionDurations.length
	                : animationDurations.length
	            : 0;
	    }
	    const hasTransform = type === TRANSITION &&
	        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
	    return {
	        type,
	        timeout,
	        propCount,
	        hasTransform
	    };
	}
	function getTimeout(delays, durations) {
	    while (delays.length < durations.length) {
	        delays = delays.concat(delays);
	    }
	    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
	}
	// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
	// numbers in a locale-dependent way, using a comma instead of a dot.
	// If comma is not replaced with a dot, the input will be rounded down
	// (i.e. acting as a floor function) causing unexpected behaviors
	function toMs(s) {
	    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
	}
	// synchronously force layout to put elements into a certain state
	function forceReflow() {
	    return document.body.offsetHeight;
	}

	const positionMap = new WeakMap();
	const newPositionMap = new WeakMap();
	const TransitionGroupImpl = {
	    name: 'TransitionGroup',
	    props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {
	        tag: String,
	        moveClass: String
	    }),
	    setup(props, { slots }) {
	        const instance = getCurrentInstance();
	        const state = useTransitionState();
	        let prevChildren;
	        let children;
	        onUpdated(() => {
	            // children is guaranteed to exist after initial render
	            if (!prevChildren.length) {
	                return;
	            }
	            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
	            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
	                return;
	            }
	            // we divide the work into three loops to avoid mixing DOM reads and writes
	            // in each iteration - which helps prevent layout thrashing.
	            prevChildren.forEach(callPendingCbs);
	            prevChildren.forEach(recordPosition);
	            const movedChildren = prevChildren.filter(applyTranslation);
	            // force reflow to put everything in position
	            forceReflow();
	            movedChildren.forEach(c => {
	                const el = c.el;
	                const style = el.style;
	                addTransitionClass(el, moveClass);
	                style.transform = style.webkitTransform = style.transitionDuration = '';
	                const cb = (el._moveCb = (e) => {
	                    if (e && e.target !== el) {
	                        return;
	                    }
	                    if (!e || /transform$/.test(e.propertyName)) {
	                        el.removeEventListener('transitionend', cb);
	                        el._moveCb = null;
	                        removeTransitionClass(el, moveClass);
	                    }
	                });
	                el.addEventListener('transitionend', cb);
	            });
	        });
	        return () => {
	            const rawProps = toRaw(props);
	            const cssTransitionProps = resolveTransitionProps(rawProps);
	            let tag = rawProps.tag || Fragment;
	            prevChildren = children;
	            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
	            for (let i = 0; i < children.length; i++) {
	                const child = children[i];
	                if (child.key != null) {
	                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
	                }
	                else {
	                    warn$1(`<TransitionGroup> children must be keyed.`);
	                }
	            }
	            if (prevChildren) {
	                for (let i = 0; i < prevChildren.length; i++) {
	                    const child = prevChildren[i];
	                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
	                    positionMap.set(child, child.el.getBoundingClientRect());
	                }
	            }
	            return createVNode(tag, null, children);
	        };
	    }
	};
	const TransitionGroup = TransitionGroupImpl;
	function callPendingCbs(c) {
	    const el = c.el;
	    if (el._moveCb) {
	        el._moveCb();
	    }
	    if (el._enterCb) {
	        el._enterCb();
	    }
	}
	function recordPosition(c) {
	    newPositionMap.set(c, c.el.getBoundingClientRect());
	}
	function applyTranslation(c) {
	    const oldPos = positionMap.get(c);
	    const newPos = newPositionMap.get(c);
	    const dx = oldPos.left - newPos.left;
	    const dy = oldPos.top - newPos.top;
	    if (dx || dy) {
	        const s = c.el.style;
	        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
	        s.transitionDuration = '0s';
	        return c;
	    }
	}
	function hasCSSTransform(el, root, moveClass) {
	    // Detect whether an element with the move class applied has
	    // CSS transitions. Since the element may be inside an entering
	    // transition at this very moment, we make a clone of it and remove
	    // all other transition classes applied to ensure only the move class
	    // is applied.
	    const clone = el.cloneNode();
	    if (el._vtc) {
	        el._vtc.forEach(cls => {
	            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
	        });
	    }
	    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
	    clone.style.display = 'none';
	    const container = (root.nodeType === 1 ? root : root.parentNode);
	    container.appendChild(clone);
	    const { hasTransform } = getTransitionInfo(clone);
	    container.removeChild(clone);
	    return hasTransform;
	}

	const getModelAssigner = (vnode) => {
	    const fn = vnode.props['onUpdate:modelValue'] ||
	        (false );
	    return isArray(fn) ? value => invokeArrayFns(fn, value) : fn;
	};
	function onCompositionStart(e) {
	    e.target.composing = true;
	}
	function onCompositionEnd(e) {
	    const target = e.target;
	    if (target.composing) {
	        target.composing = false;
	        target.dispatchEvent(new Event('input'));
	    }
	}
	// We are exporting the v-model runtime directly as vnode hooks so that it can
	// be tree-shaken in case v-model is never used.
	const vModelText = {
	    created(el, { modifiers: { lazy, trim, number } }, vnode) {
	        el._assign = getModelAssigner(vnode);
	        const castToNumber = number || (vnode.props && vnode.props.type === 'number');
	        addEventListener(el, lazy ? 'change' : 'input', e => {
	            if (e.target.composing)
	                return;
	            let domValue = el.value;
	            if (trim) {
	                domValue = domValue.trim();
	            }
	            if (castToNumber) {
	                domValue = toNumber(domValue);
	            }
	            el._assign(domValue);
	        });
	        if (trim) {
	            addEventListener(el, 'change', () => {
	                el.value = el.value.trim();
	            });
	        }
	        if (!lazy) {
	            addEventListener(el, 'compositionstart', onCompositionStart);
	            addEventListener(el, 'compositionend', onCompositionEnd);
	            // Safari < 10.2 & UIWebView doesn't fire compositionend when
	            // switching focus before confirming composition choice
	            // this also fixes the issue where some browsers e.g. iOS Chrome
	            // fires "change" instead of "input" on autocomplete.
	            addEventListener(el, 'change', onCompositionEnd);
	        }
	    },
	    // set value on mounted so it's after min/max for type="range"
	    mounted(el, { value }) {
	        el.value = value == null ? '' : value;
	    },
	    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
	        el._assign = getModelAssigner(vnode);
	        // avoid clearing unresolved text. #2302
	        if (el.composing)
	            return;
	        if (document.activeElement === el && el.type !== 'range') {
	            if (lazy) {
	                return;
	            }
	            if (trim && el.value.trim() === value) {
	                return;
	            }
	            if ((number || el.type === 'number') && toNumber(el.value) === value) {
	                return;
	            }
	        }
	        const newValue = value == null ? '' : value;
	        if (el.value !== newValue) {
	            el.value = newValue;
	        }
	    }
	};
	const vModelCheckbox = {
	    // #4096 array checkboxes need to be deep traversed
	    deep: true,
	    created(el, _, vnode) {
	        el._assign = getModelAssigner(vnode);
	        addEventListener(el, 'change', () => {
	            const modelValue = el._modelValue;
	            const elementValue = getValue(el);
	            const checked = el.checked;
	            const assign = el._assign;
	            if (isArray(modelValue)) {
	                const index = looseIndexOf(modelValue, elementValue);
	                const found = index !== -1;
	                if (checked && !found) {
	                    assign(modelValue.concat(elementValue));
	                }
	                else if (!checked && found) {
	                    const filtered = [...modelValue];
	                    filtered.splice(index, 1);
	                    assign(filtered);
	                }
	            }
	            else if (isSet(modelValue)) {
	                const cloned = new Set(modelValue);
	                if (checked) {
	                    cloned.add(elementValue);
	                }
	                else {
	                    cloned.delete(elementValue);
	                }
	                assign(cloned);
	            }
	            else {
	                assign(getCheckboxValue(el, checked));
	            }
	        });
	    },
	    // set initial checked on mount to wait for true-value/false-value
	    mounted: setChecked,
	    beforeUpdate(el, binding, vnode) {
	        el._assign = getModelAssigner(vnode);
	        setChecked(el, binding, vnode);
	    }
	};
	function setChecked(el, { value, oldValue }, vnode) {
	    el._modelValue = value;
	    if (isArray(value)) {
	        el.checked = looseIndexOf(value, vnode.props.value) > -1;
	    }
	    else if (isSet(value)) {
	        el.checked = value.has(vnode.props.value);
	    }
	    else if (value !== oldValue) {
	        el.checked = looseEqual(value, getCheckboxValue(el, true));
	    }
	}
	const vModelRadio = {
	    created(el, { value }, vnode) {
	        el.checked = looseEqual(value, vnode.props.value);
	        el._assign = getModelAssigner(vnode);
	        addEventListener(el, 'change', () => {
	            el._assign(getValue(el));
	        });
	    },
	    beforeUpdate(el, { value, oldValue }, vnode) {
	        el._assign = getModelAssigner(vnode);
	        if (value !== oldValue) {
	            el.checked = looseEqual(value, vnode.props.value);
	        }
	    }
	};
	const vModelSelect = {
	    // <select multiple> value need to be deep traversed
	    deep: true,
	    created(el, { value, modifiers: { number } }, vnode) {
	        const isSetModel = isSet(value);
	        addEventListener(el, 'change', () => {
	            const selectedVal = Array.prototype.filter
	                .call(el.options, (o) => o.selected)
	                .map((o) => number ? toNumber(getValue(o)) : getValue(o));
	            el._assign(el.multiple
	                ? isSetModel
	                    ? new Set(selectedVal)
	                    : selectedVal
	                : selectedVal[0]);
	        });
	        el._assign = getModelAssigner(vnode);
	    },
	    // set value in mounted & updated because <select> relies on its children
	    // <option>s.
	    mounted(el, { value }) {
	        setSelected(el, value);
	    },
	    beforeUpdate(el, _binding, vnode) {
	        el._assign = getModelAssigner(vnode);
	    },
	    updated(el, { value }) {
	        setSelected(el, value);
	    }
	};
	function setSelected(el, value) {
	    const isMultiple = el.multiple;
	    if (isMultiple && !isArray(value) && !isSet(value)) {
	        warn$1(`<select multiple v-model> expects an Array or Set value for its binding, ` +
	                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
	        return;
	    }
	    for (let i = 0, l = el.options.length; i < l; i++) {
	        const option = el.options[i];
	        const optionValue = getValue(option);
	        if (isMultiple) {
	            if (isArray(value)) {
	                option.selected = looseIndexOf(value, optionValue) > -1;
	            }
	            else {
	                option.selected = value.has(optionValue);
	            }
	        }
	        else {
	            if (looseEqual(getValue(option), value)) {
	                if (el.selectedIndex !== i)
	                    el.selectedIndex = i;
	                return;
	            }
	        }
	    }
	    if (!isMultiple && el.selectedIndex !== -1) {
	        el.selectedIndex = -1;
	    }
	}
	// retrieve raw value set via :value bindings
	function getValue(el) {
	    return '_value' in el ? el._value : el.value;
	}
	// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
	function getCheckboxValue(el, checked) {
	    const key = checked ? '_trueValue' : '_falseValue';
	    return key in el ? el[key] : checked;
	}
	const vModelDynamic = {
	    created(el, binding, vnode) {
	        callModelHook(el, binding, vnode, null, 'created');
	    },
	    mounted(el, binding, vnode) {
	        callModelHook(el, binding, vnode, null, 'mounted');
	    },
	    beforeUpdate(el, binding, vnode, prevVNode) {
	        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
	    },
	    updated(el, binding, vnode, prevVNode) {
	        callModelHook(el, binding, vnode, prevVNode, 'updated');
	    }
	};
	function resolveDynamicModel(tagName, type) {
	    switch (tagName) {
	        case 'SELECT':
	            return vModelSelect;
	        case 'TEXTAREA':
	            return vModelText;
	        default:
	            switch (type) {
	                case 'checkbox':
	                    return vModelCheckbox;
	                case 'radio':
	                    return vModelRadio;
	                default:
	                    return vModelText;
	            }
	    }
	}
	function callModelHook(el, binding, vnode, prevVNode, hook) {
	    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
	    const fn = modelToUse[hook];
	    fn && fn(el, binding, vnode, prevVNode);
	}

	const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
	const modifierGuards = {
	    stop: e => e.stopPropagation(),
	    prevent: e => e.preventDefault(),
	    self: e => e.target !== e.currentTarget,
	    ctrl: e => !e.ctrlKey,
	    shift: e => !e.shiftKey,
	    alt: e => !e.altKey,
	    meta: e => !e.metaKey,
	    left: e => 'button' in e && e.button !== 0,
	    middle: e => 'button' in e && e.button !== 1,
	    right: e => 'button' in e && e.button !== 2,
	    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
	};
	/**
	 * @private
	 */
	const withModifiers = (fn, modifiers) => {
	    return (event, ...args) => {
	        for (let i = 0; i < modifiers.length; i++) {
	            const guard = modifierGuards[modifiers[i]];
	            if (guard && guard(event, modifiers))
	                return;
	        }
	        return fn(event, ...args);
	    };
	};
	// Kept for 2.x compat.
	// Note: IE11 compat for `spacebar` and `del` is removed for now.
	const keyNames = {
	    esc: 'escape',
	    space: ' ',
	    up: 'arrow-up',
	    left: 'arrow-left',
	    right: 'arrow-right',
	    down: 'arrow-down',
	    delete: 'backspace'
	};
	/**
	 * @private
	 */
	const withKeys = (fn, modifiers) => {
	    return (event) => {
	        if (!('key' in event)) {
	            return;
	        }
	        const eventKey = hyphenate(event.key);
	        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
	            return fn(event);
	        }
	    };
	};

	const vShow = {
	    beforeMount(el, { value }, { transition }) {
	        el._vod = el.style.display === 'none' ? '' : el.style.display;
	        if (transition && value) {
	            transition.beforeEnter(el);
	        }
	        else {
	            setDisplay(el, value);
	        }
	    },
	    mounted(el, { value }, { transition }) {
	        if (transition && value) {
	            transition.enter(el);
	        }
	    },
	    updated(el, { value, oldValue }, { transition }) {
	        if (!value === !oldValue)
	            return;
	        if (transition) {
	            if (value) {
	                transition.beforeEnter(el);
	                setDisplay(el, true);
	                transition.enter(el);
	            }
	            else {
	                transition.leave(el, () => {
	                    setDisplay(el, false);
	                });
	            }
	        }
	        else {
	            setDisplay(el, value);
	        }
	    },
	    beforeUnmount(el, { value }) {
	        setDisplay(el, value);
	    }
	};
	function setDisplay(el, value) {
	    el.style.display = value ? el._vod : 'none';
	}

	const rendererOptions = /*#__PURE__*/ extend({ patchProp }, nodeOps);
	// lazy create the renderer - this makes core renderer logic tree-shakable
	// in case the user only imports reactivity utilities from Vue.
	let renderer;
	let enabledHydration = false;
	function ensureRenderer() {
	    return (renderer ||
	        (renderer = createRenderer(rendererOptions)));
	}
	function ensureHydrationRenderer() {
	    renderer = enabledHydration
	        ? renderer
	        : createHydrationRenderer(rendererOptions);
	    enabledHydration = true;
	    return renderer;
	}
	// use explicit type casts here to avoid import() calls in rolled-up d.ts
	const render$l = ((...args) => {
	    ensureRenderer().render(...args);
	});
	const hydrate = ((...args) => {
	    ensureHydrationRenderer().hydrate(...args);
	});
	const createApp = ((...args) => {
	    const app = ensureRenderer().createApp(...args);
	    {
	        injectNativeTagCheck(app);
	        injectCompilerOptionsCheck(app);
	    }
	    const { mount } = app;
	    app.mount = (containerOrSelector) => {
	        const container = normalizeContainer(containerOrSelector);
	        if (!container)
	            return;
	        const component = app._component;
	        if (!isFunction(component) && !component.render && !component.template) {
	            // __UNSAFE__
	            // Reason: potential execution of JS expressions in in-DOM template.
	            // The user must make sure the in-DOM template is trusted. If it's
	            // rendered by the server, the template should not contain any user data.
	            component.template = container.innerHTML;
	        }
	        // clear content before mounting
	        container.innerHTML = '';
	        const proxy = mount(container, false, container instanceof SVGElement);
	        if (container instanceof Element) {
	            container.removeAttribute('v-cloak');
	            container.setAttribute('data-v-app', '');
	        }
	        return proxy;
	    };
	    return app;
	});
	const createSSRApp = ((...args) => {
	    const app = ensureHydrationRenderer().createApp(...args);
	    {
	        injectNativeTagCheck(app);
	        injectCompilerOptionsCheck(app);
	    }
	    const { mount } = app;
	    app.mount = (containerOrSelector) => {
	        const container = normalizeContainer(containerOrSelector);
	        if (container) {
	            return mount(container, true, container instanceof SVGElement);
	        }
	    };
	    return app;
	});
	function injectNativeTagCheck(app) {
	    // Inject `isNativeTag`
	    // this is used for component name validation (dev only)
	    Object.defineProperty(app.config, 'isNativeTag', {
	        value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
	        writable: false
	    });
	}
	// dev only
	function injectCompilerOptionsCheck(app) {
	    if (isRuntimeOnly()) {
	        const isCustomElement = app.config.isCustomElement;
	        Object.defineProperty(app.config, 'isCustomElement', {
	            get() {
	                return isCustomElement;
	            },
	            set() {
	                warn$1(`The \`isCustomElement\` config option is deprecated. Use ` +
	                    `\`compilerOptions.isCustomElement\` instead.`);
	            }
	        });
	        const compilerOptions = app.config.compilerOptions;
	        const msg = `The \`compilerOptions\` config option is only respected when using ` +
	            `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
	            `Since you are using the runtime-only build, \`compilerOptions\` ` +
	            `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
	            `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
	            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
	            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
	        Object.defineProperty(app.config, 'compilerOptions', {
	            get() {
	                warn$1(msg);
	                return compilerOptions;
	            },
	            set() {
	                warn$1(msg);
	            }
	        });
	    }
	}
	function normalizeContainer(container) {
	    if (isString(container)) {
	        const res = document.querySelector(container);
	        if (!res) {
	            warn$1(`Failed to mount app: mount target selector "${container}" returned null.`);
	        }
	        return res;
	    }
	    if (window.ShadowRoot &&
	        container instanceof window.ShadowRoot &&
	        container.mode === 'closed') {
	        warn$1(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
	    }
	    return container;
	}
	/**
	 * @internal
	 */
	const initDirectivesForSSR = NOOP;

	var runtimeDom = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  render: render$l,
	  hydrate: hydrate,
	  createApp: createApp,
	  createSSRApp: createSSRApp,
	  initDirectivesForSSR: initDirectivesForSSR,
	  defineCustomElement: defineCustomElement,
	  defineSSRCustomElement: defineSSRCustomElement,
	  VueElement: VueElement,
	  useCssModule: useCssModule,
	  useCssVars: useCssVars,
	  Transition: Transition,
	  TransitionGroup: TransitionGroup,
	  vModelText: vModelText,
	  vModelCheckbox: vModelCheckbox,
	  vModelRadio: vModelRadio,
	  vModelSelect: vModelSelect,
	  vModelDynamic: vModelDynamic,
	  withModifiers: withModifiers,
	  withKeys: withKeys,
	  vShow: vShow,
	  reactive: reactive,
	  ref: ref,
	  readonly: readonly,
	  unref: unref,
	  proxyRefs: proxyRefs,
	  isRef: isRef,
	  toRef: toRef,
	  toRefs: toRefs,
	  isProxy: isProxy,
	  isReactive: isReactive,
	  isReadonly: isReadonly,
	  isShallow: isShallow,
	  customRef: customRef,
	  triggerRef: triggerRef,
	  shallowRef: shallowRef,
	  shallowReactive: shallowReactive,
	  shallowReadonly: shallowReadonly,
	  markRaw: markRaw,
	  toRaw: toRaw,
	  effect: effect,
	  stop: stop,
	  ReactiveEffect: ReactiveEffect,
	  effectScope: effectScope,
	  EffectScope: EffectScope,
	  getCurrentScope: getCurrentScope,
	  onScopeDispose: onScopeDispose,
	  computed: computed$1,
	  watch: watch,
	  watchEffect: watchEffect,
	  watchPostEffect: watchPostEffect,
	  watchSyncEffect: watchSyncEffect,
	  onBeforeMount: onBeforeMount,
	  onMounted: onMounted,
	  onBeforeUpdate: onBeforeUpdate,
	  onUpdated: onUpdated,
	  onBeforeUnmount: onBeforeUnmount,
	  onUnmounted: onUnmounted,
	  onActivated: onActivated,
	  onDeactivated: onDeactivated,
	  onRenderTracked: onRenderTracked,
	  onRenderTriggered: onRenderTriggered,
	  onErrorCaptured: onErrorCaptured,
	  onServerPrefetch: onServerPrefetch,
	  provide: provide,
	  inject: inject,
	  nextTick: nextTick,
	  defineComponent: defineComponent,
	  defineAsyncComponent: defineAsyncComponent,
	  useAttrs: useAttrs,
	  useSlots: useSlots,
	  defineProps: defineProps,
	  defineEmits: defineEmits,
	  defineExpose: defineExpose,
	  withDefaults: withDefaults,
	  mergeDefaults: mergeDefaults,
	  createPropsRestProxy: createPropsRestProxy,
	  withAsyncContext: withAsyncContext,
	  getCurrentInstance: getCurrentInstance,
	  h: h,
	  createVNode: createVNode,
	  cloneVNode: cloneVNode,
	  mergeProps: mergeProps,
	  isVNode: isVNode,
	  Fragment: Fragment,
	  Text: Text,
	  Comment: Comment,
	  Static: Static,
	  Teleport: Teleport,
	  Suspense: Suspense,
	  KeepAlive: KeepAlive,
	  BaseTransition: BaseTransition,
	  withDirectives: withDirectives,
	  useSSRContext: useSSRContext,
	  ssrContextKey: ssrContextKey,
	  createRenderer: createRenderer,
	  createHydrationRenderer: createHydrationRenderer,
	  queuePostFlushCb: queuePostFlushCb,
	  warn: warn$1,
	  handleError: handleError,
	  callWithErrorHandling: callWithErrorHandling,
	  callWithAsyncErrorHandling: callWithAsyncErrorHandling,
	  resolveComponent: resolveComponent,
	  resolveDirective: resolveDirective,
	  resolveDynamicComponent: resolveDynamicComponent,
	  registerRuntimeCompiler: registerRuntimeCompiler,
	  isRuntimeOnly: isRuntimeOnly,
	  useTransitionState: useTransitionState,
	  resolveTransitionHooks: resolveTransitionHooks,
	  setTransitionHooks: setTransitionHooks,
	  getTransitionRawChildren: getTransitionRawChildren,
	  initCustomFormatter: initCustomFormatter,
	  get devtools () { return devtools; },
	  setDevtoolsHook: setDevtoolsHook,
	  withCtx: withCtx,
	  pushScopeId: pushScopeId,
	  popScopeId: popScopeId,
	  withScopeId: withScopeId,
	  renderList: renderList,
	  toHandlers: toHandlers,
	  renderSlot: renderSlot,
	  createSlots: createSlots,
	  withMemo: withMemo,
	  isMemoSame: isMemoSame,
	  openBlock: openBlock,
	  createBlock: createBlock,
	  setBlockTracking: setBlockTracking,
	  createTextVNode: createTextVNode,
	  createCommentVNode: createCommentVNode,
	  createStaticVNode: createStaticVNode,
	  createElementVNode: createBaseVNode,
	  createElementBlock: createElementBlock,
	  guardReactiveProps: guardReactiveProps,
	  toDisplayString: toDisplayString,
	  camelize: camelize,
	  capitalize: capitalize,
	  toHandlerKey: toHandlerKey,
	  normalizeProps: normalizeProps,
	  normalizeClass: normalizeClass,
	  normalizeStyle: normalizeStyle,
	  transformVNodeArgs: transformVNodeArgs,
	  version: version,
	  ssrUtils: ssrUtils,
	  resolveFilter: resolveFilter,
	  compatUtils: compatUtils
	});

	function initDev() {
	    {
	        {
	            console.info(`You are running a development build of Vue.\n` +
	                `Make sure to use the production build (*.prod.js) when deploying for production.`);
	        }
	        initCustomFormatter();
	    }
	}

	function defaultOnError(error) {
	    throw error;
	}
	function defaultOnWarn(msg) {
	    console.warn(`[Vue warn] ${msg.message}`);
	}
	function createCompilerError(code, loc, messages, additionalMessage) {
	    const msg = (messages || errorMessages)[code] + (additionalMessage || ``)
	        ;
	    const error = new SyntaxError(String(msg));
	    error.code = code;
	    error.loc = loc;
	    return error;
	}
	const errorMessages = {
	    // parse errors
	    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
	    [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
	    [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
	    [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
	    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
	    [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
	    [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
	    [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
	    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
	    [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
	    [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
	    [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
	    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
	    [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
	    [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
	    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
	    [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
	    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
	    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
	    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
	    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
	    [20 /* UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
	    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
	    // Vue-specific parse errors
	    [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
	    [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
	    [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
	    [27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
	        'Note that dynamic directive argument cannot contain spaces.',
	    [26 /* X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',
	    // transform errors
	    [28 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
	    [29 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
	    [30 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
	    [31 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
	    [32 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
	    [33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
	    [34 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
	    [35 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
	    [36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
	    [37 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
	        `When there are multiple named slots, all slots should use <template> ` +
	        `syntax to avoid scope ambiguity.`,
	    [38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
	    [39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
	        `default slot. These children will be ignored.`,
	    [40 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
	    [41 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
	    [42 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
	    [43 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
	    [44 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
	    [45 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
	    // generic errors
	    [46 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
	    [47 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
	    [48 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
	    [49 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
	    // just to fulfill types
	    [50 /* __EXTEND_POINT__ */]: ``
	};

	const FRAGMENT = Symbol(`Fragment` );
	const TELEPORT = Symbol(`Teleport` );
	const SUSPENSE = Symbol(`Suspense` );
	const KEEP_ALIVE = Symbol(`KeepAlive` );
	const BASE_TRANSITION = Symbol(`BaseTransition` );
	const OPEN_BLOCK = Symbol(`openBlock` );
	const CREATE_BLOCK = Symbol(`createBlock` );
	const CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock` );
	const CREATE_VNODE = Symbol(`createVNode` );
	const CREATE_ELEMENT_VNODE = Symbol(`createElementVNode` );
	const CREATE_COMMENT = Symbol(`createCommentVNode` );
	const CREATE_TEXT = Symbol(`createTextVNode` );
	const CREATE_STATIC = Symbol(`createStaticVNode` );
	const RESOLVE_COMPONENT = Symbol(`resolveComponent` );
	const RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent` );
	const RESOLVE_DIRECTIVE = Symbol(`resolveDirective` );
	const RESOLVE_FILTER = Symbol(`resolveFilter` );
	const WITH_DIRECTIVES = Symbol(`withDirectives` );
	const RENDER_LIST = Symbol(`renderList` );
	const RENDER_SLOT = Symbol(`renderSlot` );
	const CREATE_SLOTS = Symbol(`createSlots` );
	const TO_DISPLAY_STRING = Symbol(`toDisplayString` );
	const MERGE_PROPS = Symbol(`mergeProps` );
	const NORMALIZE_CLASS = Symbol(`normalizeClass` );
	const NORMALIZE_STYLE = Symbol(`normalizeStyle` );
	const NORMALIZE_PROPS = Symbol(`normalizeProps` );
	const GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps` );
	const TO_HANDLERS = Symbol(`toHandlers` );
	const CAMELIZE = Symbol(`camelize` );
	const CAPITALIZE = Symbol(`capitalize` );
	const TO_HANDLER_KEY = Symbol(`toHandlerKey` );
	const SET_BLOCK_TRACKING = Symbol(`setBlockTracking` );
	const PUSH_SCOPE_ID = Symbol(`pushScopeId` );
	const POP_SCOPE_ID = Symbol(`popScopeId` );
	const WITH_CTX = Symbol(`withCtx` );
	const UNREF = Symbol(`unref` );
	const IS_REF = Symbol(`isRef` );
	const WITH_MEMO = Symbol(`withMemo` );
	const IS_MEMO_SAME = Symbol(`isMemoSame` );
	// Name mapping for runtime helpers that need to be imported from 'vue' in
	// generated code. Make sure these are correctly exported in the runtime!
	// Using `any` here because TS doesn't allow symbols as index type.
	const helperNameMap = {
	    [FRAGMENT]: `Fragment`,
	    [TELEPORT]: `Teleport`,
	    [SUSPENSE]: `Suspense`,
	    [KEEP_ALIVE]: `KeepAlive`,
	    [BASE_TRANSITION]: `BaseTransition`,
	    [OPEN_BLOCK]: `openBlock`,
	    [CREATE_BLOCK]: `createBlock`,
	    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
	    [CREATE_VNODE]: `createVNode`,
	    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
	    [CREATE_COMMENT]: `createCommentVNode`,
	    [CREATE_TEXT]: `createTextVNode`,
	    [CREATE_STATIC]: `createStaticVNode`,
	    [RESOLVE_COMPONENT]: `resolveComponent`,
	    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
	    [RESOLVE_DIRECTIVE]: `resolveDirective`,
	    [RESOLVE_FILTER]: `resolveFilter`,
	    [WITH_DIRECTIVES]: `withDirectives`,
	    [RENDER_LIST]: `renderList`,
	    [RENDER_SLOT]: `renderSlot`,
	    [CREATE_SLOTS]: `createSlots`,
	    [TO_DISPLAY_STRING]: `toDisplayString`,
	    [MERGE_PROPS]: `mergeProps`,
	    [NORMALIZE_CLASS]: `normalizeClass`,
	    [NORMALIZE_STYLE]: `normalizeStyle`,
	    [NORMALIZE_PROPS]: `normalizeProps`,
	    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
	    [TO_HANDLERS]: `toHandlers`,
	    [CAMELIZE]: `camelize`,
	    [CAPITALIZE]: `capitalize`,
	    [TO_HANDLER_KEY]: `toHandlerKey`,
	    [SET_BLOCK_TRACKING]: `setBlockTracking`,
	    [PUSH_SCOPE_ID]: `pushScopeId`,
	    [POP_SCOPE_ID]: `popScopeId`,
	    [WITH_CTX]: `withCtx`,
	    [UNREF]: `unref`,
	    [IS_REF]: `isRef`,
	    [WITH_MEMO]: `withMemo`,
	    [IS_MEMO_SAME]: `isMemoSame`
	};
	function registerRuntimeHelpers(helpers) {
	    Object.getOwnPropertySymbols(helpers).forEach(s => {
	        helperNameMap[s] = helpers[s];
	    });
	}

	// AST Utilities ---------------------------------------------------------------
	// Some expressions, e.g. sequence and conditional expressions, are never
	// associated with template nodes, so their source locations are just a stub.
	// Container types like CompoundExpression also don't need a real location.
	const locStub = {
	    source: '',
	    start: { line: 1, column: 1, offset: 0 },
	    end: { line: 1, column: 1, offset: 0 }
	};
	function createRoot(children, loc = locStub) {
	    return {
	        type: 0 /* ROOT */,
	        children,
	        helpers: [],
	        components: [],
	        directives: [],
	        hoists: [],
	        imports: [],
	        cached: 0,
	        temps: 0,
	        codegenNode: undefined,
	        loc
	    };
	}
	function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
	    if (context) {
	        if (isBlock) {
	            context.helper(OPEN_BLOCK);
	            context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
	        }
	        else {
	            context.helper(getVNodeHelper(context.inSSR, isComponent));
	        }
	        if (directives) {
	            context.helper(WITH_DIRECTIVES);
	        }
	    }
	    return {
	        type: 13 /* VNODE_CALL */,
	        tag,
	        props,
	        children,
	        patchFlag,
	        dynamicProps,
	        directives,
	        isBlock,
	        disableTracking,
	        isComponent,
	        loc
	    };
	}
	function createArrayExpression(elements, loc = locStub) {
	    return {
	        type: 17 /* JS_ARRAY_EXPRESSION */,
	        loc,
	        elements
	    };
	}
	function createObjectExpression(properties, loc = locStub) {
	    return {
	        type: 15 /* JS_OBJECT_EXPRESSION */,
	        loc,
	        properties
	    };
	}
	function createObjectProperty(key, value) {
	    return {
	        type: 16 /* JS_PROPERTY */,
	        loc: locStub,
	        key: isString(key) ? createSimpleExpression(key, true) : key,
	        value
	    };
	}
	function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* NOT_CONSTANT */) {
	    return {
	        type: 4 /* SIMPLE_EXPRESSION */,
	        loc,
	        content,
	        isStatic,
	        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType
	    };
	}
	function createCompoundExpression(children, loc = locStub) {
	    return {
	        type: 8 /* COMPOUND_EXPRESSION */,
	        loc,
	        children
	    };
	}
	function createCallExpression(callee, args = [], loc = locStub) {
	    return {
	        type: 14 /* JS_CALL_EXPRESSION */,
	        loc,
	        callee,
	        arguments: args
	    };
	}
	function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
	    return {
	        type: 18 /* JS_FUNCTION_EXPRESSION */,
	        params,
	        returns,
	        newline,
	        isSlot,
	        loc
	    };
	}
	function createConditionalExpression(test, consequent, alternate, newline = true) {
	    return {
	        type: 19 /* JS_CONDITIONAL_EXPRESSION */,
	        test,
	        consequent,
	        alternate,
	        newline,
	        loc: locStub
	    };
	}
	function createCacheExpression(index, value, isVNode = false) {
	    return {
	        type: 20 /* JS_CACHE_EXPRESSION */,
	        index,
	        value,
	        isVNode,
	        loc: locStub
	    };
	}
	function createBlockStatement(body) {
	    return {
	        type: 21 /* JS_BLOCK_STATEMENT */,
	        body,
	        loc: locStub
	    };
	}

	const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
	const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
	function isCoreComponent(tag) {
	    if (isBuiltInType(tag, 'Teleport')) {
	        return TELEPORT;
	    }
	    else if (isBuiltInType(tag, 'Suspense')) {
	        return SUSPENSE;
	    }
	    else if (isBuiltInType(tag, 'KeepAlive')) {
	        return KEEP_ALIVE;
	    }
	    else if (isBuiltInType(tag, 'BaseTransition')) {
	        return BASE_TRANSITION;
	    }
	}
	const nonIdentifierRE = /^\d|[^\$\w]/;
	const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
	const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
	const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
	const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
	/**
	 * Simple lexer to check if an expression is a member expression. This is
	 * lax and only checks validity at the root level (i.e. does not validate exps
	 * inside square brackets), but it's ok since these are only used on template
	 * expressions and false positives are invalid expressions in the first place.
	 */
	const isMemberExpressionBrowser = (path) => {
	    // remove whitespaces around . or [ first
	    path = path.trim().replace(whitespaceRE, s => s.trim());
	    let state = 0 /* inMemberExp */;
	    let stateStack = [];
	    let currentOpenBracketCount = 0;
	    let currentOpenParensCount = 0;
	    let currentStringType = null;
	    for (let i = 0; i < path.length; i++) {
	        const char = path.charAt(i);
	        switch (state) {
	            case 0 /* inMemberExp */:
	                if (char === '[') {
	                    stateStack.push(state);
	                    state = 1 /* inBrackets */;
	                    currentOpenBracketCount++;
	                }
	                else if (char === '(') {
	                    stateStack.push(state);
	                    state = 2 /* inParens */;
	                    currentOpenParensCount++;
	                }
	                else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
	                    return false;
	                }
	                break;
	            case 1 /* inBrackets */:
	                if (char === `'` || char === `"` || char === '`') {
	                    stateStack.push(state);
	                    state = 3 /* inString */;
	                    currentStringType = char;
	                }
	                else if (char === `[`) {
	                    currentOpenBracketCount++;
	                }
	                else if (char === `]`) {
	                    if (!--currentOpenBracketCount) {
	                        state = stateStack.pop();
	                    }
	                }
	                break;
	            case 2 /* inParens */:
	                if (char === `'` || char === `"` || char === '`') {
	                    stateStack.push(state);
	                    state = 3 /* inString */;
	                    currentStringType = char;
	                }
	                else if (char === `(`) {
	                    currentOpenParensCount++;
	                }
	                else if (char === `)`) {
	                    // if the exp ends as a call then it should not be considered valid
	                    if (i === path.length - 1) {
	                        return false;
	                    }
	                    if (!--currentOpenParensCount) {
	                        state = stateStack.pop();
	                    }
	                }
	                break;
	            case 3 /* inString */:
	                if (char === currentStringType) {
	                    state = stateStack.pop();
	                    currentStringType = null;
	                }
	                break;
	        }
	    }
	    return !currentOpenBracketCount && !currentOpenParensCount;
	};
	const isMemberExpression = isMemberExpressionBrowser
	    ;
	function getInnerRange(loc, offset, length) {
	    const source = loc.source.slice(offset, offset + length);
	    const newLoc = {
	        source,
	        start: advancePositionWithClone(loc.start, loc.source, offset),
	        end: loc.end
	    };
	    if (length != null) {
	        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
	    }
	    return newLoc;
	}
	function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
	    return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
	}
	// advance by mutation without cloning (for performance reasons), since this
	// gets called a lot in the parser
	function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
	    let linesCount = 0;
	    let lastNewLinePos = -1;
	    for (let i = 0; i < numberOfCharacters; i++) {
	        if (source.charCodeAt(i) === 10 /* newline char code */) {
	            linesCount++;
	            lastNewLinePos = i;
	        }
	    }
	    pos.offset += numberOfCharacters;
	    pos.line += linesCount;
	    pos.column =
	        lastNewLinePos === -1
	            ? pos.column + numberOfCharacters
	            : numberOfCharacters - lastNewLinePos;
	    return pos;
	}
	function assert(condition, msg) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error(msg || `unexpected compiler condition`);
	    }
	}
	function findDir(node, name, allowEmpty = false) {
	    for (let i = 0; i < node.props.length; i++) {
	        const p = node.props[i];
	        if (p.type === 7 /* DIRECTIVE */ &&
	            (allowEmpty || p.exp) &&
	            (isString(name) ? p.name === name : name.test(p.name))) {
	            return p;
	        }
	    }
	}
	function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
	    for (let i = 0; i < node.props.length; i++) {
	        const p = node.props[i];
	        if (p.type === 6 /* ATTRIBUTE */) {
	            if (dynamicOnly)
	                continue;
	            if (p.name === name && (p.value || allowEmpty)) {
	                return p;
	            }
	        }
	        else if (p.name === 'bind' &&
	            (p.exp || allowEmpty) &&
	            isStaticArgOf(p.arg, name)) {
	            return p;
	        }
	    }
	}
	function isStaticArgOf(arg, name) {
	    return !!(arg && isStaticExp(arg) && arg.content === name);
	}
	function hasDynamicKeyVBind(node) {
	    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
	        p.name === 'bind' &&
	        (!p.arg || // v-bind="obj"
	            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
	            !p.arg.isStatic) // v-bind:[foo]
	    );
	}
	function isText(node) {
	    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
	}
	function isVSlot(p) {
	    return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
	}
	function isTemplateNode(node) {
	    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
	}
	function isSlotOutlet(node) {
	    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
	}
	function getVNodeHelper(ssr, isComponent) {
	    return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
	}
	function getVNodeBlockHelper(ssr, isComponent) {
	    return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
	}
	const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
	function getUnnormalizedProps(props, callPath = []) {
	    if (props &&
	        !isString(props) &&
	        props.type === 14 /* JS_CALL_EXPRESSION */) {
	        const callee = props.callee;
	        if (!isString(callee) && propsHelperSet.has(callee)) {
	            return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
	        }
	    }
	    return [props, callPath];
	}
	function injectProp(node, prop, context) {
	    let propsWithInjection;
	    /**
	     * 1. mergeProps(...)
	     * 2. toHandlers(...)
	     * 3. normalizeProps(...)
	     * 4. normalizeProps(guardReactiveProps(...))
	     *
	     * we need to get the real props before normalization
	     */
	    let props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
	    let callPath = [];
	    let parentCall;
	    if (props &&
	        !isString(props) &&
	        props.type === 14 /* JS_CALL_EXPRESSION */) {
	        const ret = getUnnormalizedProps(props);
	        props = ret[0];
	        callPath = ret[1];
	        parentCall = callPath[callPath.length - 1];
	    }
	    if (props == null || isString(props)) {
	        propsWithInjection = createObjectExpression([prop]);
	    }
	    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
	        // merged props... add ours
	        // only inject key to object literal if it's the first argument so that
	        // if doesn't override user provided keys
	        const first = props.arguments[0];
	        if (!isString(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {
	            first.properties.unshift(prop);
	        }
	        else {
	            if (props.callee === TO_HANDLERS) {
	                // #2366
	                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
	                    createObjectExpression([prop]),
	                    props
	                ]);
	            }
	            else {
	                props.arguments.unshift(createObjectExpression([prop]));
	            }
	        }
	        !propsWithInjection && (propsWithInjection = props);
	    }
	    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
	        let alreadyExists = false;
	        // check existing key to avoid overriding user provided keys
	        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
	            const propKeyName = prop.key.content;
	            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
	                p.key.content === propKeyName);
	        }
	        if (!alreadyExists) {
	            props.properties.unshift(prop);
	        }
	        propsWithInjection = props;
	    }
	    else {
	        // single v-bind with expression, return a merged replacement
	        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
	            createObjectExpression([prop]),
	            props
	        ]);
	        // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
	        // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
	        // the `guardReactiveProps` will no longer be needed
	        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
	            parentCall = callPath[callPath.length - 2];
	        }
	    }
	    if (node.type === 13 /* VNODE_CALL */) {
	        if (parentCall) {
	            parentCall.arguments[0] = propsWithInjection;
	        }
	        else {
	            node.props = propsWithInjection;
	        }
	    }
	    else {
	        if (parentCall) {
	            parentCall.arguments[0] = propsWithInjection;
	        }
	        else {
	            node.arguments[2] = propsWithInjection;
	        }
	    }
	}
	function toValidAssetId(name, type) {
	    // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
	    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
    })}`;
	}
	function getMemoedVNodeCall(node) {
	    if (node.type === 14 /* JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {
	        return node.arguments[1].returns;
	    }
	    else {
	        return node;
	    }
	}
	function makeBlock(node, { helper, removeHelper, inSSR }) {
	    if (!node.isBlock) {
	        node.isBlock = true;
	        removeHelper(getVNodeHelper(inSSR, node.isComponent));
	        helper(OPEN_BLOCK);
	        helper(getVNodeBlockHelper(inSSR, node.isComponent));
	    }
	}

	const deprecationData = {
	    ["COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */]: {
	        message: `Platform-native elements with "is" prop will no longer be ` +
	            `treated as components in Vue 3 unless the "is" value is explicitly ` +
	            `prefixed with "vue:".`,
	        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
	    },
	    ["COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */]: {
	        message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
	            `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
	            `\`v-model:${key}\`.`,
	        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
	    },
	    ["COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */]: {
	        message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
	            `Vue 3 will automatically set a binding as DOM property when appropriate.`
	    },
	    ["COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */]: {
	        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
	            `object spread: it will now overwrite an existing non-mergeable attribute ` +
	            `that appears before v-bind in the case of conflict. ` +
	            `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
	            `You can also suppress this warning if the usage is intended.`,
	        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
	    },
	    ["COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */]: {
	        message: `.native modifier for v-on has been removed as is no longer necessary.`,
	        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
	    },
	    ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
	        message: `v-if / v-for precedence when used on the same element has changed ` +
	            `in Vue 3: v-if now takes higher precedence and will no longer have ` +
	            `access to v-for scope variables. It is best to avoid the ambiguity ` +
	            `with <template> tags or use a computed property that filters v-for ` +
	            `data source.`,
	        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
	    },
	    ["COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */]: {
	        message: `<template> with no special directives will render as a native template ` +
	            `element instead of its inner content in Vue 3.`
	    },
	    ["COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */]: {
	        message: `"inline-template" has been removed in Vue 3.`,
	        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
	    },
	    ["COMPILER_FILTER" /* COMPILER_FILTERS */]: {
	        message: `filters have been removed in Vue 3. ` +
	            `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
	            `Use method calls or computed properties instead.`,
	        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
	    }
	};
	function getCompatValue(key, context) {
	    const config = context.options
	        ? context.options.compatConfig
	        : context.compatConfig;
	    const value = config && config[key];
	    if (key === 'MODE') {
	        return value || 3; // compiler defaults to v3 behavior
	    }
	    else {
	        return value;
	    }
	}
	function isCompatEnabled(key, context) {
	    const mode = getCompatValue('MODE', context);
	    const value = getCompatValue(key, context);
	    // in v3 mode, only enable if explicitly set to true
	    // otherwise enable for any non-false value
	    return mode === 3 ? value === true : value !== false;
	}
	function checkCompatEnabled(key, context, loc, ...args) {
	    const enabled = isCompatEnabled(key, context);
	    if (enabled) {
	        warnDeprecation(key, context, loc, ...args);
	    }
	    return enabled;
	}
	function warnDeprecation(key, context, loc, ...args) {
	    const val = getCompatValue(key, context);
	    if (val === 'suppress-warning') {
	        return;
	    }
	    const { message, link } = deprecationData[key];
	    const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
	    const err = new SyntaxError(msg);
	    err.code = key;
	    if (loc)
	        err.loc = loc;
	    context.onWarn(err);
	}

	// The default decoder only provides escapes for characters reserved as part of
	// the template syntax, and is only used if the custom renderer did not provide
	// a platform-specific decoder.
	const decodeRE = /&(gt|lt|amp|apos|quot);/g;
	const decodeMap = {
	    gt: '>',
	    lt: '<',
	    amp: '&',
	    apos: "'",
	    quot: '"'
	};
	const defaultParserOptions = {
	    delimiters: [`{{`, `}}`],
	    getNamespace: () => 0 /* HTML */,
	    getTextMode: () => 0 /* DATA */,
	    isVoidTag: NO,
	    isPreTag: NO,
	    isCustomElement: NO,
	    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
	    onError: defaultOnError,
	    onWarn: defaultOnWarn,
	    comments: true
	};
	function baseParse(content, options = {}) {
	    const context = createParserContext(content, options);
	    const start = getCursor(context);
	    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
	}
	function createParserContext(content, rawOptions) {
	    const options = extend({}, defaultParserOptions);
	    let key;
	    for (key in rawOptions) {
	        // @ts-ignore
	        options[key] =
	            rawOptions[key] === undefined
	                ? defaultParserOptions[key]
	                : rawOptions[key];
	    }
	    return {
	        options,
	        column: 1,
	        line: 1,
	        offset: 0,
	        originalSource: content,
	        source: content,
	        inPre: false,
	        inVPre: false,
	        onWarn: options.onWarn
	    };
	}
	function parseChildren(context, mode, ancestors) {
	    const parent = last(ancestors);
	    const ns = parent ? parent.ns : 0 /* HTML */;
	    const nodes = [];
	    while (!isEnd(context, mode, ancestors)) {
	        const s = context.source;
	        let node = undefined;
	        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
	            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
	                // '{{'
	                node = parseInterpolation(context, mode);
	            }
	            else if (mode === 0 /* DATA */ && s[0] === '<') {
	                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
	                if (s.length === 1) {
	                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
	                }
	                else if (s[1] === '!') {
	                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
	                    if (startsWith(s, '<!--')) {
	                        node = parseComment(context);
	                    }
	                    else if (startsWith(s, '<!DOCTYPE')) {
	                        // Ignore DOCTYPE by a limitation.
	                        node = parseBogusComment(context);
	                    }
	                    else if (startsWith(s, '<![CDATA[')) {
	                        if (ns !== 0 /* HTML */) {
	                            node = parseCDATA(context, ancestors);
	                        }
	                        else {
	                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
	                            node = parseBogusComment(context);
	                        }
	                    }
	                    else {
	                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
	                        node = parseBogusComment(context);
	                    }
	                }
	                else if (s[1] === '/') {
	                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
	                    if (s.length === 2) {
	                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
	                    }
	                    else if (s[2] === '>') {
	                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
	                        advanceBy(context, 3);
	                        continue;
	                    }
	                    else if (/[a-z]/i.test(s[2])) {
	                        emitError(context, 23 /* X_INVALID_END_TAG */);
	                        parseTag(context, 1 /* End */, parent);
	                        continue;
	                    }
	                    else {
	                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
	                        node = parseBogusComment(context);
	                    }
	                }
	                else if (/[a-z]/i.test(s[1])) {
	                    node = parseElement(context, ancestors);
	                }
	                else if (s[1] === '?') {
	                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
	                    node = parseBogusComment(context);
	                }
	                else {
	                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
	                }
	            }
	        }
	        if (!node) {
	            node = parseText(context, mode);
	        }
	        if (isArray(node)) {
	            for (let i = 0; i < node.length; i++) {
	                pushNode(nodes, node[i]);
	            }
	        }
	        else {
	            pushNode(nodes, node);
	        }
	    }
	    // Whitespace handling strategy like v2
	    let removedWhitespace = false;
	    if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {
	        const shouldCondense = context.options.whitespace !== 'preserve';
	        for (let i = 0; i < nodes.length; i++) {
	            const node = nodes[i];
	            if (!context.inPre && node.type === 2 /* TEXT */) {
	                if (!/[^\t\r\n\f ]/.test(node.content)) {
	                    const prev = nodes[i - 1];
	                    const next = nodes[i + 1];
	                    // Remove if:
	                    // - the whitespace is the first or last node, or:
	                    // - (condense mode) the whitespace is adjacent to a comment, or:
	                    // - (condense mode) the whitespace is between two elements AND contains newline
	                    if (!prev ||
	                        !next ||
	                        (shouldCondense &&
	                            (prev.type === 3 /* COMMENT */ ||
	                                next.type === 3 /* COMMENT */ ||
	                                (prev.type === 1 /* ELEMENT */ &&
	                                    next.type === 1 /* ELEMENT */ &&
	                                    /[\r\n]/.test(node.content))))) {
	                        removedWhitespace = true;
	                        nodes[i] = null;
	                    }
	                    else {
	                        // Otherwise, the whitespace is condensed into a single space
	                        node.content = ' ';
	                    }
	                }
	                else if (shouldCondense) {
	                    // in condense mode, consecutive whitespaces in text are condensed
	                    // down to a single space.
	                    node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
	                }
	            }
	            // Remove comment nodes if desired by configuration.
	            else if (node.type === 3 /* COMMENT */ && !context.options.comments) {
	                removedWhitespace = true;
	                nodes[i] = null;
	            }
	        }
	        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
	            // remove leading newline per html spec
	            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
	            const first = nodes[0];
	            if (first && first.type === 2 /* TEXT */) {
	                first.content = first.content.replace(/^\r?\n/, '');
	            }
	        }
	    }
	    return removedWhitespace ? nodes.filter(Boolean) : nodes;
	}
	function pushNode(nodes, node) {
	    if (node.type === 2 /* TEXT */) {
	        const prev = last(nodes);
	        // Merge if both this and the previous node are text and those are
	        // consecutive. This happens for cases like "a < b".
	        if (prev &&
	            prev.type === 2 /* TEXT */ &&
	            prev.loc.end.offset === node.loc.start.offset) {
	            prev.content += node.content;
	            prev.loc.end = node.loc.end;
	            prev.loc.source += node.loc.source;
	            return;
	        }
	    }
	    nodes.push(node);
	}
	function parseCDATA(context, ancestors) {
	    advanceBy(context, 9);
	    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
	    if (context.source.length === 0) {
	        emitError(context, 6 /* EOF_IN_CDATA */);
	    }
	    else {
	        advanceBy(context, 3);
	    }
	    return nodes;
	}
	function parseComment(context) {
	    const start = getCursor(context);
	    let content;
	    // Regular comment.
	    const match = /--(\!)?>/.exec(context.source);
	    if (!match) {
	        content = context.source.slice(4);
	        advanceBy(context, context.source.length);
	        emitError(context, 7 /* EOF_IN_COMMENT */);
	    }
	    else {
	        if (match.index <= 3) {
	            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
	        }
	        if (match[1]) {
	            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
	        }
	        content = context.source.slice(4, match.index);
	        // Advancing with reporting nested comments.
	        const s = context.source.slice(0, match.index);
	        let prevIndex = 1, nestedIndex = 0;
	        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
	            advanceBy(context, nestedIndex - prevIndex + 1);
	            if (nestedIndex + 4 < s.length) {
	                emitError(context, 16 /* NESTED_COMMENT */);
	            }
	            prevIndex = nestedIndex + 1;
	        }
	        advanceBy(context, match.index + match[0].length - prevIndex + 1);
	    }
	    return {
	        type: 3 /* COMMENT */,
	        content,
	        loc: getSelection(context, start)
	    };
	}
	function parseBogusComment(context) {
	    const start = getCursor(context);
	    const contentStart = context.source[1] === '?' ? 1 : 2;
	    let content;
	    const closeIndex = context.source.indexOf('>');
	    if (closeIndex === -1) {
	        content = context.source.slice(contentStart);
	        advanceBy(context, context.source.length);
	    }
	    else {
	        content = context.source.slice(contentStart, closeIndex);
	        advanceBy(context, closeIndex + 1);
	    }
	    return {
	        type: 3 /* COMMENT */,
	        content,
	        loc: getSelection(context, start)
	    };
	}
	function parseElement(context, ancestors) {
	    // Start tag.
	    const wasInPre = context.inPre;
	    const wasInVPre = context.inVPre;
	    const parent = last(ancestors);
	    const element = parseTag(context, 0 /* Start */, parent);
	    const isPreBoundary = context.inPre && !wasInPre;
	    const isVPreBoundary = context.inVPre && !wasInVPre;
	    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
	        // #4030 self-closing <pre> tag
	        if (isPreBoundary) {
	            context.inPre = false;
	        }
	        if (isVPreBoundary) {
	            context.inVPre = false;
	        }
	        return element;
	    }
	    // Children.
	    ancestors.push(element);
	    const mode = context.options.getTextMode(element, parent);
	    const children = parseChildren(context, mode, ancestors);
	    ancestors.pop();
	    element.children = children;
	    // End tag.
	    if (startsWithEndTagOpen(context.source, element.tag)) {
	        parseTag(context, 1 /* End */, parent);
	    }
	    else {
	        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
	        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
	            const first = children[0];
	            if (first && startsWith(first.loc.source, '<!--')) {
	                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
	            }
	        }
	    }
	    element.loc = getSelection(context, element.loc.start);
	    if (isPreBoundary) {
	        context.inPre = false;
	    }
	    if (isVPreBoundary) {
	        context.inVPre = false;
	    }
	    return element;
	}
	const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);
	function parseTag(context, type, parent) {
	    // Tag open.
	    const start = getCursor(context);
	    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
	    const tag = match[1];
	    const ns = context.options.getNamespace(tag, parent);
	    advanceBy(context, match[0].length);
	    advanceSpaces(context);
	    // save current state in case we need to re-parse attributes with v-pre
	    const cursor = getCursor(context);
	    const currentSource = context.source;
	    // check <pre> tag
	    if (context.options.isPreTag(tag)) {
	        context.inPre = true;
	    }
	    // Attributes.
	    let props = parseAttributes(context, type);
	    // check v-pre
	    if (type === 0 /* Start */ &&
	        !context.inVPre &&
	        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
	        context.inVPre = true;
	        // reset context
	        extend(context, cursor);
	        context.source = currentSource;
	        // re-parse attrs and filter out v-pre itself
	        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
	    }
	    // Tag close.
	    let isSelfClosing = false;
	    if (context.source.length === 0) {
	        emitError(context, 9 /* EOF_IN_TAG */);
	    }
	    else {
	        isSelfClosing = startsWith(context.source, '/>');
	        if (type === 1 /* End */ && isSelfClosing) {
	            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
	        }
	        advanceBy(context, isSelfClosing ? 2 : 1);
	    }
	    if (type === 1 /* End */) {
	        return;
	    }
	    let tagType = 0 /* ELEMENT */;
	    if (!context.inVPre) {
	        if (tag === 'slot') {
	            tagType = 2 /* SLOT */;
	        }
	        else if (tag === 'template') {
	            if (props.some(p => p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
	                tagType = 3 /* TEMPLATE */;
	            }
	        }
	        else if (isComponent(tag, props, context)) {
	            tagType = 1 /* COMPONENT */;
	        }
	    }
	    return {
	        type: 1 /* ELEMENT */,
	        ns,
	        tag,
	        tagType,
	        props,
	        isSelfClosing,
	        children: [],
	        loc: getSelection(context, start),
	        codegenNode: undefined // to be created during transform phase
	    };
	}
	function isComponent(tag, props, context) {
	    const options = context.options;
	    if (options.isCustomElement(tag)) {
	        return false;
	    }
	    if (tag === 'component' ||
	        /^[A-Z]/.test(tag) ||
	        isCoreComponent(tag) ||
	        (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
	        (options.isNativeTag && !options.isNativeTag(tag))) {
	        return true;
	    }
	    // at this point the tag should be a native tag, but check for potential "is"
	    // casting
	    for (let i = 0; i < props.length; i++) {
	        const p = props[i];
	        if (p.type === 6 /* ATTRIBUTE */) {
	            if (p.name === 'is' && p.value) {
	                if (p.value.content.startsWith('vue:')) {
	                    return true;
	                }
	            }
	        }
	        else {
	            // directive
	            // v-is (TODO Deprecate)
	            if (p.name === 'is') {
	                return true;
	            }
	            else if (
	            // :is on plain element - only treat as component in compat mode
	            p.name === 'bind' &&
	                isStaticArgOf(p.arg, 'is') &&
	                false &&
	                checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
	                return true;
	            }
	        }
	    }
	}
	function parseAttributes(context, type) {
	    const props = [];
	    const attributeNames = new Set();
	    while (context.source.length > 0 &&
	        !startsWith(context.source, '>') &&
	        !startsWith(context.source, '/>')) {
	        if (startsWith(context.source, '/')) {
	            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
	            advanceBy(context, 1);
	            advanceSpaces(context);
	            continue;
	        }
	        if (type === 1 /* End */) {
	            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
	        }
	        const attr = parseAttribute(context, attributeNames);
	        // Trim whitespace between class
	        // https://github.com/vuejs/core/issues/4251
	        if (attr.type === 6 /* ATTRIBUTE */ &&
	            attr.value &&
	            attr.name === 'class') {
	            attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
	        }
	        if (type === 0 /* Start */) {
	            props.push(attr);
	        }
	        if (/^[^\t\r\n\f />]/.test(context.source)) {
	            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
	        }
	        advanceSpaces(context);
	    }
	    return props;
	}
	function parseAttribute(context, nameSet) {
	    // Name.
	    const start = getCursor(context);
	    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
	    const name = match[0];
	    if (nameSet.has(name)) {
	        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
	    }
	    nameSet.add(name);
	    if (name[0] === '=') {
	        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
	    }
	    {
	        const pattern = /["'<]/g;
	        let m;
	        while ((m = pattern.exec(name))) {
	            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
	        }
	    }
	    advanceBy(context, name.length);
	    // Value
	    let value = undefined;
	    if (/^[\t\r\n\f ]*=/.test(context.source)) {
	        advanceSpaces(context);
	        advanceBy(context, 1);
	        advanceSpaces(context);
	        value = parseAttributeValue(context);
	        if (!value) {
	            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
	        }
	    }
	    const loc = getSelection(context, start);
	    if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
	        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
	        let isPropShorthand = startsWith(name, '.');
	        let dirName = match[1] ||
	            (isPropShorthand || startsWith(name, ':')
	                ? 'bind'
	                : startsWith(name, '@')
	                    ? 'on'
	                    : 'slot');
	        let arg;
	        if (match[2]) {
	            const isSlot = dirName === 'slot';
	            const startOffset = name.lastIndexOf(match[2]);
	            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
	            let content = match[2];
	            let isStatic = true;
	            if (content.startsWith('[')) {
	                isStatic = false;
	                if (!content.endsWith(']')) {
	                    emitError(context, 27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
	                    content = content.slice(1);
	                }
	                else {
	                    content = content.slice(1, content.length - 1);
	                }
	            }
	            else if (isSlot) {
	                // #1241 special case for v-slot: vuetify relies extensively on slot
	                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
	                // supports such usage so we are keeping it consistent with 2.x.
	                content += match[3] || '';
	            }
	            arg = {
	                type: 4 /* SIMPLE_EXPRESSION */,
	                content,
	                isStatic,
	                constType: isStatic
	                    ? 3 /* CAN_STRINGIFY */
	                    : 0 /* NOT_CONSTANT */,
	                loc
	            };
	        }
	        if (value && value.isQuoted) {
	            const valueLoc = value.loc;
	            valueLoc.start.offset++;
	            valueLoc.start.column++;
	            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
	            valueLoc.source = valueLoc.source.slice(1, -1);
	        }
	        const modifiers = match[3] ? match[3].slice(1).split('.') : [];
	        if (isPropShorthand)
	            modifiers.push('prop');
	        return {
	            type: 7 /* DIRECTIVE */,
	            name: dirName,
	            exp: value && {
	                type: 4 /* SIMPLE_EXPRESSION */,
	                content: value.content,
	                isStatic: false,
	                // Treat as non-constant by default. This can be potentially set to
	                // other values by `transformExpression` to make it eligible for hoisting.
	                constType: 0 /* NOT_CONSTANT */,
	                loc: value.loc
	            },
	            arg,
	            modifiers,
	            loc
	        };
	    }
	    // missing directive name or illegal directive name
	    if (!context.inVPre && startsWith(name, 'v-')) {
	        emitError(context, 26 /* X_MISSING_DIRECTIVE_NAME */);
	    }
	    return {
	        type: 6 /* ATTRIBUTE */,
	        name,
	        value: value && {
	            type: 2 /* TEXT */,
	            content: value.content,
	            loc: value.loc
	        },
	        loc
	    };
	}
	function parseAttributeValue(context) {
	    const start = getCursor(context);
	    let content;
	    const quote = context.source[0];
	    const isQuoted = quote === `"` || quote === `'`;
	    if (isQuoted) {
	        // Quoted value.
	        advanceBy(context, 1);
	        const endIndex = context.source.indexOf(quote);
	        if (endIndex === -1) {
	            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
	        }
	        else {
	            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
	            advanceBy(context, 1);
	        }
	    }
	    else {
	        // Unquoted
	        const match = /^[^\t\r\n\f >]+/.exec(context.source);
	        if (!match) {
	            return undefined;
	        }
	        const unexpectedChars = /["'<=`]/g;
	        let m;
	        while ((m = unexpectedChars.exec(match[0]))) {
	            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
	        }
	        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
	    }
	    return { content, isQuoted, loc: getSelection(context, start) };
	}
	function parseInterpolation(context, mode) {
	    const [open, close] = context.options.delimiters;
	    const closeIndex = context.source.indexOf(close, open.length);
	    if (closeIndex === -1) {
	        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
	        return undefined;
	    }
	    const start = getCursor(context);
	    advanceBy(context, open.length);
	    const innerStart = getCursor(context);
	    const innerEnd = getCursor(context);
	    const rawContentLength = closeIndex - open.length;
	    const rawContent = context.source.slice(0, rawContentLength);
	    const preTrimContent = parseTextData(context, rawContentLength, mode);
	    const content = preTrimContent.trim();
	    const startOffset = preTrimContent.indexOf(content);
	    if (startOffset > 0) {
	        advancePositionWithMutation(innerStart, rawContent, startOffset);
	    }
	    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
	    advancePositionWithMutation(innerEnd, rawContent, endOffset);
	    advanceBy(context, close.length);
	    return {
	        type: 5 /* INTERPOLATION */,
	        content: {
	            type: 4 /* SIMPLE_EXPRESSION */,
	            isStatic: false,
	            // Set `isConstant` to false by default and will decide in transformExpression
	            constType: 0 /* NOT_CONSTANT */,
	            content,
	            loc: getSelection(context, innerStart, innerEnd)
	        },
	        loc: getSelection(context, start)
	    };
	}
	function parseText(context, mode) {
	    const endTokens = mode === 3 /* CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];
	    let endIndex = context.source.length;
	    for (let i = 0; i < endTokens.length; i++) {
	        const index = context.source.indexOf(endTokens[i], 1);
	        if (index !== -1 && endIndex > index) {
	            endIndex = index;
	        }
	    }
	    const start = getCursor(context);
	    const content = parseTextData(context, endIndex, mode);
	    return {
	        type: 2 /* TEXT */,
	        content,
	        loc: getSelection(context, start)
	    };
	}
	/**
	 * Get text data with a given length from the current location.
	 * This translates HTML entities in the text data.
	 */
	function parseTextData(context, length, mode) {
	    const rawText = context.source.slice(0, length);
	    advanceBy(context, length);
	    if (mode === 2 /* RAWTEXT */ ||
	        mode === 3 /* CDATA */ ||
	        !rawText.includes('&')) {
	        return rawText;
	    }
	    else {
	        // DATA or RCDATA containing "&"". Entity decoding required.
	        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
	    }
	}
	function getCursor(context) {
	    const { column, line, offset } = context;
	    return { column, line, offset };
	}
	function getSelection(context, start, end) {
	    end = end || getCursor(context);
	    return {
	        start,
	        end,
	        source: context.originalSource.slice(start.offset, end.offset)
	    };
	}
	function last(xs) {
	    return xs[xs.length - 1];
	}
	function startsWith(source, searchString) {
	    return source.startsWith(searchString);
	}
	function advanceBy(context, numberOfCharacters) {
	    const { source } = context;
	    advancePositionWithMutation(context, source, numberOfCharacters);
	    context.source = source.slice(numberOfCharacters);
	}
	function advanceSpaces(context) {
	    const match = /^[\t\r\n\f ]+/.exec(context.source);
	    if (match) {
	        advanceBy(context, match[0].length);
	    }
	}
	function getNewPosition(context, start, numberOfCharacters) {
	    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
	}
	function emitError(context, code, offset, loc = getCursor(context)) {
	    if (offset) {
	        loc.offset += offset;
	        loc.column += offset;
	    }
	    context.options.onError(createCompilerError(code, {
	        start: loc,
	        end: loc,
	        source: ''
	    }));
	}
	function isEnd(context, mode, ancestors) {
	    const s = context.source;
	    switch (mode) {
	        case 0 /* DATA */:
	            if (startsWith(s, '</')) {
	                // TODO: probably bad performance
	                for (let i = ancestors.length - 1; i >= 0; --i) {
	                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {
	                        return true;
	                    }
	                }
	            }
	            break;
	        case 1 /* RCDATA */:
	        case 2 /* RAWTEXT */: {
	            const parent = last(ancestors);
	            if (parent && startsWithEndTagOpen(s, parent.tag)) {
	                return true;
	            }
	            break;
	        }
	        case 3 /* CDATA */:
	            if (startsWith(s, ']]>')) {
	                return true;
	            }
	            break;
	    }
	    return !s;
	}
	function startsWithEndTagOpen(source, tag) {
	    return (startsWith(source, '</') &&
	        source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
	        /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
	}

	function hoistStatic(root, context) {
	    walk(root, context, 
	    // Root node is unfortunately non-hoistable due to potential parent
	    // fallthrough attributes.
	    isSingleElementRoot(root, root.children[0]));
	}
	function isSingleElementRoot(root, child) {
	    const { children } = root;
	    return (children.length === 1 &&
	        child.type === 1 /* ELEMENT */ &&
	        !isSlotOutlet(child));
	}
	function walk(node, context, doNotHoistNode = false) {
	    const { children } = node;
	    const originalCount = children.length;
	    let hoistedCount = 0;
	    for (let i = 0; i < children.length; i++) {
	        const child = children[i];
	        // only plain elements & text calls are eligible for hoisting.
	        if (child.type === 1 /* ELEMENT */ &&
	            child.tagType === 0 /* ELEMENT */) {
	            const constantType = doNotHoistNode
	                ? 0 /* NOT_CONSTANT */
	                : getConstantType(child, context);
	            if (constantType > 0 /* NOT_CONSTANT */) {
	                if (constantType >= 2 /* CAN_HOIST */) {
	                    child.codegenNode.patchFlag =
	                        -1 /* HOISTED */ + (` /* HOISTED */` );
	                    child.codegenNode = context.hoist(child.codegenNode);
	                    hoistedCount++;
	                    continue;
	                }
	            }
	            else {
	                // node may contain dynamic children, but its props may be eligible for
	                // hoisting.
	                const codegenNode = child.codegenNode;
	                if (codegenNode.type === 13 /* VNODE_CALL */) {
	                    const flag = getPatchFlag(codegenNode);
	                    if ((!flag ||
	                        flag === 512 /* NEED_PATCH */ ||
	                        flag === 1 /* TEXT */) &&
	                        getGeneratedPropsConstantType(child, context) >=
	                            2 /* CAN_HOIST */) {
	                        const props = getNodeProps(child);
	                        if (props) {
	                            codegenNode.props = context.hoist(props);
	                        }
	                    }
	                    if (codegenNode.dynamicProps) {
	                        codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
	                    }
	                }
	            }
	        }
	        else if (child.type === 12 /* TEXT_CALL */ &&
	            getConstantType(child.content, context) >= 2 /* CAN_HOIST */) {
	            child.codegenNode = context.hoist(child.codegenNode);
	            hoistedCount++;
	        }
	        // walk further
	        if (child.type === 1 /* ELEMENT */) {
	            const isComponent = child.tagType === 1 /* COMPONENT */;
	            if (isComponent) {
	                context.scopes.vSlot++;
	            }
	            walk(child, context);
	            if (isComponent) {
	                context.scopes.vSlot--;
	            }
	        }
	        else if (child.type === 11 /* FOR */) {
	            // Do not hoist v-for single child because it has to be a block
	            walk(child, context, child.children.length === 1);
	        }
	        else if (child.type === 9 /* IF */) {
	            for (let i = 0; i < child.branches.length; i++) {
	                // Do not hoist v-if single child because it has to be a block
	                walk(child.branches[i], context, child.branches[i].children.length === 1);
	            }
	        }
	    }
	    if (hoistedCount && context.transformHoist) {
	        context.transformHoist(children, context, node);
	    }
	    // all children were hoisted - the entire children array is hoistable.
	    if (hoistedCount &&
	        hoistedCount === originalCount &&
	        node.type === 1 /* ELEMENT */ &&
	        node.tagType === 0 /* ELEMENT */ &&
	        node.codegenNode &&
	        node.codegenNode.type === 13 /* VNODE_CALL */ &&
	        isArray(node.codegenNode.children)) {
	        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
	    }
	}
	function getConstantType(node, context) {
	    const { constantCache } = context;
	    switch (node.type) {
	        case 1 /* ELEMENT */:
	            if (node.tagType !== 0 /* ELEMENT */) {
	                return 0 /* NOT_CONSTANT */;
	            }
	            const cached = constantCache.get(node);
	            if (cached !== undefined) {
	                return cached;
	            }
	            const codegenNode = node.codegenNode;
	            if (codegenNode.type !== 13 /* VNODE_CALL */) {
	                return 0 /* NOT_CONSTANT */;
	            }
	            if (codegenNode.isBlock &&
	                node.tag !== 'svg' &&
	                node.tag !== 'foreignObject') {
	                return 0 /* NOT_CONSTANT */;
	            }
	            const flag = getPatchFlag(codegenNode);
	            if (!flag) {
	                let returnType = 3 /* CAN_STRINGIFY */;
	                // Element itself has no patch flag. However we still need to check:
	                // 1. Even for a node with no patch flag, it is possible for it to contain
	                // non-hoistable expressions that refers to scope variables, e.g. compiler
	                // injected keys or cached event handlers. Therefore we need to always
	                // check the codegenNode's props to be sure.
	                const generatedPropsType = getGeneratedPropsConstantType(node, context);
	                if (generatedPropsType === 0 /* NOT_CONSTANT */) {
	                    constantCache.set(node, 0 /* NOT_CONSTANT */);
	                    return 0 /* NOT_CONSTANT */;
	                }
	                if (generatedPropsType < returnType) {
	                    returnType = generatedPropsType;
	                }
	                // 2. its children.
	                for (let i = 0; i < node.children.length; i++) {
	                    const childType = getConstantType(node.children[i], context);
	                    if (childType === 0 /* NOT_CONSTANT */) {
	                        constantCache.set(node, 0 /* NOT_CONSTANT */);
	                        return 0 /* NOT_CONSTANT */;
	                    }
	                    if (childType < returnType) {
	                        returnType = childType;
	                    }
	                }
	                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
	                // type, check if any of the props can cause the type to be lowered
	                // we can skip can_patch because it's guaranteed by the absence of a
	                // patchFlag.
	                if (returnType > 1 /* CAN_SKIP_PATCH */) {
	                    for (let i = 0; i < node.props.length; i++) {
	                        const p = node.props[i];
	                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {
	                            const expType = getConstantType(p.exp, context);
	                            if (expType === 0 /* NOT_CONSTANT */) {
	                                constantCache.set(node, 0 /* NOT_CONSTANT */);
	                                return 0 /* NOT_CONSTANT */;
	                            }
	                            if (expType < returnType) {
	                                returnType = expType;
	                            }
	                        }
	                    }
	                }
	                // only svg/foreignObject could be block here, however if they are
	                // static then they don't need to be blocks since there will be no
	                // nested updates.
	                if (codegenNode.isBlock) {
	                    // except set custom directives.
	                    for (let i = 0; i < node.props.length; i++) {
	                        const p = node.props[i];
	                        if (p.type === 7 /* DIRECTIVE */) {
	                            constantCache.set(node, 0 /* NOT_CONSTANT */);
	                            return 0 /* NOT_CONSTANT */;
	                        }
	                    }
	                    context.removeHelper(OPEN_BLOCK);
	                    context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
	                    codegenNode.isBlock = false;
	                    context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
	                }
	                constantCache.set(node, returnType);
	                return returnType;
	            }
	            else {
	                constantCache.set(node, 0 /* NOT_CONSTANT */);
	                return 0 /* NOT_CONSTANT */;
	            }
	        case 2 /* TEXT */:
	        case 3 /* COMMENT */:
	            return 3 /* CAN_STRINGIFY */;
	        case 9 /* IF */:
	        case 11 /* FOR */:
	        case 10 /* IF_BRANCH */:
	            return 0 /* NOT_CONSTANT */;
	        case 5 /* INTERPOLATION */:
	        case 12 /* TEXT_CALL */:
	            return getConstantType(node.content, context);
	        case 4 /* SIMPLE_EXPRESSION */:
	            return node.constType;
	        case 8 /* COMPOUND_EXPRESSION */:
	            let returnType = 3 /* CAN_STRINGIFY */;
	            for (let i = 0; i < node.children.length; i++) {
	                const child = node.children[i];
	                if (isString(child) || isSymbol(child)) {
	                    continue;
	                }
	                const childType = getConstantType(child, context);
	                if (childType === 0 /* NOT_CONSTANT */) {
	                    return 0 /* NOT_CONSTANT */;
	                }
	                else if (childType < returnType) {
	                    returnType = childType;
	                }
	            }
	            return returnType;
	        default:
	            return 0 /* NOT_CONSTANT */;
	    }
	}
	const allowHoistedHelperSet = new Set([
	    NORMALIZE_CLASS,
	    NORMALIZE_STYLE,
	    NORMALIZE_PROPS,
	    GUARD_REACTIVE_PROPS
	]);
	function getConstantTypeOfHelperCall(value, context) {
	    if (value.type === 14 /* JS_CALL_EXPRESSION */ &&
	        !isString(value.callee) &&
	        allowHoistedHelperSet.has(value.callee)) {
	        const arg = value.arguments[0];
	        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
	            return getConstantType(arg, context);
	        }
	        else if (arg.type === 14 /* JS_CALL_EXPRESSION */) {
	            // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
	            return getConstantTypeOfHelperCall(arg, context);
	        }
	    }
	    return 0 /* NOT_CONSTANT */;
	}
	function getGeneratedPropsConstantType(node, context) {
	    let returnType = 3 /* CAN_STRINGIFY */;
	    const props = getNodeProps(node);
	    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
	        const { properties } = props;
	        for (let i = 0; i < properties.length; i++) {
	            const { key, value } = properties[i];
	            const keyType = getConstantType(key, context);
	            if (keyType === 0 /* NOT_CONSTANT */) {
	                return keyType;
	            }
	            if (keyType < returnType) {
	                returnType = keyType;
	            }
	            let valueType;
	            if (value.type === 4 /* SIMPLE_EXPRESSION */) {
	                valueType = getConstantType(value, context);
	            }
	            else if (value.type === 14 /* JS_CALL_EXPRESSION */) {
	                // some helper calls can be hoisted,
	                // such as the `normalizeProps` generated by the compiler for pre-normalize class,
	                // in this case we need to respect the ConstantType of the helper's arguments
	                valueType = getConstantTypeOfHelperCall(value, context);
	            }
	            else {
	                valueType = 0 /* NOT_CONSTANT */;
	            }
	            if (valueType === 0 /* NOT_CONSTANT */) {
	                return valueType;
	            }
	            if (valueType < returnType) {
	                returnType = valueType;
	            }
	        }
	    }
	    return returnType;
	}
	function getNodeProps(node) {
	    const codegenNode = node.codegenNode;
	    if (codegenNode.type === 13 /* VNODE_CALL */) {
	        return codegenNode.props;
	    }
	}
	function getPatchFlag(node) {
	    const flag = node.patchFlag;
	    return flag ? parseInt(flag, 10) : undefined;
	}

	function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
	    const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
	    const context = {
	        // options
	        selfName: nameMatch && capitalize(camelize(nameMatch[1])),
	        prefixIdentifiers,
	        hoistStatic,
	        cacheHandlers,
	        nodeTransforms,
	        directiveTransforms,
	        transformHoist,
	        isBuiltInComponent,
	        isCustomElement,
	        expressionPlugins,
	        scopeId,
	        slotted,
	        ssr,
	        inSSR,
	        ssrCssVars,
	        bindingMetadata,
	        inline,
	        isTS,
	        onError,
	        onWarn,
	        compatConfig,
	        // state
	        root,
	        helpers: new Map(),
	        components: new Set(),
	        directives: new Set(),
	        hoists: [],
	        imports: [],
	        constantCache: new Map(),
	        temps: 0,
	        cached: 0,
	        identifiers: Object.create(null),
	        scopes: {
	            vFor: 0,
	            vSlot: 0,
	            vPre: 0,
	            vOnce: 0
	        },
	        parent: null,
	        currentNode: root,
	        childIndex: 0,
	        inVOnce: false,
	        // methods
	        helper(name) {
	            const count = context.helpers.get(name) || 0;
	            context.helpers.set(name, count + 1);
	            return name;
	        },
	        removeHelper(name) {
	            const count = context.helpers.get(name);
	            if (count) {
	                const currentCount = count - 1;
	                if (!currentCount) {
	                    context.helpers.delete(name);
	                }
	                else {
	                    context.helpers.set(name, currentCount);
	                }
	            }
	        },
	        helperString(name) {
	            return `_${helperNameMap[context.helper(name)]}`;
	        },
	        replaceNode(node) {
	            /* istanbul ignore if */
	            {
	                if (!context.currentNode) {
	                    throw new Error(`Node being replaced is already removed.`);
	                }
	                if (!context.parent) {
	                    throw new Error(`Cannot replace root node.`);
	                }
	            }
	            context.parent.children[context.childIndex] = context.currentNode = node;
	        },
	        removeNode(node) {
	            if (!context.parent) {
	                throw new Error(`Cannot remove root node.`);
	            }
	            const list = context.parent.children;
	            const removalIndex = node
	                ? list.indexOf(node)
	                : context.currentNode
	                    ? context.childIndex
	                    : -1;
	            /* istanbul ignore if */
	            if (removalIndex < 0) {
	                throw new Error(`node being removed is not a child of current parent`);
	            }
	            if (!node || node === context.currentNode) {
	                // current node removed
	                context.currentNode = null;
	                context.onNodeRemoved();
	            }
	            else {
	                // sibling node removed
	                if (context.childIndex > removalIndex) {
	                    context.childIndex--;
	                    context.onNodeRemoved();
	                }
	            }
	            context.parent.children.splice(removalIndex, 1);
	        },
	        onNodeRemoved: () => { },
	        addIdentifiers(exp) {
	        },
	        removeIdentifiers(exp) {
	        },
	        hoist(exp) {
	            if (isString(exp))
	                exp = createSimpleExpression(exp);
	            context.hoists.push(exp);
	            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);
	            identifier.hoisted = exp;
	            return identifier;
	        },
	        cache(exp, isVNode = false) {
	            return createCacheExpression(context.cached++, exp, isVNode);
	        }
	    };
	    return context;
	}
	function transform(root, options) {
	    const context = createTransformContext(root, options);
	    traverseNode(root, context);
	    if (options.hoistStatic) {
	        hoistStatic(root, context);
	    }
	    if (!options.ssr) {
	        createRootCodegen(root, context);
	    }
	    // finalize meta information
	    root.helpers = [...context.helpers.keys()];
	    root.components = [...context.components];
	    root.directives = [...context.directives];
	    root.imports = context.imports;
	    root.hoists = context.hoists;
	    root.temps = context.temps;
	    root.cached = context.cached;
	}
	function createRootCodegen(root, context) {
	    const { helper } = context;
	    const { children } = root;
	    if (children.length === 1) {
	        const child = children[0];
	        // if the single child is an element, turn it into a block.
	        if (isSingleElementRoot(root, child) && child.codegenNode) {
	            // single element root is never hoisted so codegenNode will never be
	            // SimpleExpressionNode
	            const codegenNode = child.codegenNode;
	            if (codegenNode.type === 13 /* VNODE_CALL */) {
	                makeBlock(codegenNode, context);
	            }
	            root.codegenNode = codegenNode;
	        }
	        else {
	            // - single <slot/>, IfNode, ForNode: already blocks.
	            // - single text node: always patched.
	            // root codegen falls through via genNode()
	            root.codegenNode = child;
	        }
	    }
	    else if (children.length > 1) {
	        // root has multiple nodes - return a fragment block.
	        let patchFlag = 64 /* STABLE_FRAGMENT */;
	        let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];
	        // check if the fragment actually contains a single valid child with
	        // the rest being comments
	        if (children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
	            patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
	            patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;
	        }
	        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, undefined, false /* isComponent */);
	    }
	    else ;
	}
	function traverseChildren(parent, context) {
	    let i = 0;
	    const nodeRemoved = () => {
	        i--;
	    };
	    for (; i < parent.children.length; i++) {
	        const child = parent.children[i];
	        if (isString(child))
	            continue;
	        context.parent = parent;
	        context.childIndex = i;
	        context.onNodeRemoved = nodeRemoved;
	        traverseNode(child, context);
	    }
	}
	function traverseNode(node, context) {
	    context.currentNode = node;
	    // apply transform plugins
	    const { nodeTransforms } = context;
	    const exitFns = [];
	    for (let i = 0; i < nodeTransforms.length; i++) {
	        const onExit = nodeTransforms[i](node, context);
	        if (onExit) {
	            if (isArray(onExit)) {
	                exitFns.push(...onExit);
	            }
	            else {
	                exitFns.push(onExit);
	            }
	        }
	        if (!context.currentNode) {
	            // node was removed
	            return;
	        }
	        else {
	            // node may have been replaced
	            node = context.currentNode;
	        }
	    }
	    switch (node.type) {
	        case 3 /* COMMENT */:
	            if (!context.ssr) {
	                // inject import for the Comment symbol, which is needed for creating
	                // comment nodes with `createVNode`
	                context.helper(CREATE_COMMENT);
	            }
	            break;
	        case 5 /* INTERPOLATION */:
	            // no need to traverse, but we need to inject toString helper
	            if (!context.ssr) {
	                context.helper(TO_DISPLAY_STRING);
	            }
	            break;
	        // for container types, further traverse downwards
	        case 9 /* IF */:
	            for (let i = 0; i < node.branches.length; i++) {
	                traverseNode(node.branches[i], context);
	            }
	            break;
	        case 10 /* IF_BRANCH */:
	        case 11 /* FOR */:
	        case 1 /* ELEMENT */:
	        case 0 /* ROOT */:
	            traverseChildren(node, context);
	            break;
	    }
	    // exit transforms
	    context.currentNode = node;
	    let i = exitFns.length;
	    while (i--) {
	        exitFns[i]();
	    }
	}
	function createStructuralDirectiveTransform(name, fn) {
	    const matches = isString(name)
	        ? (n) => n === name
	        : (n) => name.test(n);
	    return (node, context) => {
	        if (node.type === 1 /* ELEMENT */) {
	            const { props } = node;
	            // structural directive transforms are not concerned with slots
	            // as they are handled separately in vSlot.ts
	            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
	                return;
	            }
	            const exitFns = [];
	            for (let i = 0; i < props.length; i++) {
	                const prop = props[i];
	                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
	                    // structural directives are removed to avoid infinite recursion
	                    // also we remove them *before* applying so that it can further
	                    // traverse itself in case it moves the node around
	                    props.splice(i, 1);
	                    i--;
	                    const onExit = fn(node, prop, context);
	                    if (onExit)
	                        exitFns.push(onExit);
	                }
	            }
	            return exitFns;
	        }
	    };
	}

	const PURE_ANNOTATION = `/*#__PURE__*/`;
	const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
	function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {
	    const context = {
	        mode,
	        prefixIdentifiers,
	        sourceMap,
	        filename,
	        scopeId,
	        optimizeImports,
	        runtimeGlobalName,
	        runtimeModuleName,
	        ssrRuntimeModuleName,
	        ssr,
	        isTS,
	        inSSR,
	        source: ast.loc.source,
	        code: ``,
	        column: 1,
	        line: 1,
	        offset: 0,
	        indentLevel: 0,
	        pure: false,
	        map: undefined,
	        helper(key) {
	            return `_${helperNameMap[key]}`;
	        },
	        push(code, node) {
	            context.code += code;
	        },
	        indent() {
	            newline(++context.indentLevel);
	        },
	        deindent(withoutNewLine = false) {
	            if (withoutNewLine) {
	                --context.indentLevel;
	            }
	            else {
	                newline(--context.indentLevel);
	            }
	        },
	        newline() {
	            newline(context.indentLevel);
	        }
	    };
	    function newline(n) {
	        context.push('\n' + `  `.repeat(n));
	    }
	    return context;
	}
	function generate(ast, options = {}) {
	    const context = createCodegenContext(ast, options);
	    if (options.onContextCreated)
	        options.onContextCreated(context);
	    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
	    const hasHelpers = ast.helpers.length > 0;
	    const useWithBlock = !prefixIdentifiers && mode !== 'module';
	    // preambles
	    // in setup() inline mode, the preamble is generated in a sub context
	    // and returned separately.
	    const preambleContext = context;
	    {
	        genFunctionPreamble(ast, preambleContext);
	    }
	    // enter render function
	    const functionName = ssr ? `ssrRender` : `render`;
	    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
	    const signature = args.join(', ');
	    {
	        push(`function ${functionName}(${signature}) {`);
	    }
	    indent();
	    if (useWithBlock) {
	        push(`with (_ctx) {`);
	        indent();
	        // function mode const declarations should be inside with block
	        // also they should be renamed to avoid collision with user properties
	        if (hasHelpers) {
	            push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`);
	            push(`\n`);
	            newline();
	        }
	    }
	    // generate asset resolution statements
	    if (ast.components.length) {
	        genAssets(ast.components, 'component', context);
	        if (ast.directives.length || ast.temps > 0) {
	            newline();
	        }
	    }
	    if (ast.directives.length) {
	        genAssets(ast.directives, 'directive', context);
	        if (ast.temps > 0) {
	            newline();
	        }
	    }
	    if (ast.temps > 0) {
	        push(`let `);
	        for (let i = 0; i < ast.temps; i++) {
	            push(`${i > 0 ? `, ` : ``}_temp${i}`);
	        }
	    }
	    if (ast.components.length || ast.directives.length || ast.temps) {
	        push(`\n`);
	        newline();
	    }
	    // generate the VNode tree expression
	    if (!ssr) {
	        push(`return `);
	    }
	    if (ast.codegenNode) {
	        genNode(ast.codegenNode, context);
	    }
	    else {
	        push(`null`);
	    }
	    if (useWithBlock) {
	        deindent();
	        push(`}`);
	    }
	    deindent();
	    push(`}`);
	    return {
	        ast,
	        code: context.code,
	        preamble: ``,
	        // SourceMapGenerator does have toJSON() method but it's not in the types
	        map: context.map ? context.map.toJSON() : undefined
	    };
	}
	function genFunctionPreamble(ast, context) {
	    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
	    const VueBinding = runtimeGlobalName;
	    // Generate const declaration for helpers
	    // In prefix mode, we place the const declaration at top so it's done
	    // only once; But if we not prefixing, we place the declaration inside the
	    // with block so it doesn't incur the `in` check cost for every helper access.
	    if (ast.helpers.length > 0) {
	        {
	            // "with" mode.
	            // save Vue in a separate variable to avoid collision
	            push(`const _Vue = ${VueBinding}\n`);
	            // in "with" mode, helpers are declared inside the with block to avoid
	            // has check cost, but hoists are lifted out of the function - we need
	            // to provide the helper here.
	            if (ast.hoists.length) {
	                const staticHelpers = [
	                    CREATE_VNODE,
	                    CREATE_ELEMENT_VNODE,
	                    CREATE_COMMENT,
	                    CREATE_TEXT,
	                    CREATE_STATIC
	                ]
	                    .filter(helper => ast.helpers.includes(helper))
	                    .map(aliasHelper)
	                    .join(', ');
	                push(`const { ${staticHelpers} } = _Vue\n`);
	            }
	        }
	    }
	    genHoists(ast.hoists, context);
	    newline();
	    push(`return `);
	}
	function genAssets(assets, type, { helper, push, newline, isTS }) {
	    const resolver = helper(type === 'component'
	            ? RESOLVE_COMPONENT
	            : RESOLVE_DIRECTIVE);
	    for (let i = 0; i < assets.length; i++) {
	        let id = assets[i];
	        // potential component implicit self-reference inferred from SFC filename
	        const maybeSelfReference = id.endsWith('__self');
	        if (maybeSelfReference) {
	            id = id.slice(0, -6);
	        }
	        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
	        if (i < assets.length - 1) {
	            newline();
	        }
	    }
	}
	function genHoists(hoists, context) {
	    if (!hoists.length) {
	        return;
	    }
	    context.pure = true;
	    const { push, newline, helper, scopeId, mode } = context;
	    newline();
	    for (let i = 0; i < hoists.length; i++) {
	        const exp = hoists[i];
	        if (exp) {
	            push(`const _hoisted_${i + 1} = ${``}`);
	            genNode(exp, context);
	            newline();
	        }
	    }
	    context.pure = false;
	}
	function isText$1(n) {
	    return (isString(n) ||
	        n.type === 4 /* SIMPLE_EXPRESSION */ ||
	        n.type === 2 /* TEXT */ ||
	        n.type === 5 /* INTERPOLATION */ ||
	        n.type === 8 /* COMPOUND_EXPRESSION */);
	}
	function genNodeListAsArray(nodes, context) {
	    const multilines = nodes.length > 3 ||
	        (nodes.some(n => isArray(n) || !isText$1(n)));
	    context.push(`[`);
	    multilines && context.indent();
	    genNodeList(nodes, context, multilines);
	    multilines && context.deindent();
	    context.push(`]`);
	}
	function genNodeList(nodes, context, multilines = false, comma = true) {
	    const { push, newline } = context;
	    for (let i = 0; i < nodes.length; i++) {
	        const node = nodes[i];
	        if (isString(node)) {
	            push(node);
	        }
	        else if (isArray(node)) {
	            genNodeListAsArray(node, context);
	        }
	        else {
	            genNode(node, context);
	        }
	        if (i < nodes.length - 1) {
	            if (multilines) {
	                comma && push(',');
	                newline();
	            }
	            else {
	                comma && push(', ');
	            }
	        }
	    }
	}
	function genNode(node, context) {
	    if (isString(node)) {
	        context.push(node);
	        return;
	    }
	    if (isSymbol(node)) {
	        context.push(context.helper(node));
	        return;
	    }
	    switch (node.type) {
	        case 1 /* ELEMENT */:
	        case 9 /* IF */:
	        case 11 /* FOR */:
	            assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
	                    `Apply appropriate transforms first.`);
	            genNode(node.codegenNode, context);
	            break;
	        case 2 /* TEXT */:
	            genText(node, context);
	            break;
	        case 4 /* SIMPLE_EXPRESSION */:
	            genExpression(node, context);
	            break;
	        case 5 /* INTERPOLATION */:
	            genInterpolation(node, context);
	            break;
	        case 12 /* TEXT_CALL */:
	            genNode(node.codegenNode, context);
	            break;
	        case 8 /* COMPOUND_EXPRESSION */:
	            genCompoundExpression(node, context);
	            break;
	        case 3 /* COMMENT */:
	            genComment(node, context);
	            break;
	        case 13 /* VNODE_CALL */:
	            genVNodeCall(node, context);
	            break;
	        case 14 /* JS_CALL_EXPRESSION */:
	            genCallExpression(node, context);
	            break;
	        case 15 /* JS_OBJECT_EXPRESSION */:
	            genObjectExpression(node, context);
	            break;
	        case 17 /* JS_ARRAY_EXPRESSION */:
	            genArrayExpression(node, context);
	            break;
	        case 18 /* JS_FUNCTION_EXPRESSION */:
	            genFunctionExpression(node, context);
	            break;
	        case 19 /* JS_CONDITIONAL_EXPRESSION */:
	            genConditionalExpression(node, context);
	            break;
	        case 20 /* JS_CACHE_EXPRESSION */:
	            genCacheExpression(node, context);
	            break;
	        case 21 /* JS_BLOCK_STATEMENT */:
	            genNodeList(node.body, context, true, false);
	            break;
	        // SSR only types
	        case 22 /* JS_TEMPLATE_LITERAL */:
	            break;
	        case 23 /* JS_IF_STATEMENT */:
	            break;
	        case 24 /* JS_ASSIGNMENT_EXPRESSION */:
	            break;
	        case 25 /* JS_SEQUENCE_EXPRESSION */:
	            break;
	        case 26 /* JS_RETURN_STATEMENT */:
	            break;
	        /* istanbul ignore next */
	        case 10 /* IF_BRANCH */:
	            // noop
	            break;
	        default:
	            {
	                assert(false, `unhandled codegen node type: ${node.type}`);
	                // make sure we exhaust all possible types
	                const exhaustiveCheck = node;
	                return exhaustiveCheck;
	            }
	    }
	}
	function genText(node, context) {
	    context.push(JSON.stringify(node.content), node);
	}
	function genExpression(node, context) {
	    const { content, isStatic } = node;
	    context.push(isStatic ? JSON.stringify(content) : content, node);
	}
	function genInterpolation(node, context) {
	    const { push, helper, pure } = context;
	    if (pure)
	        push(PURE_ANNOTATION);
	    push(`${helper(TO_DISPLAY_STRING)}(`);
	    genNode(node.content, context);
	    push(`)`);
	}
	function genCompoundExpression(node, context) {
	    for (let i = 0; i < node.children.length; i++) {
	        const child = node.children[i];
	        if (isString(child)) {
	            context.push(child);
	        }
	        else {
	            genNode(child, context);
	        }
	    }
	}
	function genExpressionAsPropertyKey(node, context) {
	    const { push } = context;
	    if (node.type === 8 /* COMPOUND_EXPRESSION */) {
	        push(`[`);
	        genCompoundExpression(node, context);
	        push(`]`);
	    }
	    else if (node.isStatic) {
	        // only quote keys if necessary
	        const text = isSimpleIdentifier(node.content)
	            ? node.content
	            : JSON.stringify(node.content);
	        push(text, node);
	    }
	    else {
	        push(`[${node.content}]`, node);
	    }
	}
	function genComment(node, context) {
	    const { push, helper, pure } = context;
	    if (pure) {
	        push(PURE_ANNOTATION);
	    }
	    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
	}
	function genVNodeCall(node, context) {
	    const { push, helper, pure } = context;
	    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
	    if (directives) {
	        push(helper(WITH_DIRECTIVES) + `(`);
	    }
	    if (isBlock) {
	        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
	    }
	    if (pure) {
	        push(PURE_ANNOTATION);
	    }
	    const callHelper = isBlock
	        ? getVNodeBlockHelper(context.inSSR, isComponent)
	        : getVNodeHelper(context.inSSR, isComponent);
	    push(helper(callHelper) + `(`, node);
	    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
	    push(`)`);
	    if (isBlock) {
	        push(`)`);
	    }
	    if (directives) {
	        push(`, `);
	        genNode(directives, context);
	        push(`)`);
	    }
	}
	function genNullableArgs(args) {
	    let i = args.length;
	    while (i--) {
	        if (args[i] != null)
	            break;
	    }
	    return args.slice(0, i + 1).map(arg => arg || `null`);
	}
	// JavaScript
	function genCallExpression(node, context) {
	    const { push, helper, pure } = context;
	    const callee = isString(node.callee) ? node.callee : helper(node.callee);
	    if (pure) {
	        push(PURE_ANNOTATION);
	    }
	    push(callee + `(`, node);
	    genNodeList(node.arguments, context);
	    push(`)`);
	}
	function genObjectExpression(node, context) {
	    const { push, indent, deindent, newline } = context;
	    const { properties } = node;
	    if (!properties.length) {
	        push(`{}`, node);
	        return;
	    }
	    const multilines = properties.length > 1 ||
	        (properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));
	    push(multilines ? `{` : `{ `);
	    multilines && indent();
	    for (let i = 0; i < properties.length; i++) {
	        const { key, value } = properties[i];
	        // key
	        genExpressionAsPropertyKey(key, context);
	        push(`: `);
	        // value
	        genNode(value, context);
	        if (i < properties.length - 1) {
	            // will only reach this if it's multilines
	            push(`,`);
	            newline();
	        }
	    }
	    multilines && deindent();
	    push(multilines ? `}` : ` }`);
	}
	function genArrayExpression(node, context) {
	    genNodeListAsArray(node.elements, context);
	}
	function genFunctionExpression(node, context) {
	    const { push, indent, deindent } = context;
	    const { params, returns, body, newline, isSlot } = node;
	    if (isSlot) {
	        // wrap slot functions with owner context
	        push(`_${helperNameMap[WITH_CTX]}(`);
	    }
	    push(`(`, node);
	    if (isArray(params)) {
	        genNodeList(params, context);
	    }
	    else if (params) {
	        genNode(params, context);
	    }
	    push(`) => `);
	    if (newline || body) {
	        push(`{`);
	        indent();
	    }
	    if (returns) {
	        if (newline) {
	            push(`return `);
	        }
	        if (isArray(returns)) {
	            genNodeListAsArray(returns, context);
	        }
	        else {
	            genNode(returns, context);
	        }
	    }
	    else if (body) {
	        genNode(body, context);
	    }
	    if (newline || body) {
	        deindent();
	        push(`}`);
	    }
	    if (isSlot) {
	        push(`)`);
	    }
	}
	function genConditionalExpression(node, context) {
	    const { test, consequent, alternate, newline: needNewline } = node;
	    const { push, indent, deindent, newline } = context;
	    if (test.type === 4 /* SIMPLE_EXPRESSION */) {
	        const needsParens = !isSimpleIdentifier(test.content);
	        needsParens && push(`(`);
	        genExpression(test, context);
	        needsParens && push(`)`);
	    }
	    else {
	        push(`(`);
	        genNode(test, context);
	        push(`)`);
	    }
	    needNewline && indent();
	    context.indentLevel++;
	    needNewline || push(` `);
	    push(`? `);
	    genNode(consequent, context);
	    context.indentLevel--;
	    needNewline && newline();
	    needNewline || push(` `);
	    push(`: `);
	    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
	    if (!isNested) {
	        context.indentLevel++;
	    }
	    genNode(alternate, context);
	    if (!isNested) {
	        context.indentLevel--;
	    }
	    needNewline && deindent(true /* without newline */);
	}
	function genCacheExpression(node, context) {
	    const { push, helper, indent, deindent, newline } = context;
	    push(`_cache[${node.index}] || (`);
	    if (node.isVNode) {
	        indent();
	        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
	        newline();
	    }
	    push(`_cache[${node.index}] = `);
	    genNode(node.value, context);
	    if (node.isVNode) {
	        push(`,`);
	        newline();
	        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
	        newline();
	        push(`_cache[${node.index}]`);
	        deindent();
	    }
	    push(`)`);
	}

	// these keywords should not appear inside expressions, but operators like
	// typeof, instanceof and in are allowed
	const prohibitedKeywordRE = new RegExp('\\b' +
	    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
	        'super,throw,while,yield,delete,export,import,return,switch,default,' +
	        'extends,finally,continue,debugger,function,arguments,typeof,void')
	        .split(',')
	        .join('\\b|\\b') +
	    '\\b');
	// strip strings in expressions
	const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
	/**
	 * Validate a non-prefixed expression.
	 * This is only called when using the in-browser runtime compiler since it
	 * doesn't prefix expressions.
	 */
	function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
	    const exp = node.content;
	    // empty expressions are validated per-directive since some directives
	    // do allow empty expressions.
	    if (!exp.trim()) {
	        return;
	    }
	    try {
	        new Function(asRawStatements
	            ? ` ${exp} `
	            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
	    }
	    catch (e) {
	        let message = e.message;
	        const keywordMatch = exp
	            .replace(stripStringRE, '')
	            .match(prohibitedKeywordRE);
	        if (keywordMatch) {
	            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
	        }
	        context.onError(createCompilerError(44 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));
	    }
	}

	const transformExpression = (node, context) => {
	    if (node.type === 5 /* INTERPOLATION */) {
	        node.content = processExpression(node.content, context);
	    }
	    else if (node.type === 1 /* ELEMENT */) {
	        // handle directives on element
	        for (let i = 0; i < node.props.length; i++) {
	            const dir = node.props[i];
	            // do not process for v-on & v-for since they are special handled
	            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
	                const exp = dir.exp;
	                const arg = dir.arg;
	                // do not process exp if this is v-on:arg - we need special handling
	                // for wrapping inline statements.
	                if (exp &&
	                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&
	                    !(dir.name === 'on' && arg)) {
	                    dir.exp = processExpression(exp, context, 
	                    // slot args must be processed as function params
	                    dir.name === 'slot');
	                }
	                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {
	                    dir.arg = processExpression(arg, context);
	                }
	            }
	        }
	    }
	};
	// Important: since this function uses Node.js only dependencies, it should
	// always be used with a leading !true check so that it can be
	// tree-shaken from the browser build.
	function processExpression(node, context, 
	// some expressions like v-slot props & v-for aliases should be parsed as
	// function params
	asParams = false, 
	// v-on handler values may contain multiple statements
	asRawStatements = false, localVars = Object.create(context.identifiers)) {
	    {
	        {
	            // simple in-browser validation (same logic in 2.x)
	            validateBrowserExpression(node, context, asParams, asRawStatements);
	        }
	        return node;
	    }
	}

	const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
	    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
	        // #1587: We need to dynamically increment the key based on the current
	        // node's sibling nodes, since chained v-if/else branches are
	        // rendered at the same depth
	        const siblings = context.parent.children;
	        let i = siblings.indexOf(ifNode);
	        let key = 0;
	        while (i-- >= 0) {
	            const sibling = siblings[i];
	            if (sibling && sibling.type === 9 /* IF */) {
	                key += sibling.branches.length;
	            }
	        }
	        // Exit callback. Complete the codegenNode when all children have been
	        // transformed.
	        return () => {
	            if (isRoot) {
	                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
	            }
	            else {
	                // attach this branch's codegen node to the v-if root.
	                const parentCondition = getParentCondition(ifNode.codegenNode);
	                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
	            }
	        };
	    });
	});
	// target-agnostic transform used for both Client and SSR
	function processIf(node, dir, context, processCodegen) {
	    if (dir.name !== 'else' &&
	        (!dir.exp || !dir.exp.content.trim())) {
	        const loc = dir.exp ? dir.exp.loc : node.loc;
	        context.onError(createCompilerError(28 /* X_V_IF_NO_EXPRESSION */, dir.loc));
	        dir.exp = createSimpleExpression(`true`, false, loc);
	    }
	    if (dir.exp) {
	        validateBrowserExpression(dir.exp, context);
	    }
	    if (dir.name === 'if') {
	        const branch = createIfBranch(node, dir);
	        const ifNode = {
	            type: 9 /* IF */,
	            loc: node.loc,
	            branches: [branch]
	        };
	        context.replaceNode(ifNode);
	        if (processCodegen) {
	            return processCodegen(ifNode, branch, true);
	        }
	    }
	    else {
	        // locate the adjacent v-if
	        const siblings = context.parent.children;
	        const comments = [];
	        let i = siblings.indexOf(node);
	        while (i-- >= -1) {
	            const sibling = siblings[i];
	            if (sibling && sibling.type === 3 /* COMMENT */) {
	                context.removeNode(sibling);
	                comments.unshift(sibling);
	                continue;
	            }
	            if (sibling &&
	                sibling.type === 2 /* TEXT */ &&
	                !sibling.content.trim().length) {
	                context.removeNode(sibling);
	                continue;
	            }
	            if (sibling && sibling.type === 9 /* IF */) {
	                // Check if v-else was followed by v-else-if
	                if (dir.name === 'else-if' &&
	                    sibling.branches[sibling.branches.length - 1].condition === undefined) {
	                    context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
	                }
	                // move the node to the if node's branches
	                context.removeNode();
	                const branch = createIfBranch(node, dir);
	                if (comments.length &&
	                    // #3619 ignore comments if the v-if is direct child of <transition>
	                    !(context.parent &&
	                        context.parent.type === 1 /* ELEMENT */ &&
	                        isBuiltInType(context.parent.tag, 'transition'))) {
	                    branch.children = [...comments, ...branch.children];
	                }
	                // check if user is forcing same key on different branches
	                {
	                    const key = branch.userKey;
	                    if (key) {
	                        sibling.branches.forEach(({ userKey }) => {
	                            if (isSameKey(userKey, key)) {
	                                context.onError(createCompilerError(29 /* X_V_IF_SAME_KEY */, branch.userKey.loc));
	                            }
	                        });
	                    }
	                }
	                sibling.branches.push(branch);
	                const onExit = processCodegen && processCodegen(sibling, branch, false);
	                // since the branch was removed, it will not be traversed.
	                // make sure to traverse here.
	                traverseNode(branch, context);
	                // call on exit
	                if (onExit)
	                    onExit();
	                // make sure to reset currentNode after traversal to indicate this
	                // node has been removed.
	                context.currentNode = null;
	            }
	            else {
	                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
	            }
	            break;
	        }
	    }
	}
	function createIfBranch(node, dir) {
	    const isTemplateIf = node.tagType === 3 /* TEMPLATE */;
	    return {
	        type: 10 /* IF_BRANCH */,
	        loc: node.loc,
	        condition: dir.name === 'else' ? undefined : dir.exp,
	        children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],
	        userKey: findProp(node, `key`),
	        isTemplateIf
	    };
	}
	function createCodegenNodeForBranch(branch, keyIndex, context) {
	    if (branch.condition) {
	        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
	        // make sure to pass in asBlock: true so that the comment node call
	        // closes the current block.
	        createCallExpression(context.helper(CREATE_COMMENT), [
	            '"v-if"' ,
	            'true'
	        ]));
	    }
	    else {
	        return createChildrenCodegenNode(branch, keyIndex, context);
	    }
	}
	function createChildrenCodegenNode(branch, keyIndex, context) {
	    const { helper } = context;
	    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));
	    const { children } = branch;
	    const firstChild = children[0];
	    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;
	    if (needFragmentWrapper) {
	        if (children.length === 1 && firstChild.type === 11 /* FOR */) {
	            // optimize away nested fragments when child is a ForNode
	            const vnodeCall = firstChild.codegenNode;
	            injectProp(vnodeCall, keyProperty, context);
	            return vnodeCall;
	        }
	        else {
	            let patchFlag = 64 /* STABLE_FRAGMENT */;
	            let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];
	            // check if the fragment actually contains a single valid child with
	            // the rest being comments
	            if (!branch.isTemplateIf &&
	                children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
	                patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
	                patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;
	            }
	            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, false, false /* isComponent */, branch.loc);
	        }
	    }
	    else {
	        const ret = firstChild.codegenNode;
	        const vnodeCall = getMemoedVNodeCall(ret);
	        // Change createVNode to createBlock.
	        if (vnodeCall.type === 13 /* VNODE_CALL */) {
	            makeBlock(vnodeCall, context);
	        }
	        // inject branch key
	        injectProp(vnodeCall, keyProperty, context);
	        return ret;
	    }
	}
	function isSameKey(a, b) {
	    if (!a || a.type !== b.type) {
	        return false;
	    }
	    if (a.type === 6 /* ATTRIBUTE */) {
	        if (a.value.content !== b.value.content) {
	            return false;
	        }
	    }
	    else {
	        // directive
	        const exp = a.exp;
	        const branchExp = b.exp;
	        if (exp.type !== branchExp.type) {
	            return false;
	        }
	        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||
	            exp.isStatic !== branchExp.isStatic ||
	            exp.content !== branchExp.content) {
	            return false;
	        }
	    }
	    return true;
	}
	function getParentCondition(node) {
	    while (true) {
	        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
	            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
	                node = node.alternate;
	            }
	            else {
	                return node;
	            }
	        }
	        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {
	            node = node.value;
	        }
	    }
	}

	const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
	    const { helper, removeHelper } = context;
	    return processFor(node, dir, context, forNode => {
	        // create the loop render function expression now, and add the
	        // iterator on exit after all children have been traversed
	        const renderExp = createCallExpression(helper(RENDER_LIST), [
	            forNode.source
	        ]);
	        const isTemplate = isTemplateNode(node);
	        const memo = findDir(node, 'memo');
	        const keyProp = findProp(node, `key`);
	        const keyExp = keyProp &&
	            (keyProp.type === 6 /* ATTRIBUTE */
	                ? createSimpleExpression(keyProp.value.content, true)
	                : keyProp.exp);
	        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
	        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&
	            forNode.source.constType > 0 /* NOT_CONSTANT */;
	        const fragmentFlag = isStableFragment
	            ? 64 /* STABLE_FRAGMENT */
	            : keyProp
	                ? 128 /* KEYED_FRAGMENT */
	                : 256 /* UNKEYED_FRAGMENT */;
	        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
	            (` /* ${PatchFlagNames[fragmentFlag]} */` ), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);
	        return () => {
	            // finish the codegen now that all children have been traversed
	            let childBlock;
	            const { children } = forNode;
	            // check <template v-for> key placement
	            if (isTemplate) {
	                node.children.some(c => {
	                    if (c.type === 1 /* ELEMENT */) {
	                        const key = findProp(c, 'key');
	                        if (key) {
	                            context.onError(createCompilerError(33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
	                            return true;
	                        }
	                    }
	                });
	            }
	            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;
	            const slotOutlet = isSlotOutlet(node)
	                ? node
	                : isTemplate &&
	                    node.children.length === 1 &&
	                    isSlotOutlet(node.children[0])
	                    ? node.children[0] // api-extractor somehow fails to infer this
	                    : null;
	            if (slotOutlet) {
	                // <slot v-for="..."> or <template v-for="..."><slot/></template>
	                childBlock = slotOutlet.codegenNode;
	                if (isTemplate && keyProperty) {
	                    // <template v-for="..." :key="..."><slot/></template>
	                    // we need to inject the key to the renderSlot() call.
	                    // the props for renderSlot is passed as the 3rd argument.
	                    injectProp(childBlock, keyProperty, context);
	                }
	            }
	            else if (needFragmentWrapper) {
	                // <template v-for="..."> with text or multi-elements
	                // should generate a fragment block for each loop
	                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +
	                    (` /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`
	                        ), undefined, undefined, true, undefined, false /* isComponent */);
	            }
	            else {
	                // Normal element v-for. Directly use the child's codegenNode
	                // but mark it as a block.
	                childBlock = children[0]
	                    .codegenNode;
	                if (isTemplate && keyProperty) {
	                    injectProp(childBlock, keyProperty, context);
	                }
	                if (childBlock.isBlock !== !isStableFragment) {
	                    if (childBlock.isBlock) {
	                        // switch from block to vnode
	                        removeHelper(OPEN_BLOCK);
	                        removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
	                    }
	                    else {
	                        // switch from vnode to block
	                        removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
	                    }
	                }
	                childBlock.isBlock = !isStableFragment;
	                if (childBlock.isBlock) {
	                    helper(OPEN_BLOCK);
	                    helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
	                }
	                else {
	                    helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
	                }
	            }
	            if (memo) {
	                const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
	                    createSimpleExpression(`_cached`)
	                ]));
	                loop.body = createBlockStatement([
	                    createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
	                    createCompoundExpression([
	                        `if (_cached`,
	                        ...(keyExp ? [` && _cached.key === `, keyExp] : []),
	                        ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
	                    ]),
	                    createCompoundExpression([`const _item = `, childBlock]),
	                    createSimpleExpression(`_item.memo = _memo`),
	                    createSimpleExpression(`return _item`)
	                ]);
	                renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
	            }
	            else {
	                renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
	            }
	        };
	    });
	});
	// target-agnostic transform used for both Client and SSR
	function processFor(node, dir, context, processCodegen) {
	    if (!dir.exp) {
	        context.onError(createCompilerError(31 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
	        return;
	    }
	    const parseResult = parseForExpression(
	    // can only be simple expression because vFor transform is applied
	    // before expression transform.
	    dir.exp, context);
	    if (!parseResult) {
	        context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
	        return;
	    }
	    const { addIdentifiers, removeIdentifiers, scopes } = context;
	    const { source, value, key, index } = parseResult;
	    const forNode = {
	        type: 11 /* FOR */,
	        loc: dir.loc,
	        source,
	        valueAlias: value,
	        keyAlias: key,
	        objectIndexAlias: index,
	        parseResult,
	        children: isTemplateNode(node) ? node.children : [node]
	    };
	    context.replaceNode(forNode);
	    // bookkeeping
	    scopes.vFor++;
	    const onExit = processCodegen && processCodegen(forNode);
	    return () => {
	        scopes.vFor--;
	        if (onExit)
	            onExit();
	    };
	}
	const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
	// This regex doesn't cover the case if key or index aliases have destructuring,
	// but those do not make sense in the first place, so this works in practice.
	const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
	const stripParensRE = /^\(|\)$/g;
	function parseForExpression(input, context) {
	    const loc = input.loc;
	    const exp = input.content;
	    const inMatch = exp.match(forAliasRE);
	    if (!inMatch)
	        return;
	    const [, LHS, RHS] = inMatch;
	    const result = {
	        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
	        value: undefined,
	        key: undefined,
	        index: undefined
	    };
	    {
	        validateBrowserExpression(result.source, context);
	    }
	    let valueContent = LHS.trim().replace(stripParensRE, '').trim();
	    const trimmedOffset = LHS.indexOf(valueContent);
	    const iteratorMatch = valueContent.match(forIteratorRE);
	    if (iteratorMatch) {
	        valueContent = valueContent.replace(forIteratorRE, '').trim();
	        const keyContent = iteratorMatch[1].trim();
	        let keyOffset;
	        if (keyContent) {
	            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
	            result.key = createAliasExpression(loc, keyContent, keyOffset);
	            {
	                validateBrowserExpression(result.key, context, true);
	            }
	        }
	        if (iteratorMatch[2]) {
	            const indexContent = iteratorMatch[2].trim();
	            if (indexContent) {
	                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
	                    ? keyOffset + keyContent.length
	                    : trimmedOffset + valueContent.length));
	                {
	                    validateBrowserExpression(result.index, context, true);
	                }
	            }
	        }
	    }
	    if (valueContent) {
	        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
	        {
	            validateBrowserExpression(result.value, context, true);
	        }
	    }
	    return result;
	}
	function createAliasExpression(range, content, offset) {
	    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
	}
	function createForLoopParams({ value, key, index }, memoArgs = []) {
	    return createParamsList([value, key, index, ...memoArgs]);
	}
	function createParamsList(args) {
	    let i = args.length;
	    while (i--) {
	        if (args[i])
	            break;
	    }
	    return args
	        .slice(0, i + 1)
	        .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
	}

	const defaultFallback = createSimpleExpression(`undefined`, false);
	// A NodeTransform that:
	// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
	//    by transformExpression. This is only applied in non-browser builds with
	//    { prefixIdentifiers: true }.
	// 2. Track v-slot depths so that we know a slot is inside another slot.
	//    Note the exit callback is executed before buildSlots() on the same node,
	//    so only nested slots see positive numbers.
	const trackSlotScopes = (node, context) => {
	    if (node.type === 1 /* ELEMENT */ &&
	        (node.tagType === 1 /* COMPONENT */ ||
	            node.tagType === 3 /* TEMPLATE */)) {
	        // We are only checking non-empty v-slot here
	        // since we only care about slots that introduce scope variables.
	        const vSlot = findDir(node, 'slot');
	        if (vSlot) {
	            vSlot.exp;
	            context.scopes.vSlot++;
	            return () => {
	                context.scopes.vSlot--;
	            };
	        }
	    }
	};
	const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
	// Instead of being a DirectiveTransform, v-slot processing is called during
	// transformElement to build the slots object for a component.
	function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
	    context.helper(WITH_CTX);
	    const { children, loc } = node;
	    const slotsProperties = [];
	    const dynamicSlots = [];
	    // If the slot is inside a v-for or another v-slot, force it to be dynamic
	    // since it likely uses a scope variable.
	    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
	    // 1. Check for slot with slotProps on component itself.
	    //    <Comp v-slot="{ prop }"/>
	    const onComponentSlot = findDir(node, 'slot', true);
	    if (onComponentSlot) {
	        const { arg, exp } = onComponentSlot;
	        if (arg && !isStaticExp(arg)) {
	            hasDynamicSlots = true;
	        }
	        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
	    }
	    // 2. Iterate through children and check for template slots
	    //    <template v-slot:foo="{ prop }">
	    let hasTemplateSlots = false;
	    let hasNamedDefaultSlot = false;
	    const implicitDefaultChildren = [];
	    const seenSlotNames = new Set();
	    for (let i = 0; i < children.length; i++) {
	        const slotElement = children[i];
	        let slotDir;
	        if (!isTemplateNode(slotElement) ||
	            !(slotDir = findDir(slotElement, 'slot', true))) {
	            // not a <template v-slot>, skip.
	            if (slotElement.type !== 3 /* COMMENT */) {
	                implicitDefaultChildren.push(slotElement);
	            }
	            continue;
	        }
	        if (onComponentSlot) {
	            // already has on-component slot - this is incorrect usage.
	            context.onError(createCompilerError(37 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
	            break;
	        }
	        hasTemplateSlots = true;
	        const { children: slotChildren, loc: slotLoc } = slotElement;
	        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
	        // check if name is dynamic.
	        let staticSlotName;
	        if (isStaticExp(slotName)) {
	            staticSlotName = slotName ? slotName.content : `default`;
	        }
	        else {
	            hasDynamicSlots = true;
	        }
	        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
	        // check if this slot is conditional (v-if/v-for)
	        let vIf;
	        let vElse;
	        let vFor;
	        if ((vIf = findDir(slotElement, 'if'))) {
	            hasDynamicSlots = true;
	            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
	        }
	        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
	            // find adjacent v-if
	            let j = i;
	            let prev;
	            while (j--) {
	                prev = children[j];
	                if (prev.type !== 3 /* COMMENT */) {
	                    break;
	                }
	            }
	            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
	                // remove node
	                children.splice(i, 1);
	                i--;
	                // attach this slot to previous conditional
	                let conditional = dynamicSlots[dynamicSlots.length - 1];
	                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
	                    conditional = conditional.alternate;
	                }
	                conditional.alternate = vElse.exp
	                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
	                    : buildDynamicSlot(slotName, slotFunction);
	            }
	            else {
	                context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
	            }
	        }
	        else if ((vFor = findDir(slotElement, 'for'))) {
	            hasDynamicSlots = true;
	            const parseResult = vFor.parseResult ||
	                parseForExpression(vFor.exp, context);
	            if (parseResult) {
	                // Render the dynamic slots as an array and add it to the createSlot()
	                // args. The runtime knows how to handle it appropriately.
	                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
	                    parseResult.source,
	                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
	                ]));
	            }
	            else {
	                context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
	            }
	        }
	        else {
	            // check duplicate static names
	            if (staticSlotName) {
	                if (seenSlotNames.has(staticSlotName)) {
	                    context.onError(createCompilerError(38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
	                    continue;
	                }
	                seenSlotNames.add(staticSlotName);
	                if (staticSlotName === 'default') {
	                    hasNamedDefaultSlot = true;
	                }
	            }
	            slotsProperties.push(createObjectProperty(slotName, slotFunction));
	        }
	    }
	    if (!onComponentSlot) {
	        const buildDefaultSlotProperty = (props, children) => {
	            const fn = buildSlotFn(props, children, loc);
	            return createObjectProperty(`default`, fn);
	        };
	        if (!hasTemplateSlots) {
	            // implicit default slot (on component)
	            slotsProperties.push(buildDefaultSlotProperty(undefined, children));
	        }
	        else if (implicitDefaultChildren.length &&
	            // #3766
	            // with whitespace: 'preserve', whitespaces between slots will end up in
	            // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
	            implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {
	            // implicit default slot (mixed with named slots)
	            if (hasNamedDefaultSlot) {
	                context.onError(createCompilerError(39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
	            }
	            else {
	                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
	            }
	        }
	    }
	    const slotFlag = hasDynamicSlots
	        ? 2 /* DYNAMIC */
	        : hasForwardedSlots(node.children)
	            ? 3 /* FORWARDED */
	            : 1 /* STABLE */;
	    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
	    // 2 = compiled but dynamic = can skip normalization, but must run diff
	    // 1 = compiled and static = can skip normalization AND diff as optimized
	    createSimpleExpression(slotFlag + (` /* ${slotFlagsText[slotFlag]} */` ), false))), loc);
	    if (dynamicSlots.length) {
	        slots = createCallExpression(context.helper(CREATE_SLOTS), [
	            slots,
	            createArrayExpression(dynamicSlots)
	        ]);
	    }
	    return {
	        slots,
	        hasDynamicSlots
	    };
	}
	function buildDynamicSlot(name, fn) {
	    return createObjectExpression([
	        createObjectProperty(`name`, name),
	        createObjectProperty(`fn`, fn)
	    ]);
	}
	function hasForwardedSlots(children) {
	    for (let i = 0; i < children.length; i++) {
	        const child = children[i];
	        switch (child.type) {
	            case 1 /* ELEMENT */:
	                if (child.tagType === 2 /* SLOT */ ||
	                    hasForwardedSlots(child.children)) {
	                    return true;
	                }
	                break;
	            case 9 /* IF */:
	                if (hasForwardedSlots(child.branches))
	                    return true;
	                break;
	            case 10 /* IF_BRANCH */:
	            case 11 /* FOR */:
	                if (hasForwardedSlots(child.children))
	                    return true;
	                break;
	        }
	    }
	    return false;
	}
	function isNonWhitespaceContent(node) {
	    if (node.type !== 2 /* TEXT */ && node.type !== 12 /* TEXT_CALL */)
	        return true;
	    return node.type === 2 /* TEXT */
	        ? !!node.content.trim()
	        : isNonWhitespaceContent(node.content);
	}

	// some directive transforms (e.g. v-model) may return a symbol for runtime
	// import, which should be used instead of a resolveDirective call.
	const directiveImportMap = new WeakMap();
	// generate a JavaScript AST for this element's codegen
	const transformElement = (node, context) => {
	    // perform the work on exit, after all child expressions have been
	    // processed and merged.
	    return function postTransformElement() {
	        node = context.currentNode;
	        if (!(node.type === 1 /* ELEMENT */ &&
	            (node.tagType === 0 /* ELEMENT */ ||
	                node.tagType === 1 /* COMPONENT */))) {
	            return;
	        }
	        const { tag, props } = node;
	        const isComponent = node.tagType === 1 /* COMPONENT */;
	        // The goal of the transform is to create a codegenNode implementing the
	        // VNodeCall interface.
	        let vnodeTag = isComponent
	            ? resolveComponentType(node, context)
	            : `"${tag}"`;
	        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
	        let vnodeProps;
	        let vnodeChildren;
	        let vnodePatchFlag;
	        let patchFlag = 0;
	        let vnodeDynamicProps;
	        let dynamicPropNames;
	        let vnodeDirectives;
	        let shouldUseBlock = 
	        // dynamic component may resolve to plain elements
	        isDynamicComponent ||
	            vnodeTag === TELEPORT ||
	            vnodeTag === SUSPENSE ||
	            (!isComponent &&
	                // <svg> and <foreignObject> must be forced into blocks so that block
	                // updates inside get proper isSVG flag at runtime. (#639, #643)
	                // This is technically web-specific, but splitting the logic out of core
	                // leads to too much unnecessary complexity.
	                (tag === 'svg' || tag === 'foreignObject'));
	        // props
	        if (props.length > 0) {
	            const propsBuildResult = buildProps(node, context, undefined, isComponent, isDynamicComponent);
	            vnodeProps = propsBuildResult.props;
	            patchFlag = propsBuildResult.patchFlag;
	            dynamicPropNames = propsBuildResult.dynamicPropNames;
	            const directives = propsBuildResult.directives;
	            vnodeDirectives =
	                directives && directives.length
	                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
	                    : undefined;
	            if (propsBuildResult.shouldUseBlock) {
	                shouldUseBlock = true;
	            }
	        }
	        // children
	        if (node.children.length > 0) {
	            if (vnodeTag === KEEP_ALIVE) {
	                // Although a built-in component, we compile KeepAlive with raw children
	                // instead of slot functions so that it can be used inside Transition
	                // or other Transition-wrapping HOCs.
	                // To ensure correct updates with block optimizations, we need to:
	                // 1. Force keep-alive into a block. This avoids its children being
	                //    collected by a parent block.
	                shouldUseBlock = true;
	                // 2. Force keep-alive to always be updated, since it uses raw children.
	                patchFlag |= 1024 /* DYNAMIC_SLOTS */;
	                if (node.children.length > 1) {
	                    context.onError(createCompilerError(45 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {
	                        start: node.children[0].loc.start,
	                        end: node.children[node.children.length - 1].loc.end,
	                        source: ''
	                    }));
	                }
	            }
	            const shouldBuildAsSlots = isComponent &&
	                // Teleport is not a real component and has dedicated runtime handling
	                vnodeTag !== TELEPORT &&
	                // explained above.
	                vnodeTag !== KEEP_ALIVE;
	            if (shouldBuildAsSlots) {
	                const { slots, hasDynamicSlots } = buildSlots(node, context);
	                vnodeChildren = slots;
	                if (hasDynamicSlots) {
	                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;
	                }
	            }
	            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
	                const child = node.children[0];
	                const type = child.type;
	                // check for dynamic text children
	                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
	                    type === 8 /* COMPOUND_EXPRESSION */;
	                if (hasDynamicTextChild &&
	                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
	                    patchFlag |= 1 /* TEXT */;
	                }
	                // pass directly if the only child is a text node
	                // (plain / interpolation / expression)
	                if (hasDynamicTextChild || type === 2 /* TEXT */) {
	                    vnodeChildren = child;
	                }
	                else {
	                    vnodeChildren = node.children;
	                }
	            }
	            else {
	                vnodeChildren = node.children;
	            }
	        }
	        // patchFlag & dynamicPropNames
	        if (patchFlag !== 0) {
	            {
	                if (patchFlag < 0) {
	                    // special flags (negative and mutually exclusive)
	                    vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
	                }
	                else {
	                    // bitwise flags
	                    const flagNames = Object.keys(PatchFlagNames)
	                        .map(Number)
	                        .filter(n => n > 0 && patchFlag & n)
	                        .map(n => PatchFlagNames[n])
	                        .join(`, `);
	                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
	                }
	            }
	            if (dynamicPropNames && dynamicPropNames.length) {
	                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
	            }
	        }
	        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);
	    };
	};
	function resolveComponentType(node, context, ssr = false) {
	    let { tag } = node;
	    // 1. dynamic component
	    const isExplicitDynamic = isComponentTag(tag);
	    const isProp = findProp(node, 'is');
	    if (isProp) {
	        if (isExplicitDynamic ||
	            (false )) {
	            const exp = isProp.type === 6 /* ATTRIBUTE */
	                ? isProp.value && createSimpleExpression(isProp.value.content, true)
	                : isProp.exp;
	            if (exp) {
	                return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
	                    exp
	                ]);
	            }
	        }
	        else if (isProp.type === 6 /* ATTRIBUTE */ &&
	            isProp.value.content.startsWith('vue:')) {
	            // <button is="vue:xxx">
	            // if not <component>, only is value that starts with "vue:" will be
	            // treated as component by the parse phase and reach here, unless it's
	            // compat mode where all is values are considered components
	            tag = isProp.value.content.slice(4);
	        }
	    }
	    // 1.5 v-is (TODO: Deprecate)
	    const isDir = !isExplicitDynamic && findDir(node, 'is');
	    if (isDir && isDir.exp) {
	        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
	            isDir.exp
	        ]);
	    }
	    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
	    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
	    if (builtIn) {
	        // built-ins are simply fallthroughs / have special handling during ssr
	        // so we don't need to import their runtime equivalents
	        if (!ssr)
	            context.helper(builtIn);
	        return builtIn;
	    }
	    // 5. user component (resolve)
	    context.helper(RESOLVE_COMPONENT);
	    context.components.add(tag);
	    return toValidAssetId(tag, `component`);
	}
	function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
	    const { tag, loc: elementLoc, children } = node;
	    let properties = [];
	    const mergeArgs = [];
	    const runtimeDirectives = [];
	    const hasChildren = children.length > 0;
	    let shouldUseBlock = false;
	    // patchFlag analysis
	    let patchFlag = 0;
	    let hasRef = false;
	    let hasClassBinding = false;
	    let hasStyleBinding = false;
	    let hasHydrationEventBinding = false;
	    let hasDynamicKeys = false;
	    let hasVnodeHook = false;
	    const dynamicPropNames = [];
	    const analyzePatchFlag = ({ key, value }) => {
	        if (isStaticExp(key)) {
	            const name = key.content;
	            const isEventHandler = isOn(name);
	            if (isEventHandler &&
	                (!isComponent || isDynamicComponent) &&
	                // omit the flag for click handlers because hydration gives click
	                // dedicated fast path.
	                name.toLowerCase() !== 'onclick' &&
	                // omit v-model handlers
	                name !== 'onUpdate:modelValue' &&
	                // omit onVnodeXXX hooks
	                !isReservedProp(name)) {
	                hasHydrationEventBinding = true;
	            }
	            if (isEventHandler && isReservedProp(name)) {
	                hasVnodeHook = true;
	            }
	            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
	                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
	                    value.type === 8 /* COMPOUND_EXPRESSION */) &&
	                    getConstantType(value, context) > 0)) {
	                // skip if the prop is a cached handler or has constant value
	                return;
	            }
	            if (name === 'ref') {
	                hasRef = true;
	            }
	            else if (name === 'class') {
	                hasClassBinding = true;
	            }
	            else if (name === 'style') {
	                hasStyleBinding = true;
	            }
	            else if (name !== 'key' && !dynamicPropNames.includes(name)) {
	                dynamicPropNames.push(name);
	            }
	            // treat the dynamic class and style binding of the component as dynamic props
	            if (isComponent &&
	                (name === 'class' || name === 'style') &&
	                !dynamicPropNames.includes(name)) {
	                dynamicPropNames.push(name);
	            }
	        }
	        else {
	            hasDynamicKeys = true;
	        }
	    };
	    for (let i = 0; i < props.length; i++) {
	        // static attribute
	        const prop = props[i];
	        if (prop.type === 6 /* ATTRIBUTE */) {
	            const { loc, name, value } = prop;
	            let isStatic = true;
	            if (name === 'ref') {
	                hasRef = true;
	                if (context.scopes.vFor > 0) {
	                    properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
	                }
	            }
	            // skip is on <component>, or is="vue:xxx"
	            if (name === 'is' &&
	                (isComponentTag(tag) ||
	                    (value && value.content.startsWith('vue:')) ||
	                    (false ))) {
	                continue;
	            }
	            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
	        }
	        else {
	            // directives
	            const { name, arg, exp, loc } = prop;
	            const isVBind = name === 'bind';
	            const isVOn = name === 'on';
	            // skip v-slot - it is handled by its dedicated transform.
	            if (name === 'slot') {
	                if (!isComponent) {
	                    context.onError(createCompilerError(40 /* X_V_SLOT_MISPLACED */, loc));
	                }
	                continue;
	            }
	            // skip v-once/v-memo - they are handled by dedicated transforms.
	            if (name === 'once' || name === 'memo') {
	                continue;
	            }
	            // skip v-is and :is on <component>
	            if (name === 'is' ||
	                (isVBind &&
	                    isStaticArgOf(arg, 'is') &&
	                    (isComponentTag(tag) ||
	                        (false )))) {
	                continue;
	            }
	            // skip v-on in SSR compilation
	            if (isVOn && ssr) {
	                continue;
	            }
	            if (
	            // #938: elements with dynamic keys should be forced into blocks
	            (isVBind && isStaticArgOf(arg, 'key')) ||
	                // inline before-update hooks need to force block so that it is invoked
	                // before children
	                (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {
	                shouldUseBlock = true;
	            }
	            if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
	                properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
	            }
	            // special case for v-bind and v-on with no argument
	            if (!arg && (isVBind || isVOn)) {
	                hasDynamicKeys = true;
	                if (exp) {
	                    if (properties.length) {
	                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
	                        properties = [];
	                    }
	                    if (isVBind) {
	                        mergeArgs.push(exp);
	                    }
	                    else {
	                        // v-on="obj" -> toHandlers(obj)
	                        mergeArgs.push({
	                            type: 14 /* JS_CALL_EXPRESSION */,
	                            loc,
	                            callee: context.helper(TO_HANDLERS),
	                            arguments: [exp]
	                        });
	                    }
	                }
	                else {
	                    context.onError(createCompilerError(isVBind
	                        ? 34 /* X_V_BIND_NO_EXPRESSION */
	                        : 35 /* X_V_ON_NO_EXPRESSION */, loc));
	                }
	                continue;
	            }
	            const directiveTransform = context.directiveTransforms[name];
	            if (directiveTransform) {
	                // has built-in directive transform.
	                const { props, needRuntime } = directiveTransform(prop, node, context);
	                !ssr && props.forEach(analyzePatchFlag);
	                properties.push(...props);
	                if (needRuntime) {
	                    runtimeDirectives.push(prop);
	                    if (isSymbol(needRuntime)) {
	                        directiveImportMap.set(prop, needRuntime);
	                    }
	                }
	            }
	            else if (!isBuiltInDirective(name)) {
	                // no built-in transform, this is a user custom directive.
	                runtimeDirectives.push(prop);
	                // custom dirs may use beforeUpdate so they need to force blocks
	                // to ensure before-update gets called before children update
	                if (hasChildren) {
	                    shouldUseBlock = true;
	                }
	            }
	        }
	    }
	    let propsExpression = undefined;
	    // has v-bind="object" or v-on="object", wrap with mergeProps
	    if (mergeArgs.length) {
	        if (properties.length) {
	            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
	        }
	        if (mergeArgs.length > 1) {
	            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
	        }
	        else {
	            // single v-bind with nothing else - no need for a mergeProps call
	            propsExpression = mergeArgs[0];
	        }
	    }
	    else if (properties.length) {
	        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
	    }
	    // patchFlag analysis
	    if (hasDynamicKeys) {
	        patchFlag |= 16 /* FULL_PROPS */;
	    }
	    else {
	        if (hasClassBinding && !isComponent) {
	            patchFlag |= 2 /* CLASS */;
	        }
	        if (hasStyleBinding && !isComponent) {
	            patchFlag |= 4 /* STYLE */;
	        }
	        if (dynamicPropNames.length) {
	            patchFlag |= 8 /* PROPS */;
	        }
	        if (hasHydrationEventBinding) {
	            patchFlag |= 32 /* HYDRATE_EVENTS */;
	        }
	    }
	    if (!shouldUseBlock &&
	        (patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&
	        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
	        patchFlag |= 512 /* NEED_PATCH */;
	    }
	    // pre-normalize props, SSR is skipped for now
	    if (!context.inSSR && propsExpression) {
	        switch (propsExpression.type) {
	            case 15 /* JS_OBJECT_EXPRESSION */:
	                // means that there is no v-bind,
	                // but still need to deal with dynamic key binding
	                let classKeyIndex = -1;
	                let styleKeyIndex = -1;
	                let hasDynamicKey = false;
	                for (let i = 0; i < propsExpression.properties.length; i++) {
	                    const key = propsExpression.properties[i].key;
	                    if (isStaticExp(key)) {
	                        if (key.content === 'class') {
	                            classKeyIndex = i;
	                        }
	                        else if (key.content === 'style') {
	                            styleKeyIndex = i;
	                        }
	                    }
	                    else if (!key.isHandlerKey) {
	                        hasDynamicKey = true;
	                    }
	                }
	                const classProp = propsExpression.properties[classKeyIndex];
	                const styleProp = propsExpression.properties[styleKeyIndex];
	                // no dynamic key
	                if (!hasDynamicKey) {
	                    if (classProp && !isStaticExp(classProp.value)) {
	                        classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
	                    }
	                    if (styleProp &&
	                        // the static style is compiled into an object,
	                        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
	                        (hasStyleBinding ||
	                            (styleProp.value.type === 4 /* SIMPLE_EXPRESSION */ &&
	                                styleProp.value.content.trim()[0] === `[`) ||
	                            // v-bind:style and style both exist,
	                            // v-bind:style with static literal object
	                            styleProp.value.type === 17 /* JS_ARRAY_EXPRESSION */)) {
	                        styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
	                    }
	                }
	                else {
	                    // dynamic key binding, wrap with `normalizeProps`
	                    propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
	                }
	                break;
	            case 14 /* JS_CALL_EXPRESSION */:
	                // mergeProps call, do nothing
	                break;
	            default:
	                // single v-bind
	                propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
	                    createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
	                        propsExpression
	                    ])
	                ]);
	                break;
	        }
	    }
	    return {
	        props: propsExpression,
	        directives: runtimeDirectives,
	        patchFlag,
	        dynamicPropNames,
	        shouldUseBlock
	    };
	}
	// Dedupe props in an object literal.
	// Literal duplicated attributes would have been warned during the parse phase,
	// however, it's possible to encounter duplicated `onXXX` handlers with different
	// modifiers. We also need to merge static and dynamic class / style attributes.
	// - onXXX handlers / style: merge into array
	// - class: merge into single expression with concatenation
	function dedupeProperties(properties) {
	    const knownProps = new Map();
	    const deduped = [];
	    for (let i = 0; i < properties.length; i++) {
	        const prop = properties[i];
	        // dynamic keys are always allowed
	        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
	            deduped.push(prop);
	            continue;
	        }
	        const name = prop.key.content;
	        const existing = knownProps.get(name);
	        if (existing) {
	            if (name === 'style' || name === 'class' || isOn(name)) {
	                mergeAsArray$1(existing, prop);
	            }
	            // unexpected duplicate, should have emitted error during parse
	        }
	        else {
	            knownProps.set(name, prop);
	            deduped.push(prop);
	        }
	    }
	    return deduped;
	}
	function mergeAsArray$1(existing, incoming) {
	    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
	        existing.value.elements.push(incoming.value);
	    }
	    else {
	        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
	    }
	}
	function buildDirectiveArgs(dir, context) {
	    const dirArgs = [];
	    const runtime = directiveImportMap.get(dir);
	    if (runtime) {
	        // built-in directive with runtime
	        dirArgs.push(context.helperString(runtime));
	    }
	    else {
	        {
	            // inject statement for resolving directive
	            context.helper(RESOLVE_DIRECTIVE);
	            context.directives.add(dir.name);
	            dirArgs.push(toValidAssetId(dir.name, `directive`));
	        }
	    }
	    const { loc } = dir;
	    if (dir.exp)
	        dirArgs.push(dir.exp);
	    if (dir.arg) {
	        if (!dir.exp) {
	            dirArgs.push(`void 0`);
	        }
	        dirArgs.push(dir.arg);
	    }
	    if (Object.keys(dir.modifiers).length) {
	        if (!dir.arg) {
	            if (!dir.exp) {
	                dirArgs.push(`void 0`);
	            }
	            dirArgs.push(`void 0`);
	        }
	        const trueExpression = createSimpleExpression(`true`, false, loc);
	        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
	    }
	    return createArrayExpression(dirArgs, dir.loc);
	}
	function stringifyDynamicPropNames(props) {
	    let propsNamesString = `[`;
	    for (let i = 0, l = props.length; i < l; i++) {
	        propsNamesString += JSON.stringify(props[i]);
	        if (i < l - 1)
	            propsNamesString += ', ';
	    }
	    return propsNamesString + `]`;
	}
	function isComponentTag(tag) {
	    return tag === 'component' || tag === 'Component';
	}

	const transformSlotOutlet = (node, context) => {
	    if (isSlotOutlet(node)) {
	        const { children, loc } = node;
	        const { slotName, slotProps } = processSlotOutlet(node, context);
	        const slotArgs = [
	            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
	            slotName,
	            '{}',
	            'undefined',
	            'true'
	        ];
	        let expectedLen = 2;
	        if (slotProps) {
	            slotArgs[2] = slotProps;
	            expectedLen = 3;
	        }
	        if (children.length) {
	            slotArgs[3] = createFunctionExpression([], children, false, false, loc);
	            expectedLen = 4;
	        }
	        if (context.scopeId && !context.slotted) {
	            expectedLen = 5;
	        }
	        slotArgs.splice(expectedLen); // remove unused arguments
	        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
	    }
	};
	function processSlotOutlet(node, context) {
	    let slotName = `"default"`;
	    let slotProps = undefined;
	    const nonNameProps = [];
	    for (let i = 0; i < node.props.length; i++) {
	        const p = node.props[i];
	        if (p.type === 6 /* ATTRIBUTE */) {
	            if (p.value) {
	                if (p.name === 'name') {
	                    slotName = JSON.stringify(p.value.content);
	                }
	                else {
	                    p.name = camelize(p.name);
	                    nonNameProps.push(p);
	                }
	            }
	        }
	        else {
	            if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
	                if (p.exp)
	                    slotName = p.exp;
	            }
	            else {
	                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
	                    p.arg.content = camelize(p.arg.content);
	                }
	                nonNameProps.push(p);
	            }
	        }
	    }
	    if (nonNameProps.length > 0) {
	        const { props, directives } = buildProps(node, context, nonNameProps, false, false);
	        slotProps = props;
	        if (directives.length) {
	            context.onError(createCompilerError(36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
	        }
	    }
	    return {
	        slotName,
	        slotProps
	    };
	}

	const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
	const transformOn = (dir, node, context, augmentor) => {
	    const { loc, modifiers, arg } = dir;
	    if (!dir.exp && !modifiers.length) {
	        context.onError(createCompilerError(35 /* X_V_ON_NO_EXPRESSION */, loc));
	    }
	    let eventName;
	    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
	        if (arg.isStatic) {
	            let rawName = arg.content;
	            // TODO deprecate @vnodeXXX usage
	            if (rawName.startsWith('vue:')) {
	                rawName = `vnode-${rawName.slice(4)}`;
	            }
	            // for all event listeners, auto convert it to camelCase. See issue #2249
	            eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);
	        }
	        else {
	            // #2388
	            eventName = createCompoundExpression([
	                `${context.helperString(TO_HANDLER_KEY)}(`,
	                arg,
	                `)`
	            ]);
	        }
	    }
	    else {
	        // already a compound expression.
	        eventName = arg;
	        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
	        eventName.children.push(`)`);
	    }
	    // handler processing
	    let exp = dir.exp;
	    if (exp && !exp.content.trim()) {
	        exp = undefined;
	    }
	    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
	    if (exp) {
	        const isMemberExp = isMemberExpression(exp.content);
	        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
	        const hasMultipleStatements = exp.content.includes(`;`);
	        {
	            validateBrowserExpression(exp, context, false, hasMultipleStatements);
	        }
	        if (isInlineStatement || (shouldCache && isMemberExp)) {
	            // wrap inline statement in a function expression
	            exp = createCompoundExpression([
	                `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
	                exp,
	                hasMultipleStatements ? `}` : `)`
	            ]);
	        }
	    }
	    let ret = {
	        props: [
	            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
	        ]
	    };
	    // apply extended compiler augmentor
	    if (augmentor) {
	        ret = augmentor(ret);
	    }
	    if (shouldCache) {
	        // cache handlers so that it's always the same handler being passed down.
	        // this avoids unnecessary re-renders when users use inline handlers on
	        // components.
	        ret.props[0].value = context.cache(ret.props[0].value);
	    }
	    // mark the key as handler for props normalization check
	    ret.props.forEach(p => (p.key.isHandlerKey = true));
	    return ret;
	};

	// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
	// codegen for the entire props object. This transform here is only for v-bind
	// *with* args.
	const transformBind = (dir, _node, context) => {
	    const { exp, modifiers, loc } = dir;
	    const arg = dir.arg;
	    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {
	        arg.children.unshift(`(`);
	        arg.children.push(`) || ""`);
	    }
	    else if (!arg.isStatic) {
	        arg.content = `${arg.content} || ""`;
	    }
	    // .sync is replaced by v-model:arg
	    if (modifiers.includes('camel')) {
	        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
	            if (arg.isStatic) {
	                arg.content = camelize(arg.content);
	            }
	            else {
	                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
	            }
	        }
	        else {
	            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
	            arg.children.push(`)`);
	        }
	    }
	    if (!context.inSSR) {
	        if (modifiers.includes('prop')) {
	            injectPrefix(arg, '.');
	        }
	        if (modifiers.includes('attr')) {
	            injectPrefix(arg, '^');
	        }
	    }
	    if (!exp ||
	        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {
	        context.onError(createCompilerError(34 /* X_V_BIND_NO_EXPRESSION */, loc));
	        return {
	            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
	        };
	    }
	    return {
	        props: [createObjectProperty(arg, exp)]
	    };
	};
	const injectPrefix = (arg, prefix) => {
	    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
	        if (arg.isStatic) {
	            arg.content = prefix + arg.content;
	        }
	        else {
	            arg.content = `\`${prefix}\${${arg.content}}\``;
	        }
	    }
	    else {
	        arg.children.unshift(`'${prefix}' + (`);
	        arg.children.push(`)`);
	    }
	};

	// Merge adjacent text nodes and expressions into a single expression
	// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
	const transformText = (node, context) => {
	    if (node.type === 0 /* ROOT */ ||
	        node.type === 1 /* ELEMENT */ ||
	        node.type === 11 /* FOR */ ||
	        node.type === 10 /* IF_BRANCH */) {
	        // perform the transform on node exit so that all expressions have already
	        // been processed.
	        return () => {
	            const children = node.children;
	            let currentContainer = undefined;
	            let hasText = false;
	            for (let i = 0; i < children.length; i++) {
	                const child = children[i];
	                if (isText(child)) {
	                    hasText = true;
	                    for (let j = i + 1; j < children.length; j++) {
	                        const next = children[j];
	                        if (isText(next)) {
	                            if (!currentContainer) {
	                                currentContainer = children[i] = createCompoundExpression([child], child.loc);
	                            }
	                            // merge adjacent text node into current
	                            currentContainer.children.push(` + `, next);
	                            children.splice(j, 1);
	                            j--;
	                        }
	                        else {
	                            currentContainer = undefined;
	                            break;
	                        }
	                    }
	                }
	            }
	            if (!hasText ||
	                // if this is a plain element with a single text child, leave it
	                // as-is since the runtime has dedicated fast path for this by directly
	                // setting textContent of the element.
	                // for component root it's always normalized anyway.
	                (children.length === 1 &&
	                    (node.type === 0 /* ROOT */ ||
	                        (node.type === 1 /* ELEMENT */ &&
	                            node.tagType === 0 /* ELEMENT */ &&
	                            // #3756
	                            // custom directives can potentially add DOM elements arbitrarily,
	                            // we need to avoid setting textContent of the element at runtime
	                            // to avoid accidentally overwriting the DOM elements added
	                            // by the user through custom directives.
	                            !node.props.find(p => p.type === 7 /* DIRECTIVE */ &&
	                                !context.directiveTransforms[p.name]) &&
	                            // in compat mode, <template> tags with no special directives
	                            // will be rendered as a fragment so its children must be
	                            // converted into vnodes.
	                            !(false ))))) {
	                return;
	            }
	            // pre-convert text nodes into createTextVNode(text) calls to avoid
	            // runtime normalization.
	            for (let i = 0; i < children.length; i++) {
	                const child = children[i];
	                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
	                    const callArgs = [];
	                    // createTextVNode defaults to single whitespace, so if it is a
	                    // single space the code could be an empty call to save bytes.
	                    if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
	                        callArgs.push(child);
	                    }
	                    // mark dynamic text with flag so it gets patched inside a block
	                    if (!context.ssr &&
	                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
	                        callArgs.push(1 /* TEXT */ +
	                            (` /* ${PatchFlagNames[1 /* TEXT */]} */` ));
	                    }
	                    children[i] = {
	                        type: 12 /* TEXT_CALL */,
	                        content: child,
	                        loc: child.loc,
	                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
	                    };
	                }
	            }
	        };
	    }
	};

	const seen = new WeakSet();
	const transformOnce = (node, context) => {
	    if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
	        if (seen.has(node) || context.inVOnce) {
	            return;
	        }
	        seen.add(node);
	        context.inVOnce = true;
	        context.helper(SET_BLOCK_TRACKING);
	        return () => {
	            context.inVOnce = false;
	            const cur = context.currentNode;
	            if (cur.codegenNode) {
	                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
	            }
	        };
	    }
	};

	const transformModel = (dir, node, context) => {
	    const { exp, arg } = dir;
	    if (!exp) {
	        context.onError(createCompilerError(41 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
	        return createTransformProps();
	    }
	    const rawExp = exp.loc.source;
	    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;
	    // im SFC <script setup> inline mode, the exp may have been transformed into
	    // _unref(exp)
	    context.bindingMetadata[rawExp];
	    const maybeRef = !true    /* SETUP_CONST */;
	    if (!expString.trim() ||
	        (!isMemberExpression(expString) && !maybeRef)) {
	        context.onError(createCompilerError(42 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
	        return createTransformProps();
	    }
	    const propName = arg ? arg : createSimpleExpression('modelValue', true);
	    const eventName = arg
	        ? isStaticExp(arg)
	            ? `onUpdate:${arg.content}`
	            : createCompoundExpression(['"onUpdate:" + ', arg])
	        : `onUpdate:modelValue`;
	    let assignmentExp;
	    const eventArg = context.isTS ? `($event: any)` : `$event`;
	    {
	        assignmentExp = createCompoundExpression([
	            `${eventArg} => ((`,
	            exp,
	            `) = $event)`
	        ]);
	    }
	    const props = [
	        // modelValue: foo
	        createObjectProperty(propName, dir.exp),
	        // "onUpdate:modelValue": $event => (foo = $event)
	        createObjectProperty(eventName, assignmentExp)
	    ];
	    // modelModifiers: { foo: true, "bar-baz": true }
	    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
	        const modifiers = dir.modifiers
	            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
	            .join(`, `);
	        const modifiersKey = arg
	            ? isStaticExp(arg)
	                ? `${arg.content}Modifiers`
	                : createCompoundExpression([arg, ' + "Modifiers"'])
	            : `modelModifiers`;
	        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));
	    }
	    return createTransformProps(props);
	};
	function createTransformProps(props = []) {
	    return { props };
	}

	const seen$1 = new WeakSet();
	const transformMemo = (node, context) => {
	    if (node.type === 1 /* ELEMENT */) {
	        const dir = findDir(node, 'memo');
	        if (!dir || seen$1.has(node)) {
	            return;
	        }
	        seen$1.add(node);
	        return () => {
	            const codegenNode = node.codegenNode ||
	                context.currentNode.codegenNode;
	            if (codegenNode && codegenNode.type === 13 /* VNODE_CALL */) {
	                // non-component sub tree should be turned into a block
	                if (node.tagType !== 1 /* COMPONENT */) {
	                    makeBlock(codegenNode, context);
	                }
	                node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
	                    dir.exp,
	                    createFunctionExpression(undefined, codegenNode),
	                    `_cache`,
	                    String(context.cached++)
	                ]);
	            }
	        };
	    }
	};

	function getBaseTransformPreset(prefixIdentifiers) {
	    return [
	        [
	            transformOnce,
	            transformIf,
	            transformMemo,
	            transformFor,
	            ...([]),
	            ...([transformExpression]
	                    ),
	            transformSlotOutlet,
	            transformElement,
	            trackSlotScopes,
	            transformText
	        ],
	        {
	            on: transformOn,
	            bind: transformBind,
	            model: transformModel
	        }
	    ];
	}
	// we name it `baseCompile` so that higher order compilers like
	// @vue/compiler-dom can export `compile` while re-exporting everything else.
	function baseCompile(template, options = {}) {
	    const onError = options.onError || defaultOnError;
	    const isModuleMode = options.mode === 'module';
	    /* istanbul ignore if */
	    {
	        if (options.prefixIdentifiers === true) {
	            onError(createCompilerError(46 /* X_PREFIX_ID_NOT_SUPPORTED */));
	        }
	        else if (isModuleMode) {
	            onError(createCompilerError(47 /* X_MODULE_MODE_NOT_SUPPORTED */));
	        }
	    }
	    const prefixIdentifiers = !true ;
	    if (options.cacheHandlers) {
	        onError(createCompilerError(48 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
	    }
	    if (options.scopeId && !isModuleMode) {
	        onError(createCompilerError(49 /* X_SCOPE_ID_NOT_SUPPORTED */));
	    }
	    const ast = isString(template) ? baseParse(template, options) : template;
	    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
	    transform(ast, extend({}, options, {
	        prefixIdentifiers,
	        nodeTransforms: [
	            ...nodeTransforms,
	            ...(options.nodeTransforms || []) // user transforms
	        ],
	        directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms
	        )
	    }));
	    return generate(ast, extend({}, options, {
	        prefixIdentifiers
	    }));
	}

	const noopDirectiveTransform = () => ({ props: [] });

	const V_MODEL_RADIO = Symbol(`vModelRadio` );
	const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox` );
	const V_MODEL_TEXT = Symbol(`vModelText` );
	const V_MODEL_SELECT = Symbol(`vModelSelect` );
	const V_MODEL_DYNAMIC = Symbol(`vModelDynamic` );
	const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard` );
	const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard` );
	const V_SHOW = Symbol(`vShow` );
	const TRANSITION$1 = Symbol(`Transition` );
	const TRANSITION_GROUP = Symbol(`TransitionGroup` );
	registerRuntimeHelpers({
	    [V_MODEL_RADIO]: `vModelRadio`,
	    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
	    [V_MODEL_TEXT]: `vModelText`,
	    [V_MODEL_SELECT]: `vModelSelect`,
	    [V_MODEL_DYNAMIC]: `vModelDynamic`,
	    [V_ON_WITH_MODIFIERS]: `withModifiers`,
	    [V_ON_WITH_KEYS]: `withKeys`,
	    [V_SHOW]: `vShow`,
	    [TRANSITION$1]: `Transition`,
	    [TRANSITION_GROUP]: `TransitionGroup`
	});

	/* eslint-disable no-restricted-globals */
	let decoder;
	function decodeHtmlBrowser(raw, asAttr = false) {
	    if (!decoder) {
	        decoder = document.createElement('div');
	    }
	    if (asAttr) {
	        decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
	        return decoder.children[0].getAttribute('foo');
	    }
	    else {
	        decoder.innerHTML = raw;
	        return decoder.textContent;
	    }
	}

	const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);
	const parserOptions = {
	    isVoidTag,
	    isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
	    isPreTag: tag => tag === 'pre',
	    decodeEntities: decodeHtmlBrowser ,
	    isBuiltInComponent: (tag) => {
	        if (isBuiltInType(tag, `Transition`)) {
	            return TRANSITION$1;
	        }
	        else if (isBuiltInType(tag, `TransitionGroup`)) {
	            return TRANSITION_GROUP;
	        }
	    },
	    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
	    getNamespace(tag, parent) {
	        let ns = parent ? parent.ns : 0 /* HTML */;
	        if (parent && ns === 2 /* MATH_ML */) {
	            if (parent.tag === 'annotation-xml') {
	                if (tag === 'svg') {
	                    return 1 /* SVG */;
	                }
	                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
	                    a.name === 'encoding' &&
	                    a.value != null &&
	                    (a.value.content === 'text/html' ||
	                        a.value.content === 'application/xhtml+xml'))) {
	                    ns = 0 /* HTML */;
	                }
	            }
	            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
	                tag !== 'mglyph' &&
	                tag !== 'malignmark') {
	                ns = 0 /* HTML */;
	            }
	        }
	        else if (parent && ns === 1 /* SVG */) {
	            if (parent.tag === 'foreignObject' ||
	                parent.tag === 'desc' ||
	                parent.tag === 'title') {
	                ns = 0 /* HTML */;
	            }
	        }
	        if (ns === 0 /* HTML */) {
	            if (tag === 'svg') {
	                return 1 /* SVG */;
	            }
	            if (tag === 'math') {
	                return 2 /* MATH_ML */;
	            }
	        }
	        return ns;
	    },
	    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
	    getTextMode({ tag, ns }) {
	        if (ns === 0 /* HTML */) {
	            if (tag === 'textarea' || tag === 'title') {
	                return 1 /* RCDATA */;
	            }
	            if (isRawTextContainer(tag)) {
	                return 2 /* RAWTEXT */;
	            }
	        }
	        return 0 /* DATA */;
	    }
	};

	// Parse inline CSS strings for static style attributes into an object.
	// This is a NodeTransform since it works on the static `style` attribute and
	// converts it into a dynamic equivalent:
	// style="color: red" -> :style='{ "color": "red" }'
	// It is then processed by `transformElement` and included in the generated
	// props.
	const transformStyle = node => {
	    if (node.type === 1 /* ELEMENT */) {
	        node.props.forEach((p, i) => {
	            if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
	                // replace p with an expression node
	                node.props[i] = {
	                    type: 7 /* DIRECTIVE */,
	                    name: `bind`,
	                    arg: createSimpleExpression(`style`, true, p.loc),
	                    exp: parseInlineCSS(p.value.content, p.loc),
	                    modifiers: [],
	                    loc: p.loc
	                };
	            }
	        });
	    }
	};
	const parseInlineCSS = (cssText, loc) => {
	    const normalized = parseStringStyle(cssText);
	    return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);
	};

	function createDOMCompilerError(code, loc) {
	    return createCompilerError(code, loc, DOMErrorMessages );
	}
	const DOMErrorMessages = {
	    [50 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
	    [51 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
	    [52 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
	    [53 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
	    [54 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
	    [55 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
	    [56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
	    [57 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
	    [58 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
	    [59 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
	    [60 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
	};

	const transformVHtml = (dir, node, context) => {
	    const { exp, loc } = dir;
	    if (!exp) {
	        context.onError(createDOMCompilerError(50 /* X_V_HTML_NO_EXPRESSION */, loc));
	    }
	    if (node.children.length) {
	        context.onError(createDOMCompilerError(51 /* X_V_HTML_WITH_CHILDREN */, loc));
	        node.children.length = 0;
	    }
	    return {
	        props: [
	            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))
	        ]
	    };
	};

	const transformVText = (dir, node, context) => {
	    const { exp, loc } = dir;
	    if (!exp) {
	        context.onError(createDOMCompilerError(52 /* X_V_TEXT_NO_EXPRESSION */, loc));
	    }
	    if (node.children.length) {
	        context.onError(createDOMCompilerError(53 /* X_V_TEXT_WITH_CHILDREN */, loc));
	        node.children.length = 0;
	    }
	    return {
	        props: [
	            createObjectProperty(createSimpleExpression(`textContent`, true), exp
	                ? getConstantType(exp, context) > 0
	                    ? exp
	                    : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)
	                : createSimpleExpression('', true))
	        ]
	    };
	};

	const transformModel$1 = (dir, node, context) => {
	    const baseResult = transformModel(dir, node, context);
	    // base transform has errors OR component v-model (only need props)
	    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
	        return baseResult;
	    }
	    if (dir.arg) {
	        context.onError(createDOMCompilerError(55 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
	    }
	    function checkDuplicatedValue() {
	        const value = findProp(node, 'value');
	        if (value) {
	            context.onError(createDOMCompilerError(57 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
	        }
	    }
	    const { tag } = node;
	    const isCustomElement = context.isCustomElement(tag);
	    if (tag === 'input' ||
	        tag === 'textarea' ||
	        tag === 'select' ||
	        isCustomElement) {
	        let directiveToUse = V_MODEL_TEXT;
	        let isInvalidType = false;
	        if (tag === 'input' || isCustomElement) {
	            const type = findProp(node, `type`);
	            if (type) {
	                if (type.type === 7 /* DIRECTIVE */) {
	                    // :type="foo"
	                    directiveToUse = V_MODEL_DYNAMIC;
	                }
	                else if (type.value) {
	                    switch (type.value.content) {
	                        case 'radio':
	                            directiveToUse = V_MODEL_RADIO;
	                            break;
	                        case 'checkbox':
	                            directiveToUse = V_MODEL_CHECKBOX;
	                            break;
	                        case 'file':
	                            isInvalidType = true;
	                            context.onError(createDOMCompilerError(56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
	                            break;
	                        default:
	                            // text type
	                            checkDuplicatedValue();
	                            break;
	                    }
	                }
	            }
	            else if (hasDynamicKeyVBind(node)) {
	                // element has bindings with dynamic keys, which can possibly contain
	                // "type".
	                directiveToUse = V_MODEL_DYNAMIC;
	            }
	            else {
	                // text type
	                checkDuplicatedValue();
	            }
	        }
	        else if (tag === 'select') {
	            directiveToUse = V_MODEL_SELECT;
	        }
	        else {
	            // textarea
	            checkDuplicatedValue();
	        }
	        // inject runtime directive
	        // by returning the helper symbol via needRuntime
	        // the import will replaced a resolveDirective call.
	        if (!isInvalidType) {
	            baseResult.needRuntime = context.helper(directiveToUse);
	        }
	    }
	    else {
	        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
	    }
	    // native vmodel doesn't need the `modelValue` props since they are also
	    // passed to the runtime as `binding.value`. removing it reduces code size.
	    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
	        p.key.content === 'modelValue'));
	    return baseResult;
	};

	const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);
	const isNonKeyModifier = /*#__PURE__*/ makeMap(
	// event propagation management
`stop,prevent,self,`	 +
	    // system modifiers + exact
	    `ctrl,shift,alt,meta,exact,` +
	    // mouse
	    `middle`);
	// left & right could be mouse or key modifiers based on event type
	const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');
	const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);
	const resolveModifiers = (key, modifiers, context, loc) => {
	    const keyModifiers = [];
	    const nonKeyModifiers = [];
	    const eventOptionModifiers = [];
	    for (let i = 0; i < modifiers.length; i++) {
	        const modifier = modifiers[i];
	        if (isEventOptionModifier(modifier)) {
	            // eventOptionModifiers: modifiers for addEventListener() options,
	            // e.g. .passive & .capture
	            eventOptionModifiers.push(modifier);
	        }
	        else {
	            // runtimeModifiers: modifiers that needs runtime guards
	            if (maybeKeyModifier(modifier)) {
	                if (isStaticExp(key)) {
	                    if (isKeyboardEvent(key.content)) {
	                        keyModifiers.push(modifier);
	                    }
	                    else {
	                        nonKeyModifiers.push(modifier);
	                    }
	                }
	                else {
	                    keyModifiers.push(modifier);
	                    nonKeyModifiers.push(modifier);
	                }
	            }
	            else {
	                if (isNonKeyModifier(modifier)) {
	                    nonKeyModifiers.push(modifier);
	                }
	                else {
	                    keyModifiers.push(modifier);
	                }
	            }
	        }
	    }
	    return {
	        keyModifiers,
	        nonKeyModifiers,
	        eventOptionModifiers
	    };
	};
	const transformClick = (key, event) => {
	    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';
	    return isStaticClick
	        ? createSimpleExpression(event, true)
	        : key.type !== 4 /* SIMPLE_EXPRESSION */
	            ? createCompoundExpression([
	                `(`,
	                key,
	                `) === "onClick" ? "${event}" : (`,
	                key,
	                `)`
	            ])
	            : key;
	};
	const transformOn$1 = (dir, node, context) => {
	    return transformOn(dir, node, context, baseResult => {
	        const { modifiers } = dir;
	        if (!modifiers.length)
	            return baseResult;
	        let { key, value: handlerExp } = baseResult.props[0];
	        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
	        // normalize click.right and click.middle since they don't actually fire
	        if (nonKeyModifiers.includes('right')) {
	            key = transformClick(key, `onContextmenu`);
	        }
	        if (nonKeyModifiers.includes('middle')) {
	            key = transformClick(key, `onMouseup`);
	        }
	        if (nonKeyModifiers.length) {
	            handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
	                handlerExp,
	                JSON.stringify(nonKeyModifiers)
	            ]);
	        }
	        if (keyModifiers.length &&
	            // if event name is dynamic, always wrap with keys guard
	            (!isStaticExp(key) || isKeyboardEvent(key.content))) {
	            handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
	                handlerExp,
	                JSON.stringify(keyModifiers)
	            ]);
	        }
	        if (eventOptionModifiers.length) {
	            const modifierPostfix = eventOptionModifiers.map(capitalize).join('');
	            key = isStaticExp(key)
	                ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
	                : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
	        }
	        return {
	            props: [createObjectProperty(key, handlerExp)]
	        };
	    });
	};

	const transformShow = (dir, node, context) => {
	    const { exp, loc } = dir;
	    if (!exp) {
	        context.onError(createDOMCompilerError(58 /* X_V_SHOW_NO_EXPRESSION */, loc));
	    }
	    return {
	        props: [],
	        needRuntime: context.helper(V_SHOW)
	    };
	};

	const transformTransition = (node, context) => {
	    if (node.type === 1 /* ELEMENT */ &&
	        node.tagType === 1 /* COMPONENT */) {
	        const component = context.isBuiltInComponent(node.tag);
	        if (component === TRANSITION$1) {
	            return () => {
	                if (!node.children.length) {
	                    return;
	                }
	                // warn multiple transition children
	                if (hasMultipleChildren(node)) {
	                    context.onError(createDOMCompilerError(59 /* X_TRANSITION_INVALID_CHILDREN */, {
	                        start: node.children[0].loc.start,
	                        end: node.children[node.children.length - 1].loc.end,
	                        source: ''
	                    }));
	                }
	                // check if it's s single child w/ v-show
	                // if yes, inject "persisted: true" to the transition props
	                const child = node.children[0];
	                if (child.type === 1 /* ELEMENT */) {
	                    for (const p of child.props) {
	                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'show') {
	                            node.props.push({
	                                type: 6 /* ATTRIBUTE */,
	                                name: 'persisted',
	                                value: undefined,
	                                loc: node.loc
	                            });
	                        }
	                    }
	                }
	            };
	        }
	    }
	};
	function hasMultipleChildren(node) {
	    // #1352 filter out potential comment nodes.
	    const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */ &&
	        !(c.type === 2 /* TEXT */ && !c.content.trim())));
	    const child = children[0];
	    return (children.length !== 1 ||
	        child.type === 11 /* FOR */ ||
	        (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
	}

	const ignoreSideEffectTags = (node, context) => {
	    if (node.type === 1 /* ELEMENT */ &&
	        node.tagType === 0 /* ELEMENT */ &&
	        (node.tag === 'script' || node.tag === 'style')) {
	        context.onError(createDOMCompilerError(60 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
	        context.removeNode();
	    }
	};

	const DOMNodeTransforms = [
	    transformStyle,
	    ...([transformTransition] )
	];
	const DOMDirectiveTransforms = {
	    cloak: noopDirectiveTransform,
	    html: transformVHtml,
	    text: transformVText,
	    model: transformModel$1,
	    on: transformOn$1,
	    show: transformShow
	};
	function compile$1(template, options = {}) {
	    return baseCompile(template, extend({}, parserOptions, options, {
	        nodeTransforms: [
	            // ignore <script> and <tag>
	            // this is not put inside DOMNodeTransforms because that list is used
	            // by compiler-ssr to generate vnode fallback branches
	            ignoreSideEffectTags,
	            ...DOMNodeTransforms,
	            ...(options.nodeTransforms || [])
	        ],
	        directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
	        transformHoist: null 
	    }));
	}

	// This entry is the "full-build" that includes both the runtime
	{
	    initDev();
	}
	const compileCache = Object.create(null);
	function compileToFunction(template, options) {
	    if (!isString(template)) {
	        if (template.nodeType) {
	            template = template.innerHTML;
	        }
	        else {
	            warn$1(`invalid template option: `, template);
	            return NOOP;
	        }
	    }
	    const key = template;
	    const cached = compileCache[key];
	    if (cached) {
	        return cached;
	    }
	    if (template[0] === '#') {
	        const el = document.querySelector(template);
	        if (!el) {
	            warn$1(`Template element not found or is empty: ${template}`);
	        }
	        // __UNSAFE__
	        // Reason: potential execution of JS expressions in in-DOM template.
	        // The user must make sure the in-DOM template is trusted. If it's rendered
	        // by the server, the template should not contain any user data.
	        template = el ? el.innerHTML : ``;
	    }
	    const { code } = compile$1(template, extend({
	        hoistStatic: true,
	        onError: onError ,
	        onWarn: e => onError(e, true) 
	    }, options));
	    function onError(err, asWarning = false) {
	        const message = asWarning
	            ? err.message
	            : `Template compilation error: ${err.message}`;
	        const codeFrame = err.loc &&
	            generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
	        warn$1(codeFrame ? `${message}\n${codeFrame}` : message);
	    }
	    // The wildcard import results in a huge object with every export
	    // with keys that cannot be mangled, and can be quite heavy size-wise.
	    // In the global build we know `Vue` is available globally so we can avoid
	    // the wildcard object.
	    const render = (new Function('Vue', code)(runtimeDom));
	    render._rc = true;
	    return (compileCache[key] = render);
	}
	registerRuntimeCompiler(compileToFunction);

	var Vue = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BaseTransition: BaseTransition,
		Comment: Comment,
		EffectScope: EffectScope,
		Fragment: Fragment,
		KeepAlive: KeepAlive,
		ReactiveEffect: ReactiveEffect,
		Static: Static,
		Suspense: Suspense,
		Teleport: Teleport,
		Text: Text,
		Transition: Transition,
		TransitionGroup: TransitionGroup,
		VueElement: VueElement,
		callWithAsyncErrorHandling: callWithAsyncErrorHandling,
		callWithErrorHandling: callWithErrorHandling,
		camelize: camelize,
		capitalize: capitalize,
		cloneVNode: cloneVNode,
		compatUtils: compatUtils,
		compile: compileToFunction,
		computed: computed$1,
		createApp: createApp,
		createBlock: createBlock,
		createCommentVNode: createCommentVNode,
		createElementBlock: createElementBlock,
		createElementVNode: createBaseVNode,
		createHydrationRenderer: createHydrationRenderer,
		createPropsRestProxy: createPropsRestProxy,
		createRenderer: createRenderer,
		createSSRApp: createSSRApp,
		createSlots: createSlots,
		createStaticVNode: createStaticVNode,
		createTextVNode: createTextVNode,
		createVNode: createVNode,
		customRef: customRef,
		defineAsyncComponent: defineAsyncComponent,
		defineComponent: defineComponent,
		defineCustomElement: defineCustomElement,
		defineEmits: defineEmits,
		defineExpose: defineExpose,
		defineProps: defineProps,
		defineSSRCustomElement: defineSSRCustomElement,
		get devtools () { return devtools; },
		effect: effect,
		effectScope: effectScope,
		getCurrentInstance: getCurrentInstance,
		getCurrentScope: getCurrentScope,
		getTransitionRawChildren: getTransitionRawChildren,
		guardReactiveProps: guardReactiveProps,
		h: h,
		handleError: handleError,
		hydrate: hydrate,
		initCustomFormatter: initCustomFormatter,
		initDirectivesForSSR: initDirectivesForSSR,
		inject: inject,
		isMemoSame: isMemoSame,
		isProxy: isProxy,
		isReactive: isReactive,
		isReadonly: isReadonly,
		isRef: isRef,
		isRuntimeOnly: isRuntimeOnly,
		isShallow: isShallow,
		isVNode: isVNode,
		markRaw: markRaw,
		mergeDefaults: mergeDefaults,
		mergeProps: mergeProps,
		nextTick: nextTick,
		normalizeClass: normalizeClass,
		normalizeProps: normalizeProps,
		normalizeStyle: normalizeStyle,
		onActivated: onActivated,
		onBeforeMount: onBeforeMount,
		onBeforeUnmount: onBeforeUnmount,
		onBeforeUpdate: onBeforeUpdate,
		onDeactivated: onDeactivated,
		onErrorCaptured: onErrorCaptured,
		onMounted: onMounted,
		onRenderTracked: onRenderTracked,
		onRenderTriggered: onRenderTriggered,
		onScopeDispose: onScopeDispose,
		onServerPrefetch: onServerPrefetch,
		onUnmounted: onUnmounted,
		onUpdated: onUpdated,
		openBlock: openBlock,
		popScopeId: popScopeId,
		provide: provide,
		proxyRefs: proxyRefs,
		pushScopeId: pushScopeId,
		queuePostFlushCb: queuePostFlushCb,
		reactive: reactive,
		readonly: readonly,
		ref: ref,
		registerRuntimeCompiler: registerRuntimeCompiler,
		render: render$l,
		renderList: renderList,
		renderSlot: renderSlot,
		resolveComponent: resolveComponent,
		resolveDirective: resolveDirective,
		resolveDynamicComponent: resolveDynamicComponent,
		resolveFilter: resolveFilter,
		resolveTransitionHooks: resolveTransitionHooks,
		setBlockTracking: setBlockTracking,
		setDevtoolsHook: setDevtoolsHook,
		setTransitionHooks: setTransitionHooks,
		shallowReactive: shallowReactive,
		shallowReadonly: shallowReadonly,
		shallowRef: shallowRef,
		ssrContextKey: ssrContextKey,
		ssrUtils: ssrUtils,
		stop: stop,
		toDisplayString: toDisplayString,
		toHandlerKey: toHandlerKey,
		toHandlers: toHandlers,
		toRaw: toRaw,
		toRef: toRef,
		toRefs: toRefs,
		transformVNodeArgs: transformVNodeArgs,
		triggerRef: triggerRef,
		unref: unref,
		useAttrs: useAttrs,
		useCssModule: useCssModule,
		useCssVars: useCssVars,
		useSSRContext: useSSRContext,
		useSlots: useSlots,
		useTransitionState: useTransitionState,
		vModelCheckbox: vModelCheckbox,
		vModelDynamic: vModelDynamic,
		vModelRadio: vModelRadio,
		vModelSelect: vModelSelect,
		vModelText: vModelText,
		vShow: vShow,
		version: version,
		warn: warn$1,
		watch: watch,
		watchEffect: watchEffect,
		watchPostEffect: watchPostEffect,
		watchSyncEffect: watchSyncEffect,
		withAsyncContext: withAsyncContext,
		withCtx: withCtx,
		withDefaults: withDefaults,
		withDirectives: withDirectives,
		withKeys: withKeys,
		withMemo: withMemo,
		withModifiers: withModifiers,
		withScopeId: withScopeId
	});

	var script$B = {
	    components: {
	    },
	    props: {
		id: String,
		chart_type: String,
		register_on_status_change: Boolean,
		base_url_request: String,
		get_params_url_request: Function,
		get_custom_chart_options: Function,
	    },
	    emits: ["apply", "hidden", "showed", "chart_reloaded", "zoom"],
	    /** This method is the first method of the component called, it's called before html template creation. */
	    created() {
	    },
	    beforeUnmount() {
		this.chart.destroyChart();
	    },
	    data() {
		return {
		    chart: null,
		    chart_options: null,
		    from_zoom: false,
		    //i18n: (t) => i18n(t),
		};
	    },
	    /** This method is the first method called after html template creation. */
	    async mounted() {
		await this.init();
		ntopng_sync.ready(this.$props["id"]);
	    },
	    methods: {
		init: async function() {
		    let status = ntopng_status_manager.get_status();
		    let url_request = this.get_url_request(status);
		    if (this.register_on_status_change) {
			this.register_status(status);
		    }
		    await this.draw_chart(url_request);
		},
		register_status: function(status) {
		    let url_request = this.get_url_request(status);
		    ntopng_status_manager.on_status_change(this.id, (new_status) => {
			if (this.from_zoom == true) {
			    this.from_zoom = false;
			    //return;
			}
			let new_url_request = this.get_url_request(new_status);
			if (new_url_request == url_request) {
			    url_request = new_url_request;
			    return;
			}
			url_request = new_url_request;
			this.update_chart(new_url_request);
		    }, false);
		},
		get_url_request: function(status) {
		    let url_params;
		    if (this.get_params_url_request != null) {
			if (status == null) {
			    status = ntopng_status_manager.get_status();
			}
			url_params = this.get_params_url_request(status);
		    } else {
			url_params = ntopng_url_manager.get_url_params();
		    }
		    
		    return `${this.base_url_request}?${url_params}`;
		},
		draw_chart: async function(url_request) {
		    let chartApex = ntopChartApex;
		    let chart_type = this.chart_type;
		    if (chart_type == null) {
			chart_type = chartApex.typeChart.TS_STACKED;
		    }
		    this.chart = chartApex.newChart(chart_type);
		    this.chart.registerEvent("zoomed", (chart_context, axis) => this.on_zoomed(chart_context, axis));
		    let chart_options = await this.get_chart_options(url_request);
		    this.chart.drawChart(this.$refs["chart"], chart_options);
		},
		update_chart: async function(url_request) {
		    let chart_options = await this.get_chart_options(url_request);
		    this.chart.updateChart(chart_options);
		},
		get_chart_options: async function(url_request) {
		    let chart_options;
		    if (this.get_custom_chart_options == null) {		
			chart_options = await ntopng_utility.http_request(url_request);
		    } else {
			chart_options = await this.get_custom_chart_options(url_request);
		    }
		    this.$emit('chart_reloaded', chart_options);
		    return chart_options;
		},
		on_zoomed: function(chart_context, { xaxis, yaxis }) {
		    this.from_zoom = true;
	            const begin = moment(xaxis.min);
	            const end = moment(xaxis.max);
	            // the timestamps are in milliseconds, convert them into seconds
		    let new_epoch_status = { epoch_begin: Number.parseInt(begin.unix()), epoch_end: Number.parseInt(end.unix()) };
		    ntopng_events_manager.emit_event(ntopng_events.EPOCH_CHANGE, new_epoch_status, this.id);
		    this.$emit('zoom', new_epoch_status);
		},
	    },
	};

	const _hoisted_1$y = {
	  style: {"width":"100%"},
	  ref: "chart"
	};

	function render$k(_ctx, _cache, $props, $setup, $data, $options) {
	  return (openBlock(), createElementBlock("div", _hoisted_1$y, null, 512 /* NEED_PATCH */))
	}

	script$B.render = render$k;
	script$B.__file = "http_src/vue/chart.vue";

	const _hoisted_1$x = ["selected", "value", "disabled"];
	const _hoisted_2$v = ["label"];
	const _hoisted_3$t = ["selected", "value", "disabled"];


	var script$A = {
	  __name: 'select-search',
	  props: {
	    id: String,
	    options: Array,
	    selected_option: Object,
	    disable_change: Boolean,
	},
	  emits: ['update:selected_option', 'select_option'],
	  setup(__props, { expose, emit }) {

	const props = __props;

	const select2 = ref(null);

	// const selected2_option = ref({});



	const options_2 = ref([]);
	const groups_options_2 = ref([]);
	const selected_option_2 = ref({});



	function get_props_selected_option() {
	    if (props.selected_option == null) {
		return props.options[0];
	    }
	    return props.selected_option;
	}

	function set_selected_option(selected_option) {
	    if (selected_option == null) {
		selected_option = get_props_selected_option();
	    }
	    selected_option_2.value = selected_option;
	    if (selected_option_2.value.value == null) {
		selected_option_2.value.value = selected_option.label;
	    }
	}

	watch(() => props.selected_option, (cur_value, old_value) => {
	    set_selected_option(cur_value);
	    let select2Div = select2.value;
	    let value = get_value_from_selected_option(cur_value);
		$(select2Div).val(value);
		$(select2Div).trigger("change");
	    // }
	}, { flush: 'pre'});

	function get_value_from_selected_option(selected_option) {
	    if (selected_option == null) {
		selected_option = get_props_selected_option();
	    }
	    let value;
	    if (selected_option.value) {
		value = selected_option.value;
	    } else {
		value = selected_option.label;
	    }
	    return value;
	}

	function find_option_2_from_value(value) {
	    if (value == null) {
		value = get_value_from_selected_option();
	    }
	    // let option = options_2.value.find((o) => o.value == value);
	    let option = options_2.value.find((o) => o.value == value);
	    if (option != null) { return option; }
	    for (let i = 0; i < groups_options_2.value.length; i += 1) {
		let g = groups_options_2.value[i];
		option = g.options.find((o) => o.value == value);
		if (option != null) {
		    return option;
		}
	    }
	    return null;
	}

	let first_time_render = true;

	watch(() => props.options, (current_value, old_value) => {    
	    if (props.disable_change == true) { return; }    
	    set_input();
	}, { flush: 'pre'});

	onMounted(() => {
	    if (!props.disable_change || !first_time_render) {
	    	set_input();
	    }
	});

	function set_options() {
	    options_2.value = [];
	    groups_options_2.value = [];
	    
	    if (props.options == null) { return; }
	    let groups_dict = {};
	    props.options.forEach((option) => {
		let opt_2 = { ...option };
		if (opt_2.value == 0 || opt_2.value == "0") {
		    opt_2.value = null;
		}
		if (opt_2.value == null) {
		    opt_2.value = opt_2.label;
		}
		if (option.group == null) {
		    options_2.value.push(opt_2);
		} else {
		    if (groups_dict[option.group] == null) {
			groups_dict[option.group] = { group: opt_2.group, options: [] };
		    }
		    groups_dict[option.group].options.push(opt_2);
		}
	    });
	    groups_options_2.value = ntopng_utility.object_to_array(groups_dict);
	    
	}

	watch([options_2, groups_options_2], (cur_value, old_value) => {
	    render();
	}, { flush: 'post'});

	function set_input() {
	    set_options();
	    set_selected_option();
	}

	const render = () => {
	    let select2Div = select2.value;
	    if (first_time_render == false) {
		destroy();
	    }
	    if (!$(select2Div).hasClass("select2-hidden-accessible")) {
		$(select2Div).select2({
		    width: '100%',
		    height: '500px',
		    theme: 'bootstrap-5',
		    dropdownParent: $(select2Div).parent(),
		    dropdownAutoWidth : true
		});
		$(select2Div).on('select2:select', function (e) {
		    let data = e.params.data;
		    let value = data.element._value;
		    let option_2 = find_option_2_from_value(value);
		    let option = props.options.find((o) => o.label == option_2.label);
		    if (value != props.selected_option) {
			// emit('update:selected_option', value);
			// emit('select_option', value);
			emit('update:selected_option', option);
			emit('select_option', option);
		    }
		});
	    }
	    first_time_render = false;
	    // this.$forceUpdate();
	    // $(select2Div).val(props.selected_option);
	};

	expose({ render });

	function destroy() {
	    try {
		$(select2.value).select2('destroy');
		$(select2.value).off('select2:select');    
	    } catch(err) {
		console.error("Destroy select-search catch error:");
		console.error(err);
	    }
	}

	onBeforeUnmount(() => {
	    destroy();
	});


	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock("select", {
	    class: "select2 form-select",
	    ref_key: "select2",
	    ref: select2,
	    required: "",
	    name: "filter_type"
	  }, [
	    (openBlock(true), createElementBlock(Fragment, null, renderList(options_2.value, (item, i) => {
	      return (openBlock(), createElementBlock("option", {
	        selected: (item.value == selected_option_2.value.value),
	        value: item.value,
	        disabled: item.disabled
	      }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_1$x))
	    }), 256 /* UNKEYED_FRAGMENT */)),
	    (openBlock(true), createElementBlock(Fragment, null, renderList(groups_options_2.value, (item, i) => {
	      return (openBlock(), createElementBlock("optgroup", {
	        label: item.group
	      }, [
	        (openBlock(true), createElementBlock(Fragment, null, renderList(item.options, (opt, j) => {
	          return (openBlock(), createElementBlock("option", {
	            selected: (item.value == selected_option_2.value.value),
	            value: opt.value,
	            disabled: opt.disabled
	          }, toDisplayString(opt.label), 9 /* TEXT, PROPS */, _hoisted_3$t))
	        }), 256 /* UNKEYED_FRAGMENT */))
	      ], 8 /* PROPS */, _hoisted_2$v))
	    }), 256 /* UNKEYED_FRAGMENT */))
	  ], 512 /* NEED_PATCH */))
	}
	}

	};

	script$A.__file = "http_src/vue/select-search.vue";

	var script$z = {
	    components: {
		'select-search': script$A,
	    },
	    props: {
		id: String,
		enable_refresh: Boolean,
	    },
	    watch: {
		"enable_refresh": function(val, oldVal) {
		    if (val == true) {
			this.start_refresh();
		    } else if (this.refresh_interval != null) {
			clearInterval(this.refresh_interval);
			this.refresh_interval = null;
		    }
		}
	    },	
	    emits: ["epoch_change"],
	    /** This method is the first method of the component called, it's called before html template creation. */
	    created() {	
	    },
	    /** This method is the first method called after html template creation. */
	    mounted() {
		let epoch_begin = ntopng_url_manager.get_url_entry("epoch_begin");
		let epoch_end = ntopng_url_manager.get_url_entry("epoch_end");
		if (epoch_begin != null && epoch_end != null) {
		    // update the status
		    
	            ntopng_events_manager.emit_event(ntopng_events.EPOCH_CHANGE, { epoch_begin: Number.parseInt(epoch_begin), epoch_end: Number.parseInt(epoch_end) }, this.$props.id);
		}
		let me = this;
		let f_set_picker = (picker, var_name) => {
		    return flatpickr($(this.$refs[picker]), {
			enableTime: true,
			dateFormat: "d/m/Y H:i",
			//altInput: true,
			//dateFormat: "YYYY-MM-DD HH:mm",
			//altFormat: "d-m-Y H:i",
			//locale: "it",
			time_24hr: true,
			clickOpens: true,		
			//mode: "range",
			//static: true,
			onChange: function(selectedDates, dateStr, instance) {
			    me.enable_apply = true;
			    me.wrong_date = me.flat_begin_date.selectedDates[0].getTime() > me.flat_end_date.selectedDates[0].getTime();
			    //me.a[data] = d;
			},
		    });
		};
		this.flat_begin_date = f_set_picker("begin-date");
		this.flat_end_date = f_set_picker("end-date");
	        ntopng_events_manager.on_event_change(this.$props.id, ntopng_events.EPOCH_CHANGE, (new_status) => this.on_status_updated(new_status), true);
		
		// notifies that component is ready
		//console.log(this.$props["id"]);
		ntopng_sync.ready(this.$props["id"]);
		if (this.enable_refresh) {
		    this.start_refresh();
		}
	    },
	    
	    /** Methods of the component. */
	    methods: {
		start_refresh: function() {
		    this.refresh_interval = setInterval(() => {
			let value = this.selected_time_option?.value;
			if (this.enable_refresh && value != null && value != "custom") {
			    this.update_from_interval = true;
			    this.change_select_time();
			}
		    }, this.refresh_interval_seconds);
		},
		utc_s_to_server_date: function(utc_seconds) {
		    let utc = utc_seconds * 1000;
		    let d_local = new Date(utc);
		    let local_offset = d_local.getTimezoneOffset();
		    let server_offset = moment.tz(utc, ntop_zoneinfo)._offset;
		    let offset_minutes =  server_offset + local_offset;
		    let offset_ms = offset_minutes * 1000 * 60;
		    var d_server = new Date(utc + offset_ms);
		    return d_server;
		},
		server_date_to_date: function(date, format) {
		    let utc = date.getTime();
		    let local_offset = date.getTimezoneOffset();
		    let server_offset = moment.tz(utc, ntop_zoneinfo)._offset;
		    let offset_minutes =  server_offset + local_offset;
		    let offset_ms = offset_minutes * 1000 * 60;
		    var d_local = new Date(utc - offset_ms);
		    return d_local;
		},
	        on_status_updated: function(status) {
	            let end_date_time_utc = Date.now();        
	            // default begin date time now - 30 minutes
	            let begin_date_time_utc = end_date_time_utc - 30 * 60 * 1000;
	            if (status.epoch_end != null && status.epoch_begin != null
			&& Number.parseInt(status.epoch_end) > Number.parseInt(status.epoch_begin)) {
			status.epoch_begin = Number.parseInt(status.epoch_begin);
			status.epoch_end = Number.parseInt(status.epoch_end);
	                end_date_time_utc = status.epoch_end * 1000;
	                begin_date_time_utc = status.epoch_begin * 1000;
	            } else {
	                status.epoch_end = this.get_utc_seconds(end_date_time_utc);
	                status.epoch_begin = this.get_utc_seconds(begin_date_time_utc);
			ntopng_url_manager.add_obj_to_url(status);
	                this.emit_epoch_change(status, this.$props.id);
	            }
		    // this.flat_begin_date.setDate(new Date(status.epoch_begin * 1000));
		    // this.flat_end_date.setDate(new Date(status.epoch_end * 1000));
		    this.flat_begin_date.setDate(this.utc_s_to_server_date(status.epoch_begin));
		    this.flat_end_date.setDate(this.utc_s_to_server_date(status.epoch_end));
	            // this.set_date_time("begin-date", begin_date_time_utc, false);
	            // this.set_date_time("begin-time", begin_date_time_utc, true);
	            // this.set_date_time("end-date", end_date_time_utc, false);
	            // this.set_date_time("end-time", end_date_time_utc, true);
	            this.set_select_time_value(begin_date_time_utc, end_date_time_utc);
	            this.epoch_status = { epoch_begin: status.epoch_begin, epoch_end: status.epoch_end };
		    if (this.update_from_interval == false) {
			this.add_status_in_history(this.epoch_status);
		    }
	            this.enable_apply = false;
		    this.update_from_interval = false;
		    ntopng_url_manager.add_obj_to_url(this.epoch_status);
	        },
	        set_select_time_value: function(begin_utc, end_utc) {
	            let s_values = this.get_select_values();
	            const tolerance = 60;
	            const now = this.get_utc_seconds(Date.now());
	            const end_utc_s = this.get_utc_seconds(end_utc);
	            const begin_utc_s = this.get_utc_seconds(begin_utc);

		    
	            if (this.is_between(end_utc_s, now, tolerance)) {
	                if (this.is_between(begin_utc_s, now - s_values.min_5, tolerance)) {
	                    this.select_time_value = "min_5";
	                } else if (this.is_between(begin_utc_s, now - s_values.min_30, tolerance)) {
	                    this.select_time_value = "min_30";
	                } else if (this.is_between(begin_utc_s, now - s_values.hour, tolerance)) {
	                    this.select_time_value = "hour";
	                } else if (this.is_between(begin_utc_s, now - s_values.day, tolerance)) {
	                    this.select_time_value = "day";
	                } else if (this.is_between(begin_utc_s, now - s_values.week, tolerance)) {
	                    this.select_time_value = "week";
	                } else if (this.is_between(begin_utc_s, now - s_values.month, tolerance)) {
	                    this.select_time_value = "month";
	                } else if (this.is_between(begin_utc_s, now - s_values.year, tolerance)) {
	                    this.select_time_value = "year";
	                } else {
	                    this.select_time_value = "custom";
	                }
	            } else {
	                this.select_time_value = "custom";
	            }
	            
	            this.time_preset_list.forEach(element => {
	              element.currently_active = false;
	              if(element.value == this.select_time_value) {
	                this.selected_time_option = element;
	                element.currently_active = true;
	              }
	            });
	        },
	        apply: function() {
	            // let date_begin = this.$refs["begin-date"].valueAsDate;
	            // let d_time_begin = this.$refs["begin-time"].valueAsDate;
	            // date_begin.setHours(d_time_begin.getHours());
	            // date_begin.setMinutes(d_time_begin.getMinutes() + d_time_begin.getTimezoneOffset());
	            // date_begin.setSeconds(d_time_begin.getSeconds());
	            
	            // let date_end = this.$refs["end-date"].valueAsDate;
	            // let d_time_end = this.$refs["end-time"].valueAsDate;
	            // date_end.setHours(d_time_end.getHours());
	            // date_end.setMinutes(d_time_end.getMinutes() + d_time_end.getTimezoneOffset());
	            // date_end.setSeconds(d_time_end.getSeconds());
	            // let epoch_begin = this.get_utc_seconds(date_begin.valueOf());
	            // let epoch_end = this.get_utc_seconds(date_end.valueOf());
		    let now_s = this.get_utc_seconds(Date.now());
		    let begin_date = this.server_date_to_date(this.flat_begin_date.selectedDates[0]);
		    let epoch_begin = this.get_utc_seconds(begin_date.getTime());
		    let end_date = this.server_date_to_date(this.flat_end_date.selectedDates[0]);
		    let epoch_end = this.get_utc_seconds(end_date.getTime());
		    if (epoch_end > now_s) {
			epoch_end = now_s;
		    }
	            let status = { epoch_begin , epoch_end };
	            this.emit_epoch_change(status);
	        },
	        // set_date_time: function(ref_name, utc_ts, is_time) {
	        //     utc_ts = this.get_utc_seconds(utc_ts) * 1000;        
	        //     let date_time = new Date(utc_ts);
	        //     date_time.setMinutes(date_time.getMinutes() - date_time.getTimezoneOffset());
		//     if (is_time) {
		// 	this.$refs[ref_name].value = date_time.toISOString().substring(11,16);
		//     } else {
		// 	this.$refs[ref_name].value = date_time.toISOString().substring(0,10);
		//     }
	        // },
	        change_select_time: function() {
	            let s_values = this.get_select_values();
	            let interval_s = s_values[this.selected_time_option.value];
	            let epoch_end = this.get_utc_seconds(Date.now());
	            let epoch_begin = epoch_end - interval_s;
	            let status = { epoch_begin: epoch_begin, epoch_end: epoch_end };
	            this.emit_epoch_change(status);
	        },
	        get_select_values: function() {
	            let min = 60;
	            return {
	                min_5: min * 5,
	                min_30: min * 30,
	                hour: min * 60,
	                day: this.get_last_day_seconds(), 
	                week: this.get_last_week_seconds(), 
	                month: this.get_last_month_seconds(), 
	                year: this.get_last_year_seconds(),
	            };
	        },
	        get_utc_seconds: function(utc_ts) {
	            return Number.parseInt(utc_ts / 1000);
	        },
	        is_between: function(x, y, tolerance) {
	            return x >= y - tolerance && x <= y;
	        },
	        get_last_day_seconds: function() {
	            let t = new Date();
	            return this.get_utc_seconds(Date.now() - t.setDate(t.getDate() - 1));
	        },
	        get_last_week_seconds: function() {
	            let t = new Date();
	            return this.get_utc_seconds(Date.now() - t.setDate(t.getDate() - 7));
	        },
	        get_last_month_seconds: function() {
	            let t = new Date();
	            return this.get_utc_seconds(Date.now() - t.setMonth(t.getMonth() - 1));
	        },
	        get_last_year_seconds: function() {
	            let t = new Date();
	            return this.get_utc_seconds(Date.now() - t.setMonth(t.getMonth() - 12));
	        },
	        zoom: function(scale) {
	            if (this.epoch_status == null) { return; }
	            let interval = (this.epoch_status.epoch_end - this.epoch_status.epoch_begin) / scale;
	            let center = (this.epoch_status.epoch_end / 2 + this.epoch_status.epoch_begin / 2);
	            this.epoch_status.epoch_begin = center - interval / 2;
	            this.epoch_status.epoch_end = center + interval / 2;
	            let now = this.get_utc_seconds(Date.now());
	            if (this.epoch_status.epoch_end > now) {
	                this.epoch_status.epoch_end = now;
	            }
	            this.epoch_status.epoch_end = Number.parseInt(this.epoch_status.epoch_end);
	            this.epoch_status.epoch_begin = Number.parseInt(this.epoch_status.epoch_begin);
	            if (this.epoch_status.epoch_begin == this.epoch_status.epoch_end) {
	                this.epoch_status.epoch_begin -= 2;
	            }
	            this.emit_epoch_change(this.epoch_status);
	        },
	        jump_time_back: function() {
	            if (this.epoch_status == null) { return; }
	            const min = 60;
	            this.epoch_status.epoch_begin -= (30 * min);
	            this.epoch_status.epoch_end -= (30 * min);
	            this.emit_epoch_change(this.epoch_status);
	        },
	        jump_time_ahead: function() {
	            if (this.epoch_status == null) { return; }
	            const min = 60;
	            let previous_end = this.epoch_status.epoch_end;
	            let now = this.get_utc_seconds(Date.now());
	            
	            this.epoch_status.epoch_end += (30 * min);
	            if (this.epoch_status.epoch_end > now) {
	                this.epoch_status.epoch_end = now;
	            }
	            this.epoch_status.epoch_begin += (this.epoch_status.epoch_end - previous_end);
	            this.emit_epoch_change(this.epoch_status);
	        },
	        emit_epoch_change: function(epoch_status, id) {
	            if (epoch_status.epoch_end == null || epoch_status.epoch_begin == null) { return; }            this.wrong_date = false;
	            if (epoch_status.epoch_begin > epoch_status.epoch_end) {
	                this.wrong_date = true;
			return;
	            }
		    if (id != this.id) {
			this.on_status_updated(epoch_status);
		    }
	            ntopng_events_manager.emit_event(ntopng_events.EPOCH_CHANGE, epoch_status, this.id);
	            this.$emit("epoch_change", epoch_status);
	        },
		add_status_in_history: function(epoch_status) {
		    this.history_last_status = this.history[this.history.length - 1];
		    if (this.history.length > 5) {
			this.history.shift();
		    }
		    this.history.push(epoch_status);
		},
		
		apply_status_by_history: function() {
		    if (this.history_last_status == null) { return; }
		    this.history.pop();
		    this.history.pop();
		    this.emit_epoch_change(this.history_last_status);
		},
	    },
	    /**
	       Private date of vue component.
	    */
	  data() {
	      return {
	    i18n: (t) => i18n(t),
	      //status_id: "data-time-range-picker" + this.$props.id,
		  epoch_status: null,
		  refresh_interval: null,
		  refresh_interval_seconds: 60 * 1000,
		  update_from_interval: false,
		  history: [],
		  history_last_status: null,
	      enable_apply: false,
		  select_time_value: "min_5",
		  selected_time_option: { value: "min_5", label: i18n('show_alerts.presets.5_min'), currently_active: false },
	      wrong_date: false,
	      flat_begin_date: null,
	      flat_end_date: null,
	      time_preset_list: [
	        { value: "min_5", label: i18n('show_alerts.presets.5_min'), currently_active: false },
	        { value: "min_30", label: i18n('show_alerts.presets.30_min'), currently_active: true },
	        { value: "hour", label: i18n('show_alerts.presets.hour'), currently_active: false },
	        { value: "day", label: i18n('show_alerts.presets.day'), currently_active: false },
	        { value: "week", label: i18n('show_alerts.presets.week'), currently_active: false },
	        { value: "month", label: i18n('show_alerts.presets.month'), currently_active: false },
	        { value: "year", label: i18n('show_alerts.presets.year'), currently_active: false },
	        { value: "custom", label: i18n('show_alerts.presets.custom'), currently_active: false, disabled: true, },
	      ]
	    };
	  },
	};

	const _withScopeId$8 = n => (pushScopeId("data-v-bc6f1430"),n=n(),popScopeId(),n);
	const _hoisted_1$w = { class: "input-group" };
	const _hoisted_2$u = { class: "form-group" };
	const _hoisted_3$s = { class: "controls d-flex flex-wrap" };
	const _hoisted_4$r = { class: "btn-group me-auto btn-group-sm" };
	const _hoisted_5$q = { class: "btn-group ms-2" };
	const _hoisted_6$q = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("span", { class: "input-group-text" }, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-calendar-alt" })
	], -1 /* HOISTED */));
	const _hoisted_7$p = {
	  class: "flatpickr flatpickr-input",
	  type: "text",
	  placeholder: "Choose a date..",
	  "data-id": "datetime",
	  ref: "begin-date"
	};
	const _hoisted_8$o = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("span", { class: "input-group-text" }, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-long-arrow-alt-right" })
	], -1 /* HOISTED */));
	const _hoisted_9$m = {
	  class: "flatpickr flatpickr-input",
	  type: "text",
	  placeholder: "Choose a date..",
	  "data-id": "datetime",
	  ref: "end-date"
	};
	const _hoisted_10$i = ["title"];
	const _hoisted_11$i = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-exclamation-circle" }, null, -1 /* HOISTED */));
	const _hoisted_12$h = [
	  _hoisted_11$i
	];
	const _hoisted_13$g = { class: "d-flex align-items-center ms-2" };
	const _hoisted_14$d = ["disabled"];
	const _hoisted_15$c = { class: "btn-group" };
	const _hoisted_16$b = ["title"];
	const _hoisted_17$b = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-long-arrow-alt-left" }, null, -1 /* HOISTED */));
	const _hoisted_18$a = [
	  _hoisted_17$b
	];
	const _hoisted_19$a = ["title"];
	const _hoisted_20$8 = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-long-arrow-alt-right" }, null, -1 /* HOISTED */));
	const _hoisted_21$4 = [
	  _hoisted_20$8
	];
	const _hoisted_22$4 = ["title"];
	const _hoisted_23$4 = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-search-plus" }, null, -1 /* HOISTED */));
	const _hoisted_24$4 = [
	  _hoisted_23$4
	];
	const _hoisted_25$3 = ["title"];
	const _hoisted_26$3 = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-search-minus" }, null, -1 /* HOISTED */));
	const _hoisted_27$3 = [
	  _hoisted_26$3
	];
	const _hoisted_28$2 = ["disabled", "title"];
	const _hoisted_29$2 = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-undo" }, null, -1 /* HOISTED */));
	const _hoisted_30$2 = [
	  _hoisted_29$2
	];
	const _hoisted_31$2 = ["disabled", "title"];
	const _hoisted_32$2 = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" }, null, -1 /* HOISTED */));
	const _hoisted_33$2 = [
	  _hoisted_32$2
	];

	function render$j(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_select_search = resolveComponent("select-search");

	  return (openBlock(), createElementBlock("div", _hoisted_1$w, [
	    createBaseVNode("div", _hoisted_2$u, [
	      createBaseVNode("div", _hoisted_3$s, [
	        createBaseVNode("div", _hoisted_4$r, [
	          renderSlot(_ctx.$slots, "begin"),
	          createVNode(_component_select_search, {
	            selected_option: $data.selected_time_option,
	            "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => (($data.selected_time_option) = $event)),
	            id: 'time_preset_range_picker',
	            options: $data.time_preset_list,
	            onSelect_option: $options.change_select_time
	          }, null, 8 /* PROPS */, ["selected_option", "options", "onSelect_option"]),
	          createBaseVNode("div", _hoisted_5$q, [
	            _hoisted_6$q,
	            createBaseVNode("input", _hoisted_7$p, null, 512 /* NEED_PATCH */),
	            createCommentVNode(" <input ref=\"begin-date\" @change=\"enable_apply=true\" @change=\"change_begin_date\" type=\"date\" class=\"date_time_input begin-timepicker form-control border-right-0 fix-safari-input\"> "),
	            createCommentVNode(" <input ref=\"begin-time\" @change=\"enable_apply=true\" type=\"time\" class=\"date_time_input begin-timepicker form-control border-right-0 fix-safari-input\"> "),
	            _hoisted_8$o,
	            createBaseVNode("input", _hoisted_9$m, null, 512 /* NEED_PATCH */),
	            createCommentVNode(" <input ref=\"end-date\" @change=\"enable_apply=true\" type=\"date\" class=\"date_time_input end-timepicker form-control border-left-0 fix-safari-input\" style=\"width: 2.5rem;\"> "),
	            createCommentVNode(" <input ref=\"end-time\" @change=\"enable_apply=true\" type=\"time\" class=\"date_time_input end-timepicker form-control border-left-0 fix-safari-input\"> "),
	            withDirectives(createBaseVNode("span", {
	              title: $data.i18n('wrong_date_range'),
	              style: {"margin-left":"0.2rem","color":"red"}
	            }, _hoisted_12$h, 8 /* PROPS */, _hoisted_10$i), [
	              [vShow, $data.wrong_date]
	            ])
	          ]),
	          createBaseVNode("div", _hoisted_13$g, [
	            createBaseVNode("button", {
	              disabled: !$data.enable_apply || $data.wrong_date,
	              onClick: _cache[1] || (_cache[1] = (...args) => ($options.apply && $options.apply(...args))),
	              class: "btn btn-sm btn-primary"
	            }, toDisplayString($data.i18n('apply')), 9 /* TEXT, PROPS */, _hoisted_14$d),
	            createBaseVNode("div", _hoisted_15$c, [
	              createBaseVNode("button", {
	                onClick: _cache[2] || (_cache[2] = $event => ($options.jump_time_back())),
	                class: "btn btn-sm btn-link",
	                ref: "btn-jump-time-back",
	                title: $data.i18n('date_time_range_picker.btn_move_left')
	              }, _hoisted_18$a, 8 /* PROPS */, _hoisted_16$b),
	              createBaseVNode("button", {
	                onClick: _cache[3] || (_cache[3] = $event => ($options.jump_time_ahead())),
	                class: "btn btn-sm btn-link me-2",
	                ref: "btn-jump-time-ahead",
	                title: $data.i18n('date_time_range_picker.btn_move_right')
	              }, _hoisted_21$4, 8 /* PROPS */, _hoisted_19$a),
	              createBaseVNode("button", {
	                onClick: _cache[4] || (_cache[4] = $event => ($options.zoom(2))),
	                class: "btn btn-sm btn-link",
	                ref: "btn-zoom-in",
	                title: $data.i18n('date_time_range_picker.btn_zoom_in')
	              }, _hoisted_24$4, 8 /* PROPS */, _hoisted_22$4),
	              createBaseVNode("button", {
	                onClick: _cache[5] || (_cache[5] = $event => ($options.zoom(0.5))),
	                class: "btn btn-sm btn-link",
	                ref: "btn-zoom-out",
	                title: $data.i18n('date_time_range_picker.btn_zoom_out')
	              }, _hoisted_27$3, 8 /* PROPS */, _hoisted_25$3),
	              createBaseVNode("button", {
	                disabled: $data.history_last_status == null,
	                onClick: _cache[6] || (_cache[6] = $event => ($options.apply_status_by_history())),
	                class: "btn btn-sm btn-link",
	                title: $data.i18n('date_time_range_picker.btn_undo')
	              }, _hoisted_30$2, 8 /* PROPS */, _hoisted_28$2),
	              createBaseVNode("button", {
	                disabled: $data.select_time_value == 'custom',
	                onClick: _cache[7] || (_cache[7] = $event => ($options.change_select_time())),
	                class: "btn btn-sm btn-link",
	                title: $data.i18n('date_time_range_picker.btn_refresh')
	              }, _hoisted_33$2, 8 /* PROPS */, _hoisted_31$2),
	              renderSlot(_ctx.$slots, "extra_buttons")
	            ])
	          ])
	        ])
	      ])
	    ])
	  ]))
	}

	function styleInject(css, ref) {
	  if ( ref === void 0 ) ref = {};
	  var insertAt = ref.insertAt;

	  if (!css || typeof document === 'undefined') { return; }

	  var head = document.head || document.getElementsByTagName('head')[0];
	  var style = document.createElement('style');
	  style.type = 'text/css';

	  if (insertAt === 'top') {
	    if (head.firstChild) {
	      head.insertBefore(style, head.firstChild);
	    } else {
	      head.appendChild(style);
	    }
	  } else {
	    head.appendChild(style);
	  }

	  if (style.styleSheet) {
	    style.styleSheet.cssText = css;
	  } else {
	    style.appendChild(document.createTextNode(css));
	  }
	}

	var css_248z$a = "\n.date_time_input[data-v-bc6f1430] {\n  width: 10.5rem;\n  max-width: 10.5rem;\n  min-width: 10.5rem;\n}\n";
	styleInject(css_248z$a);

	script$z.render = render$j;
	script$z.__scopeId = "data-v-bc6f1430";
	script$z.__file = "http_src/vue/data-time-range-picker.vue";

	var script$y = defineComponent({
	    components: {
	    },
	    props: {
		id: String,
	    },
	    emits: ["hidden", "showed"],
	    /** This method is the first method of the component called, it's called before html template creation. */
	    created() {
	    },
	    data() {
		return {
		    //i18n: (t) => i18n(t),
		};
	    },
	    /** This method is the first method called after html template creation. */
	    mounted() {
		let me = this;
		$(this.$refs["modal_id"]).on('shown.bs.modal', function (e) {
		    me.$emit("showed");
		});
		$(this.$refs["modal_id"]).on('hidden.bs.modal', function (e) {
		    me.$emit("hidden");
		});
		// notifies that component is ready
		ntopng_sync.ready(this.$props["id"]);
	    },
	    methods: {
		show: function() {
		    $(this.$refs["modal_id"]).modal("show");
		},
		preventEnter: function() {},
		close: function() {
		    $(this.$refs["modal_id"]).modal("hide");
		},
	    },
	});

	const _hoisted_1$v = {
	  class: "modal-dialog modal-dialog-centered modal-lg",
	  role: "document"
	};
	const _hoisted_2$t = { class: "modal-content" };
	const _hoisted_3$r = { class: "modal-header" };
	const _hoisted_4$q = { class: "modal-title" };
	const _hoisted_5$p = /*#__PURE__*/createBaseVNode("div", { class: "modal-close" }, [
	  /*#__PURE__*/createBaseVNode("button", {
	    type: "button",
	    class: "btn-close",
	    "data-bs-dismiss": "modal",
	    "aria-label": "Close"
	  })
	], -1 /* HOISTED */);
	const _hoisted_6$p = { class: "modal-body" };
	const _hoisted_7$o = { class: "modal-footer" };
	const _hoisted_8$n = /*#__PURE__*/createBaseVNode("div", { class: "mr-auto" }, null, -1 /* HOISTED */);
	const _hoisted_9$l = /*#__PURE__*/createBaseVNode("div", {
	  class: "alert alert-info test-feedback w-100",
	  style: {"display":"none"}
	}, null, -1 /* HOISTED */);

	function render$i(_ctx, _cache, $props, $setup, $data, $options) {
	  return (openBlock(), createElementBlock("div", {
	    onSubmit: _cache[0] || (_cache[0] = withModifiers((...args) => (_ctx.preventEnter && _ctx.preventEnter(...args)), ["prevent"])),
	    class: "modal fade",
	    ref: "modal_id",
	    tabindex: "-1",
	    role: "dialog",
	    "aria-labelledby": "dt-add-filter-modal-title",
	    "aria-hidden": "true"
	  }, [
	    createBaseVNode("div", _hoisted_1$v, [
	      createBaseVNode("div", _hoisted_2$t, [
	        createBaseVNode("div", _hoisted_3$r, [
	          createBaseVNode("h5", _hoisted_4$q, [
	            renderSlot(_ctx.$slots, "title")
	          ]),
	          _hoisted_5$p
	        ]),
	        createBaseVNode("div", _hoisted_6$p, [
	          renderSlot(_ctx.$slots, "body")
	        ]),
	        createBaseVNode("div", _hoisted_7$o, [
	          _hoisted_8$n,
	          renderSlot(_ctx.$slots, "footer"),
	          _hoisted_9$l
	        ])
	      ])
	    ])
	  ], 544 /* HYDRATE_EVENTS, NEED_PATCH */))
	}

	script$y.render = render$i;
	script$y.__file = "http_src/vue/modal.vue";

	const _withScopeId$7 = n => (pushScopeId("data-v-089b0491"),n=n(),popScopeId(),n);
	const _hoisted_1$u = /*#__PURE__*/ _withScopeId$7(() => /*#__PURE__*/createBaseVNode("a", {
	  target: "_newtab",
	  href: "#",
	  style: {},
	  class: "nav-item text-muted"
	}, [
	  /*#__PURE__*/createBaseVNode("i", {
	    class: "fas fa-question-circle",
	    style: {"margin-left":"28rem","padding-top":"0.8rem"}
	  })
	], -1 /* HOISTED */));
	const _hoisted_2$s = { class: "nav nav-tabs" };
	const _hoisted_3$q = ["disabled"];
	const _hoisted_4$p = {
	  key: 0,
	  style: {"min-height":"8.5rem"}
	};
	const _hoisted_5$o = { class: "form-group ms-2 me-2 mt-3 row" };
	const _hoisted_6$o = { class: "col-form-label col-sm-4" };
	const _hoisted_7$n = { class: "col-sm-6" };
	const _hoisted_8$m = ["pattern"];
	const _hoisted_9$k = {
	  key: 1,
	  style: {"min-height":"8.5rem"}
	};
	const _hoisted_10$h = { class: "form-group ms-2 me-2 mt-3 row" };
	const _hoisted_11$h = { class: "col-form-label col-sm-4" };
	const _hoisted_12$g = { class: "col-sm-8" };
	const _hoisted_13$f = { value: "name" };
	const _hoisted_14$c = { value: "date" };
	const _hoisted_15$b = { class: "form-group ms-2 me-2 mt-3 row" };
	const _hoisted_16$a = { class: "col-form-label col-sm-4" };
	const _hoisted_17$a = { class: "col-sm-8" };
	const _hoisted_18$9 = ["value"];
	const _hoisted_19$9 = { class: "form-group ms-2 me-2 mt-3 row" };
	const _hoisted_20$7 = { class: "custom-control custom-switch" };
	const _hoisted_21$3 = { class: "custom-control-label ms-1 form-check-label" };
	const _hoisted_22$3 = ["disabled"];
	const _hoisted_23$3 = ["disabled"];
	const _hoisted_24$3 = ["disabled"];


	var script$x = {
	  __name: 'modal-snapshot',
	  props: {
	    csrf: String,
	    page: String,
	},
	  emits: ['added_snapshot', 'deleted_snapshot', 'deleted_all_snapshots'],
	  setup(__props, { expose, emit }) {

	const props = __props;

	const modal_id = ref(null);
	const action = ref("add"); // add / select
	const showed = () => {};
	const snapshot_selected = ref("");
	const apply_time = ref(false);
	const apply_time_text = ref("");
	const save_time = ref(true);
	const save_time_text = ref("");
	const snapshot_name = ref("");
	const snapshots = ref([]);
	const order_by = ref("date"); // name / date





	let pattern_singleword = NtopUtils.REGEXES.singleword;

	const disable_add = computed$1(() => {
	    let rg = new RegExp(pattern_singleword);
	    return !rg.test(snapshot_name.value);
	});

	const disable_select = computed$1(() => {
	    return snapshot_selected.value == "";
	});

	const show = () => {
	    init();
	    modal_id.value.show();
	};

	const update_action = (a) => {
	    if (snapshots.value.length == 0 && a == "select") { return; }
	    action.value = a;
	};

	function get_page() {
	    if (props.page != null) {
		return props.page;
	    }
	    let is_alert_stats_url = window.location.toString().match(/alert_stats.lua/) != null;
	    let page = "alerts";
	    if (!is_alert_stats_url) {
		page = "flows";
	    }
	    return page;
	}

	function display_name(snapshot) {
	    let utc_ms = snapshot.utc * 1000;
	    let date = ntopng_utility.from_utc_to_server_date_format(utc_ms, "DD/MM/YYYY");
	    return `${snapshot.name} (${date})`
	}

	let last_order_by = null;
	function sort_snapshots_by() {
	    if (last_order_by == order_by.value) { return; }
	    
	    snapshots.value.sort((a, b) => {
		if (order_by.value == "name") {
		    return a.name.localeCompare(b.name);
		}
		return a.utc - b.utc;
	    });
	    if (snapshots.value.length > 0) {
		snapshot_selected.value = snapshots.value[0];
	    }
	    last_order_by = order_by.value;    
	}

	let load_snapshots = true;
	async function init() {
	    action.value = "add";
	    snapshot_name.value = "";
	    save_time.value = true;
	    apply_time.value = false;
	    let status = ntopng_status_manager.get_status();
	    let save_time_filter_text = _i18n("snapshots.save_time");
	    let begin_time = ntopng_utility.from_utc_to_server_date_format(status.epoch_begin * 1000, "DD/MM/YYYY HH:mm");
	    let end_time = ntopng_utility.from_utc_to_server_date_format(status.epoch_end * 1000, "DD/MM/YYYY HH:mm");
	    save_time_filter_text = save_time_filter_text.replace(/\%begin_time/, begin_time);
	    save_time_filter_text = save_time_filter_text.replace(/\%end_time/, end_time);
	    save_time_text.value = save_time_filter_text;
	    let apply_time_filter_text = _i18n("snapshots.apply_time");
	    apply_time_filter_text = apply_time_filter_text.replace(/\%begin_time/, begin_time);
	    apply_time_filter_text = apply_time_filter_text.replace(/\%end_time/, end_time);
	    apply_time_text.value = apply_time_filter_text;
	    if (load_snapshots) {
		load_snapshots = false;
		let page = get_page();
		let url = `${http_prefix}/lua/pro/rest/v2/get/filters/snapshots.lua?page=${page}`;
		let snapshots_obj = await ntopng_utility.http_request(url);
		snapshots.value = ntopng_utility.object_to_array(snapshots_obj);
	    }
	    sort_snapshots_by();
	    if (snapshots.value.length > 0) {
		snapshot_selected.value = snapshots.value[0];
	    }
	}

	const add_snapshot = async () => {
	    let filters;
	    if (save_time.value) {
		filters = ntopng_url_manager.get_url_params();
	    } else {
		let params_obj = ntopng_url_manager.get_url_object();
		delete params_obj.epoch_begin;
		delete params_obj.epoch_end;
		filters = ntopng_url_manager.obj_to_url_params(params_obj);
	    }
	    let page = get_page();
	    let params = {
		snapshot_name: snapshot_name.value,
		filters,
		page
	    };
	    
	    params.csrf = props.csrf;
	    let url = `${http_prefix}/lua/pro/rest/v2/add/filters/snapshot.lua`;
	    try {
		let headers = {
		    'Content-Type': 'application/json'
		};
		await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
		load_snapshots = true;
	    } catch(err) {
		console.error(err);
	    }
	    close();
	    emit('added_snapshots', params);
	};

	const select_snapshot = () => {
	    close();    
	    let filters = snapshot_selected.value.filters;
	    if (apply_time.value == true) {
	    	let status = ntopng_status_manager.get_status();
	    	let params_obj = ntopng_url_manager.get_url_object(filters);
	    	params_obj.epoch_begin = status.epoch_begin;
	    	params_obj.epoch_end = status.epoch_end;
	    	filters = ntopng_url_manager.obj_to_url_params(params_obj);
	    }
	    ntopng_url_manager.replace_url_and_reload(filters);
	};

	const delete_snapshot = async (delete_all) => {
	    let name = snapshot_selected.value.name;
	    if (delete_all == true) { name = "*"; }
	    let page = get_page();
	    let params = {
	    	snapshot_name: name,
		page,
	    };
	    params.csrf = props.csrf;
	    let url = `${http_prefix}/lua/pro/rest/v2/delete/filters/snapshot.lua`;
	    try {
	    	let headers = {
	    	    'Content-Type': 'application/json'
	    	};
	    	await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	    	load_snapshots = true;
	    } catch(err) {
	    	console.error(err);
	    }
	    if (delete_all == true) {
		emit('deleted_all_snapshots', params);
	    } else {
		emit('deleted_snapshot', params);
	    }
	    close();
	};

	const close = () => {
	    modal_id.value.close();
	};


	expose({ show, close });

	onMounted(() => {
	});

	const _i18n = (t) => i18n(t);


	return (_ctx, _cache) => {
	  return (openBlock(), createBlock(script$y, {
	    onShowed: _cache[8] || (_cache[8] = $event => (showed())),
	    ref_key: "modal_id",
	    ref: modal_id
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(_i18n("snapshots.manage")) + " ", 1 /* TEXT */),
	      _hoisted_1$u
	    ]),
	    body: withCtx(() => [
	      createBaseVNode("ul", _hoisted_2$s, [
	        createBaseVNode("li", {
	          class: "nav-item",
	          onClick: _cache[0] || (_cache[0] = $event => (action.value='add'))
	        }, [
	          createBaseVNode("a", {
	            class: normalizeClass(["nav-link", {'active': action.value == 'add'}]),
	            href: "#"
	          }, toDisplayString(_i18n("snapshots.add")), 3 /* TEXT, CLASS */)
	        ]),
	        createBaseVNode("li", {
	          class: "nav-item",
	          onClick: _cache[1] || (_cache[1] = $event => (update_action('select')))
	        }, [
	          createBaseVNode("a", {
	            disabled: snapshots.value.length == 0,
	            class: normalizeClass(["nav-link", {'active': action.value == 'select', 'not-allowed': snapshots.value.length == 0 }]),
	            href: "#"
	          }, toDisplayString(_i18n("snapshots.manage")), 11 /* TEXT, CLASS, PROPS */, _hoisted_3$q)
	        ])
	      ]),
	      (action.value == 'add')
	        ? (openBlock(), createElementBlock("div", _hoisted_4$p, [
	            createBaseVNode("div", _hoisted_5$o, [
	              createBaseVNode("label", _hoisted_6$o, [
	                createBaseVNode("b", null, toDisplayString(_i18n("snapshots.name")) + ":", 1 /* TEXT */)
	              ]),
	              createBaseVNode("div", _hoisted_7$n, [
	                withDirectives(createBaseVNode("input", {
	                  pattern: unref(pattern_singleword),
	                  placeholder: "",
	                  required: "",
	                  type: "text",
	                  class: "form-control",
	                  "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((snapshot_name).value = $event))
	                }, null, 8 /* PROPS */, _hoisted_8$m), [
	                  [vModelText, snapshot_name.value]
	                ])
	              ])
	            ]),
	            createCommentVNode(" <div class=\"form-group ms-2 me-2 mt-3 row\"> "),
	            createCommentVNode(" \t<div class=\"custom-control custom-switch\"> "),
	            createCommentVNode(" \t  <input type=\"checkbox\" class=\"custom-control-input whitespace form-check-input\" v-model=\"save_time\"> "),
	            createCommentVNode(" \t  <label class=\"custom-control-label ms-1 form-check-label\">{{save_time_text}}</label> "),
	            createCommentVNode(" \t</div> "),
	            createCommentVNode(" </div>       ")
	          ]))
	        : createCommentVNode("v-if", true),
	      createCommentVNode(" action add "),
	      (action.value == 'select')
	        ? (openBlock(), createElementBlock("div", _hoisted_9$k, [
	            createBaseVNode("div", _hoisted_10$h, [
	              createBaseVNode("label", _hoisted_11$h, [
	                createBaseVNode("b", null, toDisplayString(_i18n("snapshots.order_by")), 1 /* TEXT */)
	              ]),
	              createBaseVNode("div", _hoisted_12$g, [
	                withDirectives(createBaseVNode("select", {
	                  class: "form-select",
	                  onClick: _cache[3] || (_cache[3] = $event => (sort_snapshots_by())),
	                  "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((order_by).value = $event))
	                }, [
	                  createBaseVNode("option", _hoisted_13$f, toDisplayString(_i18n("snapshots.name")), 1 /* TEXT */),
	                  createBaseVNode("option", _hoisted_14$c, toDisplayString(_i18n("snapshots.date")), 1 /* TEXT */)
	                ], 512 /* NEED_PATCH */), [
	                  [vModelSelect, order_by.value]
	                ])
	              ])
	            ]),
	            createBaseVNode("div", _hoisted_15$b, [
	              createBaseVNode("label", _hoisted_16$a, [
	                createBaseVNode("b", null, toDisplayString(_i18n("snapshots.select")), 1 /* TEXT */)
	              ]),
	              createBaseVNode("div", _hoisted_17$a, [
	                withDirectives(createBaseVNode("select", {
	                  class: "form-select",
	                  "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => ((snapshot_selected).value = $event))
	                }, [
	                  (openBlock(true), createElementBlock(Fragment, null, renderList(snapshots.value, (item) => {
	                    return (openBlock(), createElementBlock("option", { value: item }, toDisplayString(display_name(item)), 9 /* TEXT, PROPS */, _hoisted_18$9))
	                  }), 256 /* UNKEYED_FRAGMENT */))
	                ], 512 /* NEED_PATCH */), [
	                  [vModelSelect, snapshot_selected.value]
	                ])
	              ])
	            ]),
	            createBaseVNode("div", _hoisted_19$9, [
	              createBaseVNode("div", _hoisted_20$7, [
	                withDirectives(createBaseVNode("input", {
	                  type: "checkbox",
	                  class: "custom-control-input whitespace form-check-input",
	                  "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((apply_time).value = $event))
	                }, null, 512 /* NEED_PATCH */), [
	                  [vModelCheckbox, apply_time.value]
	                ]),
	                createBaseVNode("label", _hoisted_21$3, toDisplayString(apply_time_text.value), 1 /* TEXT */)
	              ])
	            ])
	          ]))
	        : createCommentVNode("v-if", true),
	      createCommentVNode(" action select ")
	    ]),
	    footer: withCtx(() => [
	      (action.value == 'add')
	        ? (openBlock(), createElementBlock("button", {
	            key: 0,
	            type: "button",
	            onClick: add_snapshot,
	            disabled: unref(disable_add),
	            class: "btn btn-primary"
	          }, toDisplayString(_i18n("snapshots.add")), 9 /* TEXT, PROPS */, _hoisted_22$3))
	        : createCommentVNode("v-if", true),
	      (action.value == 'select')
	        ? (openBlock(), createElementBlock("button", {
	            key: 1,
	            onClick: _cache[7] || (_cache[7] = $event => (delete_snapshot(true))),
	            type: "button",
	            style: {"text-align":"left","margin-left":"0px"},
	            class: "btn btn-danger start-0 position-absolute ms-3"
	          }, toDisplayString(_i18n("snapshots.delete_all")), 1 /* TEXT */))
	        : createCommentVNode("v-if", true),
	      (action.value == 'select')
	        ? (openBlock(), createElementBlock("button", {
	            key: 2,
	            type: "button",
	            onClick: delete_snapshot,
	            disabled: unref(disable_select),
	            class: "btn btn-danger"
	          }, toDisplayString(_i18n("snapshots.delete")), 9 /* TEXT, PROPS */, _hoisted_23$3))
	        : createCommentVNode("v-if", true),
	      (action.value == 'select')
	        ? (openBlock(), createElementBlock("button", {
	            key: 3,
	            type: "button",
	            onClick: select_snapshot,
	            disabled: unref(disable_select),
	            class: "btn btn-primary"
	          }, toDisplayString(_i18n("snapshots.apply")), 9 /* TEXT, PROPS */, _hoisted_24$3))
	        : createCommentVNode("v-if", true)
	    ]),
	    _: 1 /* STABLE */
	  }, 512 /* NEED_PATCH */))
	}
	}

	};

	var css_248z$9 = "\ninput[data-v-089b0491]:invalid {\n  border-color: #ff0000;\n}\n.not-allowed[data-v-089b0491] {\n  cursor: not-allowed;\n}\n";
	styleInject(css_248z$9);

	script$x.__scopeId = "data-v-089b0491";
	script$x.__file = "http_src/vue/modal-snapshot.vue";

	const _withScopeId$6 = n => (pushScopeId("data-v-185590b6"),n=n(),popScopeId(),n);
	const _hoisted_1$t = { class: "form-group ms-2 me-2 mt-3 row" };
	const _hoisted_2$r = { class: "col-11" };
	const _hoisted_3$p = { class: "col-form-label" };
	const _hoisted_4$o = /*#__PURE__*/ _withScopeId$6(() => /*#__PURE__*/createBaseVNode("button", {
	  type: "button",
	  class: "btn border"
	}, [
	  /*#__PURE__*/createBaseVNode("span", null, [
	    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" })
	  ])
	], -1 /* HOISTED */));
	const _hoisted_5$n = [
	  _hoisted_4$o
	];
	const _hoisted_6$n = { class: "container" };
	const _hoisted_7$m = { class: "row custom-ms me-2 mt-1" };
	const _hoisted_8$l = { class: "col-5" };
	const _hoisted_9$j = ["onUpdate:modelValue"];
	const _hoisted_10$g = { class: "custom-control-label ms-1 form-check-label" };
	const _hoisted_11$g = { class: "col-2" };
	const _hoisted_12$f = ["onUpdate:modelValue"];
	const _hoisted_13$e = /*#__PURE__*/ _withScopeId$6(() => /*#__PURE__*/createBaseVNode("label", { class: "custom-control-label ms-1 form-check-label" }, "Past ", -1 /* HOISTED */));
	const _hoisted_14$b = { class: "col-2" };
	const _hoisted_15$a = ["onUpdate:modelValue"];
	const _hoisted_16$9 = /*#__PURE__*/ _withScopeId$6(() => /*#__PURE__*/createBaseVNode("label", { class: "custom-control-label ms-1 form-check-label" }, "Avg ", -1 /* HOISTED */));
	const _hoisted_17$9 = { class: "col-3" };
	const _hoisted_18$8 = ["onUpdate:modelValue"];
	const _hoisted_19$8 = /*#__PURE__*/ _withScopeId$6(() => /*#__PURE__*/createBaseVNode("label", { class: "custom-control-label ms-1 form-check-label" }, "95th Perc ", -1 /* HOISTED */));


	var script$w = {
	  __name: 'list-timeseries',
	  props: {
	    id: String,
	    timeseries: Array,
	    title: String,
	    show_delete_button: Boolean,
	},
	  emits: ['delete_ts', 'update:timeseries'],
	  setup(__props, { emit }) {

	const props = __props;





	function update_timeseries() {
	    console.log(props.timeseries);
	    emit('update:timeseries', props.timeseries);
	}

	function delete_ts() {
	    emit('delete_ts', props.id);
	}

	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock("div", null, [
	    createBaseVNode("div", _hoisted_1$t, [
	      createBaseVNode("div", _hoisted_2$r, [
	        createBaseVNode("label", _hoisted_3$p, [
	          createBaseVNode("b", null, toDisplayString(__props.title), 1 /* TEXT */)
	        ])
	      ]),
	      (__props.show_delete_button)
	        ? (openBlock(), createElementBlock("div", {
	            key: 0,
	            class: "col-1",
	            onClick: delete_ts
	          }, _hoisted_5$n))
	        : createCommentVNode("v-if", true)
	    ]),
	    createBaseVNode("div", _hoisted_6$n, [
	      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.timeseries, (item) => {
	        return (openBlock(), createElementBlock("div", _hoisted_7$m, [
	          createBaseVNode("div", _hoisted_8$l, [
	            withDirectives(createBaseVNode("input", {
	              type: "checkbox",
	              class: "custom-control-input whitespace form-check-input",
	              onChange: update_timeseries,
	              "onUpdate:modelValue": $event => ((item.raw) = $event)
	            }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_9$j), [
	              [vModelCheckbox, item.raw]
	            ]),
	            createBaseVNode("label", _hoisted_10$g, toDisplayString(item.label), 1 /* TEXT */)
	          ]),
	          createBaseVNode("div", _hoisted_11$g, [
	            withDirectives(createBaseVNode("input", {
	              type: "checkbox",
	              class: "custom-control-input whitespace form-check-input",
	              onChange: update_timeseries,
	              "onUpdate:modelValue": $event => ((item.past) = $event)
	            }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_12$f), [
	              [vModelCheckbox, item.past]
	            ]),
	            _hoisted_13$e
	          ]),
	          createBaseVNode("div", _hoisted_14$b, [
	            withDirectives(createBaseVNode("input", {
	              type: "checkbox",
	              class: "custom-control-input whitespace form-check-input",
	              onChange: update_timeseries,
	              "onUpdate:modelValue": $event => ((item.avg) = $event)
	            }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_15$a), [
	              [vModelCheckbox, item.avg]
	            ]),
	            _hoisted_16$9
	          ]),
	          createBaseVNode("div", _hoisted_17$9, [
	            withDirectives(createBaseVNode("input", {
	              type: "checkbox",
	              class: "custom-control-input whitespace form-check-input",
	              onChange: update_timeseries,
	              "onUpdate:modelValue": $event => ((item.perc_95) = $event)
	            }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_18$8), [
	              [vModelCheckbox, item.perc_95]
	            ]),
	            _hoisted_19$8
	          ])
	        ]))
	      }), 256 /* UNKEYED_FRAGMENT */))
	    ])
	  ]))
	}
	}

	};

	var css_248z$8 = "\n.custom-ms[data-v-185590b6] {\n  margin-left: 2rem !important;\n}\n.inline-block[data-v-185590b6] {\n    display: inline-block;\n    margin-right: 1rem;\n}\n.border[data-v-185590b6] {\n    border-style: solid !important;\n}\n";
	styleInject(css_248z$8);

	script$w.__scopeId = "data-v-185590b6";
	script$w.__file = "http_src/vue/list-timeseries.vue";

	/**
	    (C) 2022 - ntop.org
	*/

	const set_timeseries_groups_in_url = (timeseries_groups) => {
	    let params_timeseries_groups = [];
	    timeseries_groups.forEach((ts_group) => {
		let param = get_ts_group_url_param(ts_group);
		params_timeseries_groups.push(param);
	    });
	    let url_timeseries_groups = params_timeseries_groups.join(";");
	    ntopng_url_manager$1.set_key_to_url("timeseries_groups", url_timeseries_groups);
	};

	function get_ts_group_url_param(ts_group) {
	    let timeseries = [];
	    ts_group.timeseries.forEach((ts) => {
		timeseries.push(`${ts.id}=${ts.raw}:${ts.past}:${ts.avg}:${ts.perc_95}`);
	    });
	    let metric_schema_query = ts_group.metric.schema;
	    if (ts_group.metric.query != null) {
		metric_schema_query = `${metric_schema_query}+${ts_group.metric.query}`;
	    }
	    let timeseries_param = timeseries.join("|");
	    let source_value_query = ts_group.source.value;
	    if (ts_group.source.sub_value != null) {
		source_value_query = `${source_value_query}+${ts_group.source.sub_value}`;
	    }
	    let param = `${ts_group.source_type.id},${source_value_query},${metric_schema_query},${timeseries_param}`;
	    return param;
	}

	const get_timeseries_groups_from_url = async (http_prefix, url_timeseries_groups) => {
	    if (url_timeseries_groups == null) {
		url_timeseries_groups = ntopng_url_manager$1.get_url_entry("timeseries_groups");
	    }
	    if (url_timeseries_groups == null || url_timeseries_groups == "") {
		return null;
	    }
	    let groups = url_timeseries_groups.split(";");
	    if (!groups?.length > 0) {
		return null;
	    }
	    let timeseries_groups = Promise.all(groups.map(async (g) => {
		let ts_group = await get_url_param_from_ts_group(g);
		return ts_group;
	    }));
	    return timeseries_groups;
	};

	const get_ts_group = (source_type, source, metric) => {
	    let id = get_ts_group_id(source_type, source, metric);
	    let timeseries = [];
	    for (let key in metric.timeseries) {
		let ts = metric.timeseries[key];
		timeseries.push({
		    id: key,
		    label: ts.label,
		    raw: true,
		    past: false,
		    avg: false,
		    perc_95: false,
		});
	    }
	    return {
		id, source_type, source, metric, timeseries,
	    };
	};

	const get_default_timeseries_groups = async (http_prefix, metric_ts_schema) => {
	    let source_type = get_current_page_source_type();
	    let source = await get_default_source(http_prefix, source_type);
	    let metrics = await get_metrics(http_prefix, source_type, source);
	    let metric = get_default_metric(metrics, metric_ts_schema);
	    let ts_group = get_ts_group(source_type, source, metric);
	    return [ts_group];
	};

	async function get_url_param_from_ts_group(ts_group_url_param) {
	    let g = ts_group_url_param;
	    let info = g.split(",");
	    let source_type_id = info[0];
	    let source_value_query = info[1];
	    let source_value_query_array = source_value_query.split("+");
	    if (source_value_query_array.lenght < 2) {
		source_value_query_array.push(null);
	    }
	    let metric_schema_query = info[2];
	    let metric_schema_query_array = metric_schema_query.split("+");
	    if (metric_schema_query_array.lenght < 2) {
		metric_schema_query_array.push(null);
	    }
	    let timeseries_url = info[3];

	    let source_type = get_source_type_from_id(source_type_id);
	    let source = await get_source_from_value(http_prefix, source_type, source_value_query_array[0], source_value_query_array[1]);
	    let metric = await get_metrics_from_schema(http_prefix, source_type, source, metric_schema_query_array[0], metric_schema_query_array[1]);
	    let timeseries = get_timeseries(timeseries_url, metric);
	    return {
		id: get_ts_group_id(source_type, source, metric),
		source_type,
		source,
		metric,
		timeseries,
	    };
	}

	const get_ts_group_id = (source_type, source, metric) => {
	    let metric_id = metric.schema;
	    if (metric.query != null) {
		metric_id = `${metric_id} - ${metric.query}`;
	    }
	    let source_value = source.value;
	    if (source.sub_value != null) {
		source_value = `${source_value}_${source.sub_value}`;
	    }
	    return `${source_type.value} - ${source_value} - ${metric_id}`;
	};

	function get_timeseries(timeseries_url, metric) {
	    let ts_url_array = timeseries_url.split("|");
	    let r = /(.+)=(.+):(.+):(.+):(.+)/;
	    let timeseries = [];
	    ts_url_array.forEach((ts_url) => {
		let values = r.exec(ts_url);
		let id = values[1];
		let label = metric.timeseries[id].label;
		let raw = JSON.parse(values[2]);
		let past = JSON.parse(values[3]);
		let avg = JSON.parse(values[4]);
		let perc_95 = JSON.parse(values[5]);
		timeseries.push({
		    id, label, raw, past, avg, perc_95,
		});
	    });
	    return timeseries;
	}

	const ui_types = {
	    hide: "hide",
	    select: "select",
	    select_and_select: "select_and_select",
	    select_and_input: "select_and_input",
	};

	// dictionary of functions to convert an element of source_url rest result to a source ({label, value })
	const sources_url_el_to_source = {
	    ifid: (s) => {
		let label = s.ifname;
		if (s.name != null) {
		    label = s.name;
		}
	        return {
		    label,
		    value: s.ifid,
	        };
	    },
	    pool: (p) => {
		let label = p.pool_id;
		if (p.name != null) { label = p.name; }
		return {
		    label,
		    value: p.pool_id,
		};
	    },
	};

	const sources_types = [
	    {
		id: "ifid",
		regex_page_url: "lua\/if_stats",
		label: "Interface",
		sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		value: "ifid",
		ui_type: ui_types.select,
		table_value: "interface",
		query: "iface",
	    },
	    {
		id: "host",
		regex_page_url: "lua\/host_details",
		label: "Host",
		value: "host",
		regex_type: "ip",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		table_value: "host",
		query: "host",
	    },
	    {
		id: "mac",
		regex_page_url: "lua\/mac_details",
		label: "Mac",
		value_url: "host",
		value: "mac",
		regex_type: "macAddress",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "mac",
	    },
	    {
		id: "network",
		regex_page_url: "lua\/network_details",
		label: "Network",
		// value_url: "subnet",
		value: "subnet",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "subnet",
	    },
	    {
		id: "as",
		regex_page_url: "lua\/as_details",
		label: "ASN",
		value: "asn",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "asn",
	    },
	    {
		id: "country",
		regex_page_url: "lua\/country_details",
		label: "Country",
		value: "country",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "country",
	    },
	    {
		id: "os",
		regex_page_url: "lua\/os_details",
		label: "OS",
		value: "os",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "os",
	    },
	    {
		id: "vlan",
		regex_page_url: "lua\/vlan_details",
		label: "VLAN",
		value: "vlan",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "vlan",
	    },
	    {
		id: "pool",
		regex_page_url: "lua\/pool_details",
		label: "Host Pool",
		// get sources_url() { return `lua/rest/v2/get/host/pools.lua?_=${Date.now()}` },
		sources_url: `lua/rest/v2/get/host/pools.lua`,
		value: "pool",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_select,
		query: "host_pool",
	    },
	    {
		id: "observation",
		regex_page_url: "lua\/pro\/enterprise\/observation_points",
		label: "Observation",
		value: "observation_point",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "obs_point",
	  ts_query: "obs_point",
	    },
	    {
		id: "pod",
		regex_page_url: "lua\/pod_details",
		label: "Pod",
		value: "pod",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "pod",
	  ts_query: "pod",
	    },
	    {
		id: "container",
		regex_page_url: "lua\/container_details",
		label: "Container",
		value: "container",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "container",
	    },
	    {
		id: "hash",
		regex_page_url: "lua\/hash_table_details",
		label: "Hash Table",
		value: "hash_table",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "ht",
	    },
	    {
		id: "system",
		regex_page_url: "lua\/system_stats",
		label: "System Stats",
		value: "ifid",
		sources_function: () => { return [{ label: "", value: -1 }] },
		regex_type: "text",
		ui_type: ui_types.hide,
		query: "system",
	    },
	    {
		id: "profile",	
		regex_page_url: "lua\/profile_details",
		label: "Profile",
		value: "profile",
		regex_type: "text",
		sources_sub_url: "lua/rest/v2/get/ntopng/interfaces.lua",
		sub_value: "ifid",
		sub_label: "Interface",
		ui_type: ui_types.select_and_input,
		query: "profile",
	    },
	    {
		id: "n_edge_interface",
		regex_page_url: "lua\/pro\/nedge\/if_stats.lua",
		label: "Profile",
		value: "ifid",
		regex_type: "text",
		ui_type: ui_types.select_and_input,
		query: "iface:nedge",
	    },
	    {
		id: "redis",
		regex_page_url: "lua\/monitor\/redis_monitor.lua",
		label: "Redis",
		value: "ifid",
		regex_type: "text",
		ui_type: ui_types.select_and_input,
		query: "redis",
	    },
	    {
		id: "influx",
		regex_page_url: "lua\/monitor\/influxdb_monitor.lua",
		label: "Influx DB",
		value: "ifid",
		regex_type: "text",
		ui_type: ui_types.select_and_input,
		query: "influxdb",
	    },
	    {
		id: "active_monitoring",
		regex_page_url: "lua\/monitor\/active_monitoring_monitor.lua",
		label: "Active Monitoring",
		value: "am_host",
		regex_type: "text",
		ui_type: ui_types.select_and_input,
		query: "am_host",
		ts_query: "host",
	    },
	];

	const get_source_type_from_id = (source_type_id) => {
	    return sources_types.find((st) => st.id == source_type_id);
	};

	async function get_default_sub_source(http_prefix, sub_source_type_id) {
	    let sub_source_type = get_source_type_from_id(sub_source_type_id);
	    return get_default_source(http_prefix, sub_source_type);    
	}

	const get_default_source = async (http_prefix, source_type) => {
	    let source_value = get_default_source_value(source_type);
	    let source_sub_value;
	    if (source_type.sub_value && source_type.sub_value != "") {
		source_sub_value = get_default_source_value({ value: source_type.sub_value });
	    }
	    let source = await get_source_from_value(http_prefix, source_type, source_value, source_sub_value);
	    return source;
	};

	async function add_source_to_sources(http_prefix, source_type, source) {
	    let sources = await get_sources(http_prefix, source_type);
	    let is_found = sources.some((s) => s.value == source.value && s.sub_value == source.sub_value);
	    if (is_found == false) {
		sources.push(source);
	    }
	}

	const get_source_from_value = async (http_prefix, source_type, source_value, source_sub_value) => {
	    if (source_type == null) {
		source_type = get_current_page_source_type();
	    }
	    if (source_type.sources_url || source_type.sources_function) {
		let sources;
		if (source_type.sources_url) {
		    sources = await get_sources(http_prefix, source_type);
		} else {
		    sources = source_type.sources_function();
		}
		let source = sources.find((s) => s.value == source_value);
		if (source != null && source_sub_value != null) {
		    source.sub_value = source_sub_value;
		}
		return source;
	    } else {
		if (source_sub_value == null) {
		    source_sub_value = get_default_source_value({ value: source_type.sub_value });
		}
		if (source_value == null) {
		    source_value = "";
		}
		let source = { label: source_value, value: source_value, sub_value: source_sub_value };
		//add_source_to_sources(http_prefix, source_type, source);
		return source;
	    }
	};

	let cache_sources = {};

	async function get_sub_sources(http_prefix, source_type_sub_value) {
	    let source_type = sources_types.find((s) => s.value = source_type_sub_value);
	    return get_sources(http_prefix, source_type);
	}

	const get_sources = async (http_prefix, source_type) => {
	    if (source_type == null) {
		source_type = get_current_page_source_type();
	    }
	    let key = source_type.value;    
	    if (cache_sources[key] == null) {
		if (source_type.sources_url) {
		    let url = `${http_prefix}/${source_type.sources_url}`;
		    cache_sources[key] = ntopng_utility$1.http_request(url);
		} else if (source_type.sources_function) {
		    cache_sources[key] = source_type.sources_function();
		} else {
		    return [];
		}
	    }
	    let sources = await cache_sources[key];
	    if (source_type.sources_url) {
		let f_map_source_element = sources_url_el_to_source[source_type.value];
		if (f_map_source_element == null) {
		    throw `:Error: metrics-manager.js, missing sources_url_to_source ${source_type.value} key`;
		}
		sources = sources.map((s) => f_map_source_element(s));
	    }
	    return sources.sort(NtopUtils$1.sortAlphabetically)    
	};

	function get_source_type_key_value_url(source_type) {
	    if (source_type.value_url != null) { return source_type.value_url; }
	    return source_type.value;
	}

	function get_source_type_key_sub_value_url(source_type) {
	    if (source_type.sub_value_url != null) { return source_type.sub_value_url; }
	    return source_type.sub_value;
	}

	const get_default_source_value = (source_type) => {
	    if (source_type == null) {
		source_type = get_current_page_source_type();
	    }
	    let source_type_value_url = source_type.value_url;
	    if (source_type_value_url == null) {
		source_type_value_url = source_type.value;
	    }
	    return ntopng_url_manager$1.get_url_entry(source_type_value_url);
	};

	function get_metrics_url(http_prefix, source_type, source_value, source_sub_value) {
	    let params = `${source_type.value}=${source_value}`;
	    if (source_type.sub_value != null && source_sub_value != null) {
		params = `${params}&${source_type.sub_value}=${source_sub_value}`;
	    }
	    let url = `${http_prefix}/lua/rest/v2/get/timeseries/type/consts.lua?query=${source_type.query}&${params}`;
	    return url;
	}

	function get_metric_key(source_type, source) {
	    let key = `${source_type.value}_${source.value}`;
	    if (source.sub_value != null) {
		key = `${key}_${source.sub_value}`;
	    }
	    return key;
	}

	let cache_metrics = {};
	let last_metrics_time_interval = null;
	const get_metrics = async (http_prefix, source_type, source) => {
	    let epoch_begin = ntopng_url_manager$1.get_url_entry("epoch_begin");
	    let epoch_end = ntopng_url_manager$1.get_url_entry("epoch_end");
	    let current_last_metrics_time_interval = `${epoch_begin}_${epoch_end}`;
	    if (source_type == null) {
		source_type = get_current_page_source_type();
	    }
	    if (source == null) {
		source = await get_default_source(http_prefix, source_type);
	    }
	    // let url = `${http_prefix}/lua/rest/v2/get/timeseries/type/consts.lua?query=${source_type.value}`;
	    let url = get_metrics_url(http_prefix, source_type, source.value, source.sub_value);
	    let key = get_metric_key(source_type, source);
	    if (current_last_metrics_time_interval != last_metrics_time_interval) {
		cache_metrics[key] = null;
		last_metrics_time_interval = current_last_metrics_time_interval;
	    }
	    if (cache_metrics[key] == null) {
		cache_metrics[key] = ntopng_utility$1.http_request(url);
	    }
	    let metrics = await cache_metrics[key];
	    return ntopng_utility$1.clone(metrics);
	};

	const get_current_page_source_type = () => {
	    let pathname = window.location.pathname;
	    for (let i = 0; i < sources_types.length; i += 1) {
		let regExp = new RegExp(sources_types[i].regex_page_url);
		if (regExp.test(pathname) == true) {
		    return sources_types[i];
		}
	    }
	    // if (/lua\/if_stats/.test(pathname) == true) {
	    // 	return sources_types[0];
	    // } else if (/lua\/host_details/.test(pathname) == true) {
	    // 	return sources_types[1];
	    // } else if (/lua\/mac_details/.test(pathname) == true) {
	    // 	return sources_types[2];
	    // }
	    throw `source_type not found for ${pathname}`;
	};

	const get_metrics_from_schema = async (http_prefix, source_type, source, metric_schema, metric_query) => {
	    let metrics = await get_metrics(http_prefix, source_type, source);
	    return metrics.find((m) => m.schema == metric_schema && m.query == metric_query); 
	};

	const get_default_metric = (metrics, metric_ts_schema) => {
	    let default_metric;
	    if (metric_ts_schema != null) {
		default_metric = metrics.find((m) => m.schema == metric_ts_schema);
	    }
	    if (default_metric == null) {
		default_metric = metrics.find((m) => m.default_visible == true);
	    }
	    if (default_metric != null) {
		return default_metric;
	    }
	    return metrics[0];
	};

	const metricsManager = function() {
	    return {
		set_timeseries_groups_in_url,
		get_timeseries_groups_from_url,
		get_default_timeseries_groups,
		get_ts_group,
		get_ts_group_id,

		sources_types,
		get_source_type_from_id,
		get_current_page_source_type,

		get_sources,
		get_sub_sources,
		get_default_source,
		get_default_sub_source,
		get_source_from_value,	
		get_default_source_value,
		add_source_to_sources,

		get_metrics,
		get_metrics_from_schema,
		get_default_metric,

		get_source_type_key_value_url,
		get_source_type_key_sub_value_url,

		ui_types,
	    };
	}();

	const Utils = NtopUtils$1;
	function get_data_pattern(type) {
	    if (type == "text") {
		return `.*`;
	    } else if (type == "ip") {
		let r_ipv4 = Utils.REGEXES.ipv4;
		let r_ipv4_vlan = r_ipv4.replace("$", "@[0-9]{0,5}$");
		let r_ipv6 = Utils.REGEXES.ipv6;
		let r_ipv6_vlan = r_ipv6.replaceAll("$", "@[0-9]{0,5}$");
		return `(${r_ipv4})|(${r_ipv4_vlan})|(${r_ipv6})|(${r_ipv6_vlan})`;
	    }
	    return Utils.REGEXES[type];
	}

	const regexValidation = function() {
	    return {
		get_data_pattern,
	    };
	}();

	const _hoisted_1$s = { class: "nav nav-tabs" };
	const _hoisted_2$q = { class: "form-group ms-2 me-2 mt-3 row" };
	const _hoisted_3$o = { class: "col-form-label col-sm-4" };
	const _hoisted_4$n = { class: "col-sm-8" };
	const _hoisted_5$m = {
	  key: 0,
	  class: "form-group ms-2 me-2 mt-3 row"
	};
	const _hoisted_6$m = { class: "col-form-label col-sm-4" };
	const _hoisted_7$l = { class: "col-sm-8" };
	const _hoisted_8$k = { class: "form-group ms-2 me-2 mt-3 ms-1 me-1" };
	const _hoisted_9$i = { class: "form-group row ms-1 mb-2" };
	const _hoisted_10$f = { class: "col-form-label col-sm-4" };
	const _hoisted_11$f = { class: "col-sm-8" };
	const _hoisted_12$e = { class: "form-group ms-2 me-2 mt-3 ms-3 me-1 row" };
	const _hoisted_13$d = { class: "col-form-label col-sm-4" };
	const _hoisted_14$a = { class: "col-sm-8" };
	const _hoisted_15$9 = { class: "form-group ms-2 me-2 mt-3 ms-3 me-1 row" };
	const _hoisted_16$8 = { class: "col-form-label col-sm-4" };
	const _hoisted_17$8 = { class: "col-sm-6" };
	const _hoisted_18$7 = {
	  class: "col-sm-2",
	  style: {"text-align":"end !important"}
	};
	const _hoisted_19$7 = ["disabled"];
	const _hoisted_20$6 = {
	  key: 2,
	  class: "form-group ms-2 me-2 mt-3"
	};
	const _hoisted_21$2 = { class: "form-group row ms-1 me-1 mb-2" };
	const _hoisted_22$2 = { class: "col-form-label col-sm-4" };
	const _hoisted_23$2 = { class: "col-sm-8" };
	const _hoisted_24$2 = { class: "form-group row ms-3 me-1" };
	const _hoisted_25$2 = { class: "col-form-label col-sm-4" };
	const _hoisted_26$2 = { class: "col-sm-8" };
	const _hoisted_27$2 = { class: "form-group row ms-3 me-1" };
	const _hoisted_28$1 = { class: "col-form-label col-sm-4" };
	const _hoisted_29$1 = { class: "col-sm-6" };
	const _hoisted_30$1 = ["pattern"];
	const _hoisted_31$1 = {
	  class: "col-sm-2",
	  style: {"text-align":"end !important"}
	};
	const _hoisted_32$1 = ["disabled"];
	const _hoisted_33$1 = { class: "form-group ms-2 me-2 mt-3 row" };
	const _hoisted_34$1 = { class: "col-form-label col-sm-4" };
	const _hoisted_35$1 = { class: "col-sm-8" };


	var script$v = {
	  __name: 'modal-timeseries',
	  emits: ['apply'],
	  setup(__props, { expose, emit }) {

	const modal_id = ref(null);
	const select_search_metrics = ref(null);

	const showed = () => {};

	const action = ref("select"); // add/select 

	let current_page_source_type = metricsManager.get_current_page_source_type();

	const sources_types = metricsManager.sources_types;
	const selected_source_type = ref(current_page_source_type);

	const ui_types = metricsManager.ui_types;
	const sources = ref([]);
	const selected_source = ref({});
	const selected_source_text = ref("");
	const sub_sources = ref([]);
	const selected_sub_source = ref({});
	const source_text = ref("");
	const regex_source = selected_source_type.value?.regex_type;
	const source_text_validation = ref(regexValidation.get_data_pattern(regex_source));
	const is_source_text_valid = computed$1(() => {
	    let regex = new RegExp(source_text_validation.value);
	    return regex.test(source_text.value);
	});

	const metrics = ref([]);
	const selected_metric = ref({});

	const timeseries_groups_added = ref([]);

	const timeseries_to_add = ref([]);



	let wait_init = null;

	// const props = defineProps({
	//     timseries_groups: Array,
	// });


	onMounted(async () => {
	    wait_init = init();
	});

	// watch(() => props.timeseries_groups, (current_value, old_value) => {
	//     if (current_value == null) { return; }
	//     timeseries_groups_added.value = current_value;
	// });
	watch(() => action.value, (current_value, old_value) => {
	    if (current_value != "select_search_metrics") { return; }
	    //select_search.value.render();
	    // take default visible
	    // selected_metric.value = metricsManager.get_default_metric(metrics.value);
	    // select_search.value.init();
	}, { flush: 'post'});

	const show = async (timeseries_groups) => {
	    console.log(selected_metric.value);
	    timeseries_groups_added.value = timeseries_groups;
	    await wait_init;
	    action.value = "select";
	    modal_id.value.show();
	};

	function change_action(a) {
	    action.value = a;
	}

	async function apply_source_text(set_selected_source) {
	    if (set_selected_source == true) {
		selected_source.value = await metricsManager.get_source_from_value(http_prefix, selected_source_type.value, source_text.value, selected_sub_source.value.value);
	    } else {
		selected_source.value.sub_value = selected_sub_source.value.value;
	    }
	    set_selected_source_text();
	    await set_metrics();
	}

	async function change_source_type() {
	    let regex_source = selected_source_type.value?.regex_type;
	    source_text_validation.value = regexValidation.get_data_pattern(regex_source);

	    await set_sources();
	    await set_metrics();
	}

	async function change_source() {
	    await set_metrics();
	}

	function get_selected_source_text(source_label) {
	    if (source_label == null) {
		source_label = selected_source.value.label;
	    }
	    return `${selected_sub_source.value.label} - ${source_label}`;
	}

	function set_selected_source_text() {
	    selected_source_text.value = get_selected_source_text();
	}

	async function set_sources() {
	    if (selected_source_type.value.sub_value != null) {
		sub_sources.value = await metricsManager.get_sub_sources(http_prefix, selected_source_type.value.sub_value);
		selected_sub_source.value = await metricsManager.get_default_sub_source(http_prefix, selected_source_type.value.sub_value);
	    }
	    if (!selected_source_type.value.disable_url) {
		sources.value = await metricsManager.get_sources(http_prefix, selected_source_type.value);
	    }
	    let default_source = await metricsManager.get_default_source(http_prefix, selected_source_type.value);
	    selected_source.value = default_source;
	    // if (selected_source_type.value.ui_type == ui_types.select_and_input) {
		source_text.value = selected_source.value.value;
		set_selected_source_text();
	    // }
	}

	async function set_metrics() {
	    metrics.value = await metricsManager.get_metrics(http_prefix, selected_source_type.value, selected_source.value);
	    metrics.value.sort(NtopUtils.sortAlphabetically);
	    selected_metric.value = metricsManager.get_default_metric(metrics.value);
	}

	async function init() {
	    console.log("INIT MODAL TIMESERIES");
	    // set sources
	    await set_sources();
	    // set metrics
	    await set_metrics();
	    // take default visible
	    update_timeseries_to_add();
	    console.log("emit");
	    //emit('apply', timeseries_groups_added.value);
	}

	function update_timeseries_to_add(default_config) {
	    timeseries_to_add.value = [];
	    let timeseries = selected_metric.value.timeseries;
	    for (let ts_id in timeseries) {
	    	timeseries_to_add.value.push({
	    	    id: ts_id,
	    	    label: timeseries[ts_id].label,
	    	    raw: true,
		    past: false,
	    	    avg: false,
	    	    perc_95: false,
	    	});
	    }
	}

	function get_timeseries_group_name(ts_group) {
	    let source_type_name = ts_group.source_type.label;
	    let source_name = ts_group.source.label;
	    let metric_name = ts_group.metric.label;
	    return `${source_type_name} - ${source_name} - ${metric_name}`;
	}

	function get_timeseries_group_id(ts_group) {
	    let source_type, source, metric;
	    if (ts_group == null) {
		source_type = selected_source_type.value;
		source = selected_source.value;
		metric = selected_metric.value;
	    } else {
		source_type = ts_group.source_type;
		source = ts_group.source;
		metric = ts_group.metric;
	    }
	    let id = metricsManager.get_ts_group_id(source_type, source, metric);
	    console.log(`modal-timeseries: id = ${id}`);
	    return id;
	}

	const delete_ts = (ts_group_id) => {
	    timeseries_groups_added.value = timeseries_groups_added.value.filter((ts_group) => get_timeseries_group_id(ts_group) != ts_group_id);
	};

	const set_timeseries_groups = (timeseries_groups, emit_apply) => {
	    timeseries_groups_added.value = timeseries_groups;
	    if (emit_apply) {
		emit('apply', timeseries_groups_added.value);
	    }
	};

	const add_ts_group = (ts_group_to_add, emit_apply) => {
	    let ts_group_index = timeseries_groups_added.value.findIndex((ts_group) => ts_group.id == ts_group_to_add.id);
	    if (ts_group_index < 0) {
		timeseries_groups_added.value.push(ts_group_to_add);
	    } else {
		timeseries_groups_added.value[ts_group_index] = ts_group_to_add;
	    }

	    if (emit_apply) {
		emit('apply', timeseries_groups_added.value);
	    }
	};

	const apply = () => {
	    if (action.value == "add") {
		let ts_group_id = get_timeseries_group_id();
		let ts_group = {
		    id: ts_group_id,
		    source_type: selected_source_type.value,
		    source: selected_source.value,
		    metric: selected_metric.value,
		    timeseries: ntopng_utility$1.clone(timeseries_to_add.value),
		};
		add_ts_group(ts_group);
	    }
	    emit('apply', timeseries_groups_added.value);
	    close();
	};

	const close = () => {
	    modal_id.value.close();
	};
	const _i18n = (t) => i18n(t);

	expose({ show, close, add_ts_group, set_timeseries_groups });


	return (_ctx, _cache) => {
	  return (openBlock(), createBlock(script$y, {
	    onShowed: _cache[17] || (_cache[17] = $event => (showed())),
	    ref_key: "modal_id",
	    ref: modal_id
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(_i18n("modal_timeseries.title")), 1 /* TEXT */)
	    ]),
	    body: withCtx(() => [
	      createBaseVNode("ul", _hoisted_1$s, [
	        createBaseVNode("li", {
	          class: "nav-item",
	          onClick: _cache[0] || (_cache[0] = $event => (change_action('add')))
	        }, [
	          createBaseVNode("a", {
	            class: normalizeClass(["nav-link", {'active': action.value == 'add'}]),
	            href: "#"
	          }, toDisplayString(_i18n("modal_timeseries.add_timeseries")), 3 /* TEXT, CLASS */)
	        ]),
	        createBaseVNode("li", {
	          class: "nav-item",
	          onClick: _cache[1] || (_cache[1] = $event => (change_action('select')))
	        }, [
	          createBaseVNode("a", {
	            class: normalizeClass(["nav-link", {'active': action.value == 'select' }]),
	            href: "#"
	          }, toDisplayString(_i18n("modal_timeseries.manage_timeseries")), 3 /* TEXT, CLASS */)
	        ])
	      ]),
	      createCommentVNode(" action add "),
	      (action.value == 'add')
	        ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
	            createCommentVNode(" Sources Types "),
	            createBaseVNode("div", _hoisted_2$q, [
	              createBaseVNode("label", _hoisted_3$o, [
	                createBaseVNode("b", null, toDisplayString(_i18n("modal_timeseries.source_type")), 1 /* TEXT */)
	              ]),
	              createBaseVNode("div", _hoisted_4$n, [
	                createVNode(script$A, {
	                  selected_option: selected_source_type.value,
	                  "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => ((selected_source_type).value = $event)),
	                  onSelect_option: _cache[3] || (_cache[3] = $event => (change_source_type())),
	                  options: unref(sources_types)
	                }, null, 8 /* PROPS */, ["selected_option", "options"])
	              ])
	            ]),
	            createCommentVNode(" Sources "),
	            createCommentVNode(" Interface "),
	            (selected_source_type.value.ui_type == unref(ui_types).select)
	              ? (openBlock(), createElementBlock("div", _hoisted_5$m, [
	                  createBaseVNode("label", _hoisted_6$m, [
	                    createBaseVNode("b", null, toDisplayString(_i18n("modal_timeseries.source")), 1 /* TEXT */)
	                  ]),
	                  createBaseVNode("div", _hoisted_7$l, [
	                    createVNode(script$A, {
	                      selected_option: selected_source.value,
	                      "onUpdate:selected_option": _cache[4] || (_cache[4] = $event => ((selected_source).value = $event)),
	                      onSelect_option: _cache[5] || (_cache[5] = $event => (change_source())),
	                      options: sources.value
	                    }, null, 8 /* PROPS */, ["selected_option", "options"])
	                  ])
	                ]))
	              : createCommentVNode("v-if", true),
	            createCommentVNode(" Pool "),
	            (selected_source_type.value.ui_type == unref(ui_types).select_and_select)
	              ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
	                  createBaseVNode("div", _hoisted_8$k, [
	                    createBaseVNode("div", _hoisted_9$i, [
	                      createBaseVNode("label", _hoisted_10$f, [
	                        createBaseVNode("b", null, toDisplayString(_i18n("modal_timeseries.source")), 1 /* TEXT */)
	                      ]),
	                      createBaseVNode("div", _hoisted_11$f, [
	                        withDirectives(createBaseVNode("input", {
	                          class: "form-control",
	                          "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((selected_source_text).value = $event)),
	                          type: "text",
	                          disabled: ""
	                        }, null, 512 /* NEED_PATCH */), [
	                          [vModelText, selected_source_text.value]
	                        ])
	                      ])
	                    ])
	                  ]),
	                  createBaseVNode("div", _hoisted_12$e, [
	                    createBaseVNode("label", _hoisted_13$d, [
	                      createBaseVNode("b", null, toDisplayString(selected_source_type.value.sub_label), 1 /* TEXT */)
	                    ]),
	                    createBaseVNode("div", _hoisted_14$a, [
	                      createVNode(script$A, {
	                        selected_option: selected_sub_source.value,
	                        "onUpdate:selected_option": _cache[7] || (_cache[7] = $event => ((selected_sub_source).value = $event)),
	                        options: sub_sources.value
	                      }, null, 8 /* PROPS */, ["selected_option", "options"])
	                    ])
	                  ]),
	                  createBaseVNode("div", _hoisted_15$9, [
	                    createBaseVNode("label", _hoisted_16$8, [
	                      createBaseVNode("b", null, toDisplayString(selected_source_type.value.label), 1 /* TEXT */)
	                    ]),
	                    createBaseVNode("div", _hoisted_17$8, [
	                      createVNode(script$A, {
	                        selected_option: selected_source.value,
	                        "onUpdate:selected_option": _cache[8] || (_cache[8] = $event => ((selected_source).value = $event)),
	                        options: sources.value
	                      }, null, 8 /* PROPS */, ["selected_option", "options"])
	                    ]),
	                    createBaseVNode("div", _hoisted_18$7, [
	                      createBaseVNode("button", {
	                        type: "button",
	                        disabled: !unref(is_source_text_valid),
	                        onClick: _cache[9] || (_cache[9] = $event => (apply_source_text(false))),
	                        class: "btn btn-primary"
	                      }, toDisplayString(_i18n("modal_timeseries.apply")), 9 /* TEXT, PROPS */, _hoisted_19$7)
	                    ])
	                  ])
	                ], 64 /* STABLE_FRAGMENT */))
	              : createCommentVNode("v-if", true),
	            createCommentVNode(" Host, Mac "),
	            (selected_source_type.value.ui_type == unref(ui_types).select_and_input)
	              ? (openBlock(), createElementBlock("div", _hoisted_20$6, [
	                  createBaseVNode("div", _hoisted_21$2, [
	                    createBaseVNode("label", _hoisted_22$2, [
	                      createBaseVNode("b", null, toDisplayString(_i18n("modal_timeseries.source")), 1 /* TEXT */)
	                    ]),
	                    createBaseVNode("div", _hoisted_23$2, [
	                      withDirectives(createBaseVNode("input", {
	                        class: "form-control",
	                        "onUpdate:modelValue": _cache[10] || (_cache[10] = $event => ((selected_source_text).value = $event)),
	                        type: "text",
	                        disabled: ""
	                      }, null, 512 /* NEED_PATCH */), [
	                        [vModelText, selected_source_text.value]
	                      ])
	                    ])
	                  ]),
	                  createBaseVNode("div", _hoisted_24$2, [
	                    createBaseVNode("label", _hoisted_25$2, [
	                      createBaseVNode("b", null, toDisplayString(selected_source_type.value.sub_label), 1 /* TEXT */)
	                    ]),
	                    createBaseVNode("div", _hoisted_26$2, [
	                      createVNode(script$A, {
	                        selected_option: selected_sub_source.value,
	                        "onUpdate:selected_option": _cache[11] || (_cache[11] = $event => ((selected_sub_source).value = $event)),
	                        options: sub_sources.value
	                      }, null, 8 /* PROPS */, ["selected_option", "options"])
	                    ])
	                  ]),
	                  createBaseVNode("div", _hoisted_27$2, [
	                    createBaseVNode("label", _hoisted_28$1, [
	                      createBaseVNode("b", null, toDisplayString(selected_source_type.value.label), 1 /* TEXT */)
	                    ]),
	                    createBaseVNode("div", _hoisted_29$1, [
	                      withDirectives(createBaseVNode("input", {
	                        class: "form-control",
	                        "onUpdate:modelValue": _cache[12] || (_cache[12] = $event => ((source_text).value = $event)),
	                        pattern: source_text_validation.value,
	                        required: "",
	                        type: "text",
	                        placeholder: ""
	                      }, null, 8 /* PROPS */, _hoisted_30$1), [
	                        [vModelText, source_text.value]
	                      ])
	                    ]),
	                    createBaseVNode("div", _hoisted_31$1, [
	                      createBaseVNode("button", {
	                        type: "button",
	                        disabled: !unref(is_source_text_valid),
	                        onClick: _cache[13] || (_cache[13] = $event => (apply_source_text(true))),
	                        class: "btn btn-primary"
	                      }, toDisplayString(_i18n("modal_timeseries.apply")), 9 /* TEXT, PROPS */, _hoisted_32$1)
	                    ])
	                  ])
	                ]))
	              : createCommentVNode("v-if", true),
	            createCommentVNode(" Metrics "),
	            createBaseVNode("div", _hoisted_33$1, [
	              createBaseVNode("label", _hoisted_34$1, [
	                createBaseVNode("b", null, toDisplayString(_i18n("modal_timeseries.metric")), 1 /* TEXT */)
	              ]),
	              createBaseVNode("div", _hoisted_35$1, [
	                createCommentVNode(" <select class=\"form-select\" @click=\"update_timeseries_to_add()\" v-model=\"selected_metric\"> "),
	                createCommentVNode("   <option v-for=\"item in metrics\" :value=\"item\">{{item.label}}</option> "),
	                createCommentVNode(" </select> "),
	                createVNode(script$A, {
	                  ref_key: "select_search_metrics",
	                  ref: select_search_metrics,
	                  onSelect_option: _cache[14] || (_cache[14] = $event => (update_timeseries_to_add())),
	                  selected_option: selected_metric.value,
	                  "onUpdate:selected_option": _cache[15] || (_cache[15] = $event => ((selected_metric).value = $event)),
	                  options: metrics.value
	                }, null, 8 /* PROPS */, ["selected_option", "options"])
	              ])
	            ]),
	            createVNode(script$w, {
	              id: get_timeseries_group_id(),
	              title: _i18n('modal_timeseries.timeseries_list'),
	              timeseries: timeseries_to_add.value,
	              "onUpdate:timeseries": _cache[16] || (_cache[16] = $event => ((timeseries_to_add).value = $event))
	            }, null, 8 /* PROPS */, ["id", "title", "timeseries"])
	          ], 64 /* STABLE_FRAGMENT */))
	        : createCommentVNode("v-if", true),
	      createCommentVNode(" action == add "),
	      createCommentVNode(" action select"),
	      (action.value == 'select')
	        ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
	            (openBlock(true), createElementBlock(Fragment, null, renderList(timeseries_groups_added.value, (item) => {
	              return (openBlock(), createBlock(script$w, {
	                id: get_timeseries_group_id(item),
	                title: get_timeseries_group_name(item),
	                timeseries: item.timeseries,
	                "onUpdate:timeseries": $event => ((item.timeseries) = $event),
	                show_delete_button: timeseries_groups_added.value.length > 1,
	                onDelete_ts: delete_ts
	              }, null, 8 /* PROPS */, ["id", "title", "timeseries", "onUpdate:timeseries", "show_delete_button"]))
	            }), 256 /* UNKEYED_FRAGMENT */)),
	            createCommentVNode(" v-for timeseries_groups_added ")
	          ], 64 /* STABLE_FRAGMENT */))
	        : createCommentVNode("v-if", true),
	      createCommentVNode(" action == select ")
	    ]),
	    footer: withCtx(() => [
	      withDirectives(createBaseVNode("button", {
	        type: "button",
	        onClick: apply,
	        class: "btn btn-primary"
	      }, toDisplayString(_i18n("modal_timeseries.add")), 513 /* TEXT, NEED_PATCH */), [
	        [vShow, action.value == 'add']
	      ]),
	      withDirectives(createBaseVNode("button", {
	        type: "button",
	        onClick: apply,
	        class: "btn btn-primary"
	      }, toDisplayString(_i18n("modal_timeseries.apply")), 513 /* TEXT, NEED_PATCH */), [
	        [vShow, action.value == 'select']
	      ])
	    ]),
	    _: 1 /* STABLE */
	  }, 512 /* NEED_PATCH */))
	}
	}

	};

	var css_248z$7 = "\ninput[data-v-103cd911]:invalid {\n  border-color: #ff0000;\n}\n.warn[data-v-103cd911] {\nborder-color: #ffd500;\nborder-style: solid;\n}\n";
	styleInject(css_248z$7);

	script$v.__scopeId = "data-v-103cd911";
	script$v.__file = "http_src/vue/modal-timeseries.vue";

	var script$u = defineComponent({
	    components: {
		'modal': script$y,
	    },
	    props: {
		id: String,
	    },
	    updated() {
	    },
	    data() {
		return {
		    description: "",
		    invalid_bpf: false,
		    bpf_filter: "",
		    extract_now: true,
		    show_menu: true,
		    i18n: (t) => i18n(t),
		    id_modal: `${this.$props.id}_modal`,
		};
	    },
	    emits: ["apply"],
	    created() {
	    },
	    /** This method is the first method called after html template creation. */
	    mounted() {
	    },
	    methods: {
		pad2_number: function(number) {
		    return String(number).padStart(2, '0');
		},
		format_date: function(d) {
		    // let day = this.pad2_number(d.getDate());
		    // let month = this.pad2_number(d.getMonth());
		    // let hours = this.pad2_number(d.getHours());
		    // let minutes = this.pad2_number(d.getMinutes());
		    // let s = `${day}/${month}/${d.getFullYear()} ${hours}:${minutes}`;
		    let d_ms = d.valueOf();
		    return ntopng_utility.from_utc_to_server_date_format(d_ms);
		},
		apply: async function() {
		    if (this.bpf_filter != null && this.bpf_filter != "") {
			let url_request = `${http_prefix}/lua/pro/rest/v2/check/filter.lua?query=${this.bpf_filter}`;
			let res = await ntopng_utility.http_request(url_request, null, false, true);
			this.invalid_bpf = !res.response;
			if (this.invalid_bpf == true) {
			    return;
			}		
		    }
		    let url_request_obj = {
			ifid: ntopng_url_manager.get_url_entry("ifid"),
			epoch_begin: ntopng_url_manager.get_url_entry("epoch_begin"),
			epoch_end: ntopng_url_manager.get_url_entry("epoch_end"),
			bpf_filter: this.bpf_filter,
		    };
		    let url_request_params = ntopng_url_manager.obj_to_url_params(url_request_obj);
		    if (this.extract_now == true) {
			
			let url_request = `${http_prefix}/lua/rest/v2/get/pcap/live_extraction.lua?${url_request_params}`;
			window.open(url_request, '_self', false);
		    } else {
			let url_request = `${http_prefix}/lua/traffic_extraction.lua?${url_request_params}`;
			let resp = await ntopng_utility.http_request(url_request, null, false, true);
			let job_id = resp.id;
			//let job_id = 2;
			let alert_text_html = i18n('traffic_recording.extraction_scheduled');
			let page_name = i18n('traffic_recording.traffic_extraction_jobs');
			let ifid = ntopng_url_manager.get_url_entry("ifid");
			let href = `<a href="/lua/if_stats.lua?ifid=${ifid}&page=traffic_recording&tab=jobs&job_id=${job_id}">${page_name}</a>`; 
			alert_text_html = alert_text_html.replace('%{page}', href);
			alert_text_html = `${alert_text_html} ${job_id}`;
			ntopng_events_manager.emit_custom_event(ntopng_custom_events.SHOW_GLOBAL_ALERT_INFO, alert_text_html);
		    }
		    this.$refs["modal"].close();
		},
		show: async function(bpf_filter) {
		    if (bpf_filter == null) {
			let url_params = ntopng_url_manager.get_url_params();
			let url_request = `${http_prefix}/lua/pro/rest/v2/get/db/filter/bpf.lua?${url_params}`;
			let res = await ntopng_utility.http_request(url_request);
			if (res == null || res.bpf == null) {
			    console.error(`modal-traffic-extraction: ${url_request} return null value`);
			    return;
			}
			bpf_filter = res.bpf;
		    }
		    let status = ntopng_status_manager.get_status();
		    if (status.epoch_begin == null || status.epoch_end == null) {
			console.error("modal-traffic-extraction: epoch_begin and epoch_end undefined in url");
			return;
		    }
		    let date_begin = new Date(status.epoch_begin * 1000);
		    let date_end = new Date(status.epoch_end * 1000);
		    
		    let desc = i18n('traffic_recording.about_to_download_flow');
		    desc = desc.replace('%{date_begin}', this.format_date(date_begin));
		    desc = desc.replace('%{date_end}', this.format_date(date_end));
		    this.description = desc;
		    
		    // let url_params = ntopng_url_manager.get_url_params();
		    // let url_request = `${http_prefix}/lua/pro/rest/v2/get/db/filter/bpf.lua?${url_params}`;
		    // let res = await ntopng_utility.http_request(url_request);
		    // this.bpf_filter = res.bpf;
		    this.bpf_filter = bpf_filter;
		    this.$refs["modal"].show();
		},
		show_hide_menu: function() {
		    this.show_menu = !this.show_menu;
		},
	    },
	});

	const _withScopeId$5 = n => (pushScopeId("data-v-0be978c4"),n=n(),popScopeId(),n);
	const _hoisted_1$r = ["innerHTML"];
	const _hoisted_2$p = { style: {"height":"95%"} };
	const _hoisted_3$n = {
	  class: "tab-content",
	  style: {"height":"100%"}
	};
	const _hoisted_4$m = { class: "row" };
	const _hoisted_5$l = { class: "form-group mb-3 col-md-3 has-feedback" };
	const _hoisted_6$l = { class: "form-group mb-3 col-md-9 text-right asd" };
	const _hoisted_7$k = {
	  class: "radio-inline",
	  style: {"margin-left":"1rem"}
	};
	const _hoisted_8$j = { class: "radio-inline" };
	const _hoisted_9$h = {
	  class: "row",
	  id: "pcapDownloadModal_advanced",
	  style: {}
	};
	const _hoisted_10$e = { class: "form-group mb-3 col-md-12 has-feedback" };
	const _hoisted_11$e = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */));
	const _hoisted_12$d = { class: "form-label" };
	const _hoisted_13$c = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("a", {
	  class: "ntopng-external-link",
	  href: "https://www.ntop.org/guides/n2disk/filters.html"
	}, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-external-link-alt" })
	], -1 /* HOISTED */));
	const _hoisted_14$9 = { class: "input-group" };
	const _hoisted_15$8 = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("span", { class: "input-group-addon" }, [
	  /*#__PURE__*/createBaseVNode("span", { class: "glyphicon glyphicon-filter" })
	], -1 /* HOISTED */));
	const _hoisted_16$7 = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */));
	const _hoisted_17$7 = { class: "form-label" };
	const _hoisted_18$6 = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */));
	const _hoisted_19$6 = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("ul", null, [
	  /*#__PURE__*/createBaseVNode("li", null, [
	    /*#__PURE__*/createTextVNode("Host: "),
	    /*#__PURE__*/createBaseVNode("i", null, "host 192.168.1.2")
	  ]),
	  /*#__PURE__*/createBaseVNode("li", null, [
	    /*#__PURE__*/createTextVNode("HTTP: "),
	    /*#__PURE__*/createBaseVNode("i", null, "tcp and port 80")
	  ]),
	  /*#__PURE__*/createBaseVNode("li", null, [
	    /*#__PURE__*/createTextVNode("Traffic between hosts: "),
	    /*#__PURE__*/createBaseVNode("i", null, "ip host 192.168.1.1 and 192.168.1.2")
	  ]),
	  /*#__PURE__*/createBaseVNode("li", null, [
	    /*#__PURE__*/createTextVNode("Traffic from an host to another: "),
	    /*#__PURE__*/createBaseVNode("i", null, "ip src 192.168.1.1 and dst 192.168.1.2")
	  ])
	], -1 /* HOISTED */));

	function render$h(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_modal = resolveComponent("modal");

	  return (openBlock(), createBlock(_component_modal, {
	    id: _ctx.id_modal,
	    onApply: _ctx.apply,
	    ref: "modal"
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(_ctx.i18n('traffic_recording.pcap_extract')), 1 /* TEXT */)
	    ]),
	    body: withCtx(() => [
	      createBaseVNode("div", {
	        class: "alert alert-info",
	        innerHTML: _ctx.description
	      }, null, 8 /* PROPS */, _hoisted_1$r),
	      createBaseVNode("form", _hoisted_2$p, [
	        createBaseVNode("div", _hoisted_3$n, [
	          createBaseVNode("div", _hoisted_4$m, [
	            createBaseVNode("div", _hoisted_5$l, [
	              createBaseVNode("button", {
	                class: "btn btn-sm btn-secondary",
	                type: "button",
	                onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.show_hide_menu && _ctx.show_hide_menu(...args)))
	              }, [
	                createTextVNode(toDisplayString(_ctx.i18n('advanced')), 1 /* TEXT */),
	                createBaseVNode("i", {
	                  class: normalizeClass({ 'fas fa-caret-down': _ctx.show_menu, 'fas fa-caret-up': !_ctx.show_menu})
	                }, null, 2 /* CLASS */)
	              ])
	            ]),
	            createBaseVNode("div", _hoisted_6$l, [
	              createBaseVNode("label", _hoisted_7$k, [
	                withDirectives(createBaseVNode("input", {
	                  type: "radio",
	                  name: "extract_now",
	                  "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((_ctx.extract_now) = $event)),
	                  value: "true",
	                  checked: ""
	                }, null, 512 /* NEED_PATCH */), [
	                  [vModelRadio, _ctx.extract_now]
	                ]),
	                createTextVNode(" " + toDisplayString(_ctx.i18n('traffic_recording.extract_now')), 1 /* TEXT */)
	              ]),
	              createBaseVNode("label", _hoisted_8$j, [
	                withDirectives(createBaseVNode("input", {
	                  type: "radio",
	                  name: "extract_now",
	                  "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((_ctx.extract_now) = $event)),
	                  value: "false"
	                }, null, 512 /* NEED_PATCH */), [
	                  [vModelRadio, _ctx.extract_now]
	                ]),
	                createTextVNode(" " + toDisplayString(_ctx.i18n('traffic_recording.queue_as_job')), 1 /* TEXT */)
	              ])
	            ])
	          ]),
	          withDirectives(createBaseVNode("div", _hoisted_9$h, [
	            createBaseVNode("div", _hoisted_10$e, [
	              _hoisted_11$e,
	              createBaseVNode("label", _hoisted_12$d, [
	                createTextVNode(toDisplayString(_ctx.i18n('traffic_recording.filter_bpf')) + " ", 1 /* TEXT */),
	                _hoisted_13$c
	              ]),
	              createBaseVNode("div", _hoisted_14$9, [
	                _hoisted_15$8,
	                withDirectives(createBaseVNode("input", {
	                  name: "bpf_filter",
	                  "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ((_ctx.bpf_filter) = $event)),
	                  class: "form-control input-sm",
	                  "data-bpf": "bpf",
	                  autocomplete: "off",
	                  spellcheck: "false"
	                }, null, 512 /* NEED_PATCH */), [
	                  [vModelText, _ctx.bpf_filter]
	                ]),
	                withDirectives(createBaseVNode("span", {
	                  style: {"margin":"0px","padding":"0","display":"block"},
	                  class: "invalid-feedback"
	                }, toDisplayString(_ctx.i18n('invalid_value')), 513 /* TEXT, NEED_PATCH */), [
	                  [vShow, _ctx.invalid_bpf]
	                ])
	              ]),
	              _hoisted_16$7,
	              createBaseVNode("label", _hoisted_17$7, toDisplayString(_ctx.i18n('traffic_recording.filter_examples')) + ":", 1 /* TEXT */),
	              _hoisted_18$6,
	              _hoisted_19$6
	            ])
	          ], 512 /* NEED_PATCH */), [
	            [vShow, _ctx.show_menu]
	          ])
	        ])
	      ])
	    ]),
	    footer: withCtx(() => [
	      createBaseVNode("button", {
	        type: "button",
	        onClick: _cache[4] || (_cache[4] = (...args) => (_ctx.apply && _ctx.apply(...args))),
	        class: "btn btn-primary"
	      }, toDisplayString(_ctx.i18n('apply')), 1 /* TEXT */)
	    ]),
	    _: 1 /* STABLE */
	  }, 8 /* PROPS */, ["id", "onApply"]))
	}

	var css_248z$6 = "\ninput ~ .alert[data-v-0be978c4] {\n  display: none;\n}\ninput:invalid ~ .alert[data-v-0be978c4] {\n  display: block;\n}\n";
	styleInject(css_248z$6);

	script$u.render = render$h;
	script$u.__scopeId = "data-v-0be978c4";
	script$u.__file = "http_src/vue/modal-traffic-extraction.vue";

	var script$t = defineComponent({
	    components: {
	    },
	    props: {
		id: String,
	    },
	    emits: [],
	    /** This method is the first method of the component called, it's called before html template creation. */
	    created() {
	    },
	    data() {
		return {
		    show_alert: false,
		    i18n: (t) => i18n(t),
		    body: "",
		};
	    },
	    /** This method is the first method called after html template creation. */
	    mounted() {
		ntopng_events_manager.on_custom_event(this.$props["id"], ntopng_custom_events.SHOW_GLOBAL_ALERT_INFO, (html_text) => this.show(html_text));	
	    },
	    methods: {
		close: function() {
		    this.show_alert = false;
		},
		show: function(body) {
		    this.show_alert = true;
		    this.body = body;
		},
	    },
	});

	const _hoisted_1$q = {
	  key: 0,
	  style: {"width":"100%"},
	  class: "alert alert-success alert-dismissable"
	};
	const _hoisted_2$o = ["innerHTML"];

	function render$g(_ctx, _cache, $props, $setup, $data, $options) {
	  return (_ctx.show_alert == true)
	    ? (openBlock(), createElementBlock("div", _hoisted_1$q, [
	        createBaseVNode("span", { innerHTML: _ctx.body }, null, 8 /* PROPS */, _hoisted_2$o),
	        createBaseVNode("button", {
	          type: "button",
	          onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.close && _ctx.close(...args))),
	          class: "btn-close",
	          "aria-label": "Close"
	        })
	      ]))
	    : createCommentVNode("v-if", true)
	}

	script$t.render = render$g;
	script$t.__file = "http_src/vue/alert-info.vue";

	const _hoisted_1$p = /*#__PURE__*/createBaseVNode("tbody", null, null, -1 /* HOISTED */);


	var script$s = {
	  __name: 'datatable',
	  props: {
	  table_buttons: Array,
	  columns_config: Array,
	  data_url: String,
	  enable_search: Boolean,
	  filter_buttons: {
	    type: Array,
	    required: false,
	  },
	  table_config: {
	    type: Object,
	    required: false,
	  },
	  base_url: String,
	  base_params: Object, 
	},
	  setup(__props, { expose }) {

	const props = __props;



	let new_params = props.base_params;
	const table_id = ref(null);
	// let _this = getCurrentInstance().ctx;
	function setUserColumnsDefWidths() {
	  let userColumnDef;
	  // Get the settings for this table from localStorage
	  let userColumnDefs = JSON.parse(localStorage.getItem(table_id.value)) || [];
	  if (userColumnDefs.length === 0 ) return;

	  props.columns_config.forEach( function(columnDef) {
	    // Check if there is a width specified for this column
	    userColumnDef = userColumnDefs.find( function(column) {
	      return column.targets === columnDef.targets;
	    });

	    // If there is, set the width of this columnDef in px
	    if ( userColumnDef ) {
	      columnDef.width = userColumnDef.width + 'px';
	    }
	  });
	}

	function saveColumnSettings() {
		var userColumnDefs = JSON.parse(localStorage.getItem(table_id.value)) || [];
	  var width, header, existingSetting; 

	  table.columns().every( function ( targets ) {
	    // Check if there is a setting for this column in localStorage
	    existingSetting = userColumnDefs.findIndex( function(column) { return column.targets === targets;});
	    // Get the width of this column
	    header = this.header();
	    width = $(header).width();
	    if ( existingSetting !== -1 ) {
	      // Update the width
	      userColumnDefs[existingSetting].width = width;
	    } else {
	      // Add the width for this column
	      userColumnDefs.push({
	        targets: targets,
	        width:  width,
	      });
	    }
	  });

	  // Save (or update) the settings in localStorage
	  localStorage.setItem(table_id.value, JSON.stringify(userColumnDefs));
	}

	function reloadDataTable() {
	  loadDatatable();
	}

	function loadDatatable() {
	  setUserColumnsDefWidths();
	  
	  let updated = false;
	  /* Create a datatable with the buttons */
	  let extend_config = {
	    serverSide: false,
	    scrollX: true,
	    destroy: true,
	    searching: props.enable_search,
	    order: [[0, "asc"]],
	    pagingType: 'full_numbers',
	    columnDefs: props.columns_config,
	    columns: props.columns_config,
	    autoWidth: false,
	    ajax: {
	      method: 'get',
	      url: props.data_url,
	      dataSrc: 'rsp',
	      data: (data, settings) => {
	        if(Object.keys(data).length == 0) {
	          return;
	        }

	        const tableApi = settings.oInstance.api();
	        const orderColumnIndex = data.order[0].column;
	        const orderColumnName = tableApi.column(orderColumnIndex).name() || undefined;
	        
	        if (data.order) {
	          data.order = data.order[0].dir;
	          data.sort = orderColumnName;
	        }

	        if (data.columns !== undefined) {
	          delete data.columns;
	        }

	        if (data.search !== undefined) {
	          data.map_search = data.search.value;
	          delete data.search;
	        }
	        
	        return data;
	      },
	      beforeSend: function() {
	        NtopUtils.showOverlays();
	      },
	    },
	    initComplete: function (settings) {
	      //Add JQueryUI resizable functionality to each th in the ScrollHead table
	      $('#' + table_id.value.id + '_wrapper .dataTables_scrollHead thead th').resizable({
	        handles: "e",
	        alsoResize: '#' + table_id.value.id + '_wrapper .dataTables_scrollHead table', //Not essential but makes the resizing smoother
	        stop: function () {
	          saveColumnSettings();
	          reloadDataTable();
	        }
	      });
	    },
	    drawCallback: function (settings) {
	      NtopUtils.hideOverlays();
	      ntopng_events_manager.emit_custom_event(ntopng_custom_events.DATATABLE_LOADED);
	    }
	  };
	  for (const item in (props.table_config || {})) {
	    extend_config[item] = props.table_config[item];
	  }

	  let config = DataTableUtils.getStdDatatableConfig(props.table_buttons);
	  config = DataTableUtils.extendConfig(config, extend_config);
	  table = $(table_id.value).DataTable(config);
	  for (const filter of (props.filter_buttons || [])) {
	    /* Set filters to active if available in the url */
	    const curr_value = ntopng_url_manager$1.get_url_entry(filter.filterMenuKey);
	    if(curr_value && curr_value != '') {
	      let num_non_active_entries = 0;
	      filter.filters.forEach((i) => {
	        i.currently_active = false;
	        num_non_active_entries += 1;
	        if(i.id == curr_value) {
	          i.currently_active = true;
	          num_non_active_entries -= 1;
	        }
	      });

	      if(num_non_active_entries == filter.filters.length) {
	        ntopng_url_manager$1.set_key_to_url(filter.filterMenuKey, '');
	        updated = true;
	      }
	    }

	    new DataTableFiltersMenu({
	      filterTitle: filter.filterTitle,
	      tableAPI: table,
	      filters: filter.filters,
	      filterMenuKey: filter.filterMenuKey,
	      columnIndex: filter.columnIndex,
	      url: props.data_url,
	      id: filter.id,
	      removeAllEntry: filter.removeAllEntry,
	      callbackFunction: filter.callbackFunction
	    }).init();
	  }

	  if(updated && props.base_params) {
	    const entries = ntopng_url_manager$1.get_url_entries();
	    for(const [key, value] of (entries)) {
	      new_params[key] = value;
	    }
	    table.ajax.url(NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, new_params));
	    reload();
	  }
	}

	let table = null;
	onMounted(() => {
	  loadDatatable();
	});

	const reload = () => {
	  if (table == null) { return; }
	  table.ajax.reload();
	};

	const update_url = (new_url) => {
	  if (table == null) { return; }
	  table.ajax.url(new_url);
	};

	const delete_button_handlers = (handlerId) => {
	    DataTableUtils.deleteButtonHandlers(handlerId);
	};

	let is_destroyed = false;

	const destroy_table = () => {
	    table.clear();
	    table.destroy(true);
	    is_destroyed = true;
	    props.columns_config.filter((config) => config.handlerId != null).forEach((config) => {
		delete_button_handlers(config.handlerId);
	    });
	};

	expose({ reload, delete_button_handlers, destroy_table, update_url });

	onBeforeUnmount(() => {
	    if (is_destroyed == true) { return; }
	    destroy_table();
	    // table.destroy(true);
	});


	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock("div", null, [
	    createBaseVNode("table", {
	      ref_key: "table_id",
	      ref: table_id,
	      class: "table w-100 table-striped table-hover table-bordered"
	    }, [
	      createBaseVNode("thead", null, [
	        createBaseVNode("tr", null, [
	          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columns_config, (item) => {
	            return (openBlock(), createElementBlock("th", null, toDisplayString(item.columnName), 1 /* TEXT */))
	          }), 256 /* UNKEYED_FRAGMENT */))
	        ])
	      ]),
	      _hoisted_1$p
	    ], 512 /* NEED_PATCH */)
	  ]))
	}
	}

	};

	script$s.__file = "http_src/vue/datatable.vue";

	const _hoisted_1$o = { class: "table table-hover table-borderless mb-0" };
	const _hoisted_2$n = ["innerHTML"];
	const _hoisted_3$m = ["innerHTML"];


	var script$r = {
	  __name: 'bootstrap-table',
	  props: {
	    id: String,
	    columns: Array,
	    rows: Array,
	    print_html_column: Function,
	    print_html_row: Function,
	},
	  setup(__props) {




	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock("table", _hoisted_1$o, [
	    createBaseVNode("thead", null, [
	      createBaseVNode("tr", null, [
	        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columns, (col) => {
	          return (openBlock(), createElementBlock("th", {
	            scope: "col",
	            innerHTML: __props.print_html_column(col)
	          }, null, 8 /* PROPS */, _hoisted_2$n))
	        }), 256 /* UNKEYED_FRAGMENT */))
	      ])
	    ]),
	    createBaseVNode("tbody", null, [
	      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.rows, (row) => {
	        return (openBlock(), createElementBlock("tr", null, [
	          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columns, (col) => {
	            return (openBlock(), createElementBlock("td", {
	              scope: "col",
	              innerHTML: __props.print_html_row(col, row)
	            }, null, 8 /* PROPS */, _hoisted_3$m))
	          }), 256 /* UNKEYED_FRAGMENT */))
	        ]))
	      }), 256 /* UNKEYED_FRAGMENT */))
	    ])
	  ]))
	}
	}

	};

	script$r.__file = "http_src/vue/bootstrap-table.vue";

	/**
	    (C) 2022 - ntop.org
	*/

	function tsToApexOptions(tsOptions, metric) {
	    let startTime = tsOptions.start;
	    let step = tsOptions.step * 1000;
	    tsOptions.series.forEach((s) => {
		s.name = s.label;
		delete s.type;
		let time = startTime * 1000;
		s.data = s.data.map((d) => {
		    //let d2 = { x: time, y: d * 8 };
		    let d2 = { x: time, y: d };
		    time += step;
		    return d2;
		});
	    });
	    tsOptions.xaxis = {
		labels: {
		    show: true,
		},
		axisTicks: {
		    show: true,
		},
	    };
	    
	    tsOptions.yaxis = {
		//reversed: true,
		//seriesName: 
		labels: {
		    formatter: formatterUtils.getFormatter(metric.measure_unit),
		},
		axisBorder: {
	            show: true,
		},
		title: {
	            text: metric.measure_unit,
		},
	    };
	    //tsInterface.colors = ["#ff3231", "#ffc007"];
	}

	function getSerieId(serie) {
	    return `${serie.label}`;
	}

	function getYaxisName(measureUnit, scale) {
	    if (measureUnit == "number") {
		return scale;
	    }
	    return measureUnit;
	}

	function getSerieName(name, id, tsGroup, extendSeriesName) {
	    if (name == null) {
		name = id;
	    }
	    if (extendSeriesName == false) {
		return name;
	    }
	    let prefix = `${tsGroup.source.label}`;
	    let yaxisName = getYaxisName(tsGroup.metric.measure_unit, tsGroup.metric.scale);
	    return `${prefix} ${name} (${yaxisName})`;
	}

	function getAddSeriesNameSource(tsGrpupsArray) {
	    return tsGrpupsArray[0]?.source?.name != null;
	}

	function getYaxisId(metric) {
	    return `${metric.measure_unit}_${metric.scale}`;
	}

	function getSeriesInApexFormat(tsOptions, tsGroup, extendSeriesName, forceDrawType, tsCompare) {
	    // extract start time and step
	    let startTime = tsOptions.start * 1000;    let step = tsOptions.step * 1000;
	    let seriesApex = [];

	    let seriesKeys = Object.keys(tsGroup.metric.timeseries);
	    if (tsOptions.series?.length != seriesKeys.length) {	
		tsOptions.series = seriesKeys.map((sk, i) => {
		    let serie = tsOptions.series.find((s) => getSerieId(s) == sk);
		    if (serie != null) { return serie; }
		    return {
			label: sk,
			data: [null],
		    };
		});
	    }
	    tsOptions.series.forEach((s, i) => {
		// extract id
		let id = getSerieId(s);
		// find timeseries metadata
		let sMetadata = tsGroup.metric.timeseries[id];
		// extract data and check if we need invert direction
		let scalar = 1;
		if (sMetadata.invert_direction == true) {
		    scalar = -1;
		}
		let fMapData = (data) => {
		    let time = startTime;
		    let res = data.map((d) => {
			let d2 = { x: time, y: d * scalar };
			time += step;
			return d2;
		    });
		    return res;
		};
		
		// extract ts visibility (raw, avg, perc_95)
		let tsVisibility = tsGroup.timeseries?.find((t) => t.id == id);
		let sName = getSerieName(sMetadata.label, id, tsGroup, extendSeriesName);
		// check and add raw serie visibility
		if (tsVisibility == null || tsVisibility.raw == true) {
		    let data = fMapData(s.data);

		    let drawType = sMetadata.draw_type;
		    if (drawType == null && forceDrawType != null) { drawType = forceDrawType; }
		    else if (drawType == null) { drawType = "area"; }
		    
		    // create an apex chart serie
		    let sApex = {
			id,
			colorPalette: 0,
			color: sMetadata.color,
			type: drawType,
			name: sName,
			data,
		    };
		    seriesApex.push(sApex);
		}

		// check and add past serie visibility
		if (tsVisibility?.past == true
		    && ntopng_utility$1.is_object(tsOptions.additional_series)) {
		    let seriesData = ntopng_utility$1.object_to_array(tsOptions.additional_series)[0];
		    let sApex = {
			id,
			colorPalette: 1,
			color: sMetadata.color,
			type: "line",
			name: `${sName} ${tsCompare} Ago`,
			data: fMapData(seriesData),
		    };
		    seriesApex.push(sApex);
		}

		// define a function to build a constant serie
		let fBuildConstantSerie = (prefix, id, value) => {
		    if (value == null) { return null; }
		    let name = `${sName} (${prefix})`;
		    if (value != null) {
			value *= scalar;
		    }
		    let time = startTime;
		    let data = s.data.map((d) => {
			let d2 = { x: time, y: value };
			time += step;
			return d2;
		    });
		    return {
			id,
			name: name,
			colorPalette: 1,
			color: sMetadata.color,
			type: 'line',
			stacked: false,
			data,
		    };
		};
		// check and add avg serie visibility
		if (tsVisibility?.avg == true) {
		    let value = tsOptions.statistics?.by_serie[i].average;
		    // create an apex chart serie
		    let sApex = fBuildConstantSerie("Avg", id, value);
		    seriesApex.push(sApex);
		}
		// check and add 95thperc serie visibility
		if (tsVisibility?.perc_95 == true) {
		    let value = tsOptions.statistics?.by_serie[i]["95th_percentile"];
		    // create an apex chart serie
		    let sApex = fBuildConstantSerie("95th Perc", id, value);
		    seriesApex.push(sApex);
		}

	    });
	    return seriesApex;
	}

	const defaultColors = [ 
	    "#C6D9FD",
	    "#90EE90",
	    "#EE8434",
	    "#C95D63", 
	    "#AE8799", 
	    "#717EC3", 
	    "#496DDB", 
	    "#5A7ADE", 
	    "#6986E1", 
	    "#7791E4", 
	    "#839BE6",
	    "#8EA4E8", 
	];

	function setSeriesColors2(seriesArray) {
	    let count0 = 0, count1 = 0;
	    let colors0 = defaultColors;
	    let colors1 = d3v7.schemeCategory10;
	    seriesArray.forEach((s) => {
		if (s.colorPalette == 0) {
		    s.color = colors0[count0 % colors0.length];
		    count0 += 1;
		} else if (s.colorPalette == 1) {
		    s.color = colors1[count1 % colors1.length];
		    count1 += 1;
		}
	    });
	}

	function setMinMaxYaxis(yAxisArray, seriesArray) {
	    let yAxisArrayDict = {};
	    let minMaxDict = {};
	    for (let i = 0; i < seriesArray.length; i+= 1) {
		let s = seriesArray[i];
		let y = yAxisArray[i];
		let id = y.seriesName;
		if (yAxisArrayDict[id] == null) {
		    yAxisArrayDict[id] = [];
		    minMaxDict[id] = { min: Number.MAX_SAFE_INTEGER, max: Number.MIN_SAFE_INTEGER };
		}
		yAxisArrayDict[id].push(y);
		let minMax = minMaxDict[id];
		s.data.forEach((d) => {
		    minMax.max = Math.max(minMax.max, d.y);
		    minMax.min = Math.min(minMax.min, d.y);
		});	
	    }

	    let fAddOrSubtrac3Perc = (x, isAdd) => {
		if (x == 0 || x == null || x == Number.MAX_SAFE_INTEGER || x == Number.MIN_SAFE_INTEGER) {
		    return 0;
		}
		let onePerc = x / 100 * 3;
		if ((isAdd && x > 0) || (!isAdd && x < 0)) {
		    return x + onePerc;
		} else {
		    return x - onePerc;
		}
	    };
	    for (let sName in yAxisArrayDict) {
		let yArray = yAxisArrayDict[sName];
		let minMax = minMaxDict[sName];
		minMax.min = fAddOrSubtrac3Perc(minMax.min, false);
		minMax.max = fAddOrSubtrac3Perc(minMax.max, true);
		
		yArray.forEach((y) => {
		    y.min = minMax.min;
		    y.max = minMax.max;
		});
	    }
	}

	function getYaxisInApexFormat(seriesApex, tsGroup, yaxisDict) {
	    let metric = tsGroup.metric;
	    let yaxisId = getYaxisId(metric);
	    let invertDirection = false;
	    let countYaxisId = Object.keys(yaxisDict).length;

	    let yaxisApex = [];    

	    for (let mdKey in tsGroup.metric.timeseries) {
		invertDirection |= tsGroup.metric.timeseries[mdKey].invert_direction;
	    }

	    seriesApex.forEach((s) => {
		let yaxisSeriesName = yaxisDict[yaxisId];
		if (yaxisSeriesName == null) {
		    let yaxis = {
			seriesName: s.name,
			show: true,
			//forceNiceScale: true,
			labels: {
			    formatter: formatterUtils.getFormatter(metric.measure_unit, invertDirection),
			    // minWidth: 60,
			     // maxWidth: 75,
			    // offsetX: -20,
			},
			axisTicks: {
			    show: true
			},
			axisBorder: {
			    // offsetX: 60,
			    show: true,
			},
			title: {
			    text: getYaxisName(tsGroup.metric.measure_unit, tsGroup.metric.scale),
			},
			opposite: (countYaxisId % 2) == 1,
		    };
		    yaxisDict[yaxisId] = yaxis.seriesName;
		    yaxisApex.push(yaxis);
		} else {
		    yaxisApex.push({
			seriesName: yaxisSeriesName,
			labels: {
			    formatter: formatterUtils.getFormatter(metric.measure_unit, invertDirection),
			},
			show: false,
		    });
		}
	    });
	    return yaxisApex;
	}

	const groupsOptionsModesEnum = {
	  '1_chart': { value: "1_chart", label: i18n('page_stats.layout_1_per_all') },
	  '1_chart_x_yaxis': { value: "1_chart_x_yaxis", label: i18n('page_stats.layout_1_per_y') },
	  '1_chart_x_metric': { value: "1_chart_x_metric", label: i18n('page_stats.layout_1_per_1') },
	};

	function getGroupOptionMode(group_id) {
	  return groupsOptionsModesEnum[group_id] || null;
	}
	function tsArrayToApexOptionsArray(tsOptionsArray, tsGrpupsArray, groupsOptionsMode, tsCompare) {
	    if (groupsOptionsMode.value == groupsOptionsModesEnum["1_chart"].value) {	
		let apexOptions = tsArrayToApexOptions(tsOptionsArray, tsGrpupsArray, tsCompare);
		let apexOptionsArray = [apexOptions];
		setLeftPadding(apexOptionsArray);
		return apexOptionsArray;
	    } else if (groupsOptionsMode.value == groupsOptionsModesEnum["1_chart_x_yaxis"].value) {
		let tsDict = {};
		tsGrpupsArray.forEach((tsGroup, i) => {
		    let yaxisId = getYaxisId(tsGroup.metric);
		    let tsEl = {tsGroup, tsOptions: tsOptionsArray[i]};
		    if (tsDict[yaxisId] == null) {
			tsDict[yaxisId] = [tsEl];
		    } else {
			tsDict[yaxisId].push(tsEl);
		    }
		});	
		let apexOptionsArray = [];
		for (let key in tsDict) {
		    let tsArray = tsDict[key];
		    let tsOptionsArray2 = tsArray.map((ts) => ts.tsOptions);
		    let tsGrpupsArray2 = tsArray.map((ts) => ts.tsGroup);
		    let apexOptions = tsArrayToApexOptions(tsOptionsArray2, tsGrpupsArray2, tsCompare);
		    apexOptionsArray.push(apexOptions);
		}
		setLeftPadding(apexOptionsArray);
		return apexOptionsArray;
	    } else if (groupsOptionsMode.value == groupsOptionsModesEnum["1_chart_x_metric"].value) {
		let apexOptionsArray = [];
		tsOptionsArray.forEach((tsOptions, i) => {
		    let apexOptions = tsArrayToApexOptions([tsOptions], [tsGrpupsArray[i]], tsCompare);
		    apexOptionsArray.push(apexOptions);	    
		});
		setLeftPadding(apexOptionsArray);
		return apexOptionsArray;
	    }
	    return [];
	}

	function setLeftPadding(apexOptionsArray) {
	    // apexOptions.yaxis.filter((yaxis) => yaxis.show).forEach((yaxis) => yaxis
	    let oneChart = apexOptionsArray.length == 1;
	    apexOptionsArray.forEach((apexOptions) => {
		if (!oneChart) {
		    apexOptions.yaxis.filter((yaxis) => yaxis.show).forEach((yaxis) => {
			yaxis.labels.minWidth = 60;
		    });
		}
		if (apexOptions.yaxis.length < 2) {
		    return;
		}    
		apexOptions.yaxis.forEach((yaxis) => {
		    yaxis.labels.offsetX = -20;
		});
		apexOptions.grid.padding.left = -7;
	    });
	}

	function tsArrayToApexOptions(tsOptionsArray, tsGrpupsArray, tsCompare) {
	    if (tsOptionsArray.length != tsGrpupsArray.length) {
		console.error(`Error in timeseries-utils:tsArrayToApexOptions: tsOptionsArray ${tsOptionsArray} different length from tsGrpupsArray ${tsGrpupsArray}`);
		return;
	    }
	    let seriesArray = [];
	    let yaxisArray = [];
	    let yaxisDict = {};
	    getAddSeriesNameSource(tsGrpupsArray);
	    let forceDrawType = null;
	    tsOptionsArray.forEach((tsOptions, i) => {
		let tsGroup = tsGrpupsArray[i];

		if (i > 0) {
		    forceDrawType = "line";
		}
		// get seriesData
		let seriesApex = getSeriesInApexFormat(tsOptions, tsGroup, true, forceDrawType, tsCompare);
		seriesArray = seriesArray.concat(seriesApex);

		// get yaxis
		let yaxisApex = getYaxisInApexFormat(seriesApex, tsGroup, yaxisDict);
		yaxisArray = yaxisArray.concat(yaxisApex);
	    });

	    // set colors in series
	    setSeriesColors2(seriesArray);
	    setMinMaxYaxis(yaxisArray, seriesArray);
	    
	    let chartOptions = buildChartOptions(seriesArray, yaxisArray);    
	    return chartOptions;
	}

	function buildChartOptions(seriesArray, yaxisArray) {
	    return {
		chart: {
		    id: ntopng_utility$1.get_random_string(),
		    group: "timeseries",
		    // height: 300,
		},
		grid: {
		    padding: {
		    	// left: -8,
		    },
		},
		fill: {
		    opacity: 0.5,
		    type: 'solid',
		    pattern: {
			strokeWidth: 10,
		    },
		},
		// fill: {
		    
		// }
		stroke: {
		    show: true,
		    lineCap: 'butt',
		    width: 3,
		},
		legend: {
		    show: true,
		    showForSingleSeries: true,
		    position: "top",
		    horizontalAlign: "right",
		    onItemClick: {
			toggleDataSeries: false,
		    },
		},
		series: seriesArray,
		// colors: colorsInterpolation.transformColors(colors),
		yaxis: yaxisArray,
		xaxis: {
		    labels: {
			show: true,
		    },
		    axisTicks: {
			show: true,
		    },
		},
	    };
	}

	function getTsQuery(tsGroup) {
	    let tsQuery;
	    if (tsGroup.source_type.sub_value == null) {
		tsQuery = `${tsGroup.source_type.value}:${tsGroup.source.value}`;
	    } else {
		// let sub_value = ntopng_url_manager.get_url_entry(tsGroup.source_type.sub_value);
		let sub_value = tsGroup.source.sub_value;
	tsQuery = `${tsGroup.source_type.sub_value}:${sub_value},${(tsGroup.source_type.ts_query || tsGroup.source_type.value)}:${tsGroup.metric.ts_query || tsGroup.source.value}`;
	    }

	    if (tsGroup.metric.query != null) {
		tsQuery = `${tsQuery},${tsGroup.metric.query}`;
	    }
	    return tsQuery;
	}

	async function getTsChartsOptions(httpPrefix, epochStatus, tsCompare, timeseriesGroups, isPro) {
	    let paramsEpochObj = { epoch_begin: epochStatus.epoch_begin, epoch_end: epochStatus.epoch_end };

	    let tsChartsOptions;
	    if (!isPro) {
		let tsDataUrl = `${httpPrefix}/lua/rest/v2/get/timeseries/ts.lua`;
		let paramsUrlRequest = `ts_compare=${tsCompare}&version=4&zoom=${tsCompare}&initial_point=true&limit=180`;
		let tsGroup = timeseriesGroups[0];
		let tsQuery = getTsQuery(tsGroup);
		let pObj = {
		    ...paramsEpochObj,
		    ts_query: tsQuery,
		    tskey: tsGroup.source.value,
		    ts_schema: `${tsGroup.metric.schema}`,
		};
		let pUrlRequest =  ntopng_url_manager$1.add_obj_to_url(pObj, paramsUrlRequest);
		let url = `${tsDataUrl}?${pUrlRequest}`;
		let tsChartOption = await ntopng_utility$1.http_request(url);
		tsChartsOptions = [tsChartOption];
	    } else {
		let paramsChart = {
			zoom: tsCompare,
			initial_point: true,
			limit: 180,
			version: 4,
			ts_compare: tsCompare,
		};
		let tsRequests = timeseriesGroups.map((tsGroup) => {
		    let tsQuery = getTsQuery(tsGroup);
		    let pObj = {
			...paramsEpochObj,
			...paramsChart,
			ts_query: tsQuery,
			tskey: tsGroup.source.value,
			ts_schema: `${tsGroup.metric.schema}`,
		    };
		    return pObj;
		});
		let tsDataUrlMulti = `${httpPrefix}/lua/pro/rest/v2/get/timeseries/ts_multi.lua`;
		let req = { ts_requests: tsRequests };
		let headers = {
	            'Content-Type': 'application/json'
		};
		tsChartsOptions = await ntopng_utility$1.http_request(tsDataUrlMulti, { method: 'post', headers, body: JSON.stringify(req)});
	    }
	    return tsChartsOptions;
	}

	const timeseriesUtils = function() {
	    return {
		groupsOptionsModesEnum,
		tsToApexOptions,
		tsArrayToApexOptions,
		tsArrayToApexOptionsArray,
		getGroupOptionMode,
		getSerieId,
		getSerieName,
		getTsChartsOptions,
		getTsQuery,
	    };
	}();

	const _withScopeId$4 = n => (pushScopeId("data-v-937058e4"),n=n(),popScopeId(),n);
	const _hoisted_1$n = { class: "col-12 mb-2 mt-2" };
	const _hoisted_2$m = { class: "card h-100 overflow-hidden" };
	const _hoisted_3$l = ["title"];
	const _hoisted_4$l = /*#__PURE__*/ _withScopeId$4(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-camera-retro" }, null, -1 /* HOISTED */));
	const _hoisted_5$k = [
	  _hoisted_4$l
	];
	const _hoisted_6$k = ["title"];
	const _hoisted_7$j = /*#__PURE__*/ _withScopeId$4(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-download" }, null, -1 /* HOISTED */));
	const _hoisted_8$i = [
	  _hoisted_7$j
	];
	const _hoisted_9$g = { class: "form-group ms-1 me-1 mt-1" };
	const _hoisted_10$d = { class: "inline select2-size me-2 mt-2" };
	const _hoisted_11$d = { class: "inline select2-size me-2 mt-2" };
	const _hoisted_12$c = { class: "mt-4 card card-shadow" };
	const _hoisted_13$b = { class: "card-body" };
	const _hoisted_14$8 = {
	  key: 0,
	  class: "mt-4 card card-shadow"
	};
	const _hoisted_15$7 = { class: "card-body" };
	const _hoisted_16$6 = {
	  class: "mb-4 text-nowrap",
	  style: {"font-size":"1.1rem"}
	};
	const _hoisted_17$6 = /*#__PURE__*/ _withScopeId$4(() => /*#__PURE__*/createBaseVNode("i", { class: "fa-solid fa-chart-line" }, null, -1 /* HOISTED */));


	var script$q = {
	  __name: 'page-stats',
	  props: {
	    csrf: String,
	    is_ntop_pro: Boolean,
	    source_value: String,
	    source_sub_value: String,
	    enable_snapshots: Boolean,
	    is_history_enabled: Boolean,
	    traffic_extraction_permitted: Boolean,
	},
	  setup(__props) {

	const props = __props;



	ntopng_utility$1.check_and_set_default_interval_time();

	const _i18n = (t) => i18n(t);

	let id_chart = "chart";
	let id_date_time_picker = "date_time_picker";
	let chart_type = ntopChartApex.typeChart.TS_LINE;
	const config_app_table = ref({});
	const init_config_table = ref(false);
	const charts = ref([]);
	const date_time_picker = ref(null);
	const top_applications_table = ref(null);
	const modal_timeseries = ref(null);
	const modal_snapshot = ref(null);

	const metrics = ref([]);
	const selected_metric = ref({});

	const enable_table = function() {
	    let source_type = metricsManager.get_current_page_source_type();    
	    return source_type.table_value != null;
	}();

	/**
	 * { key: identifier of Chart component, if change Chart will be destroyed and recreated,
	 *  chart_options: chart options }[]
	 **/
	const charts_options_items = ref([]);

	/**
	 * Modes that represent how it's possible display timeseries.
	 */
	const groups_options_modes = ntopng_utility$1.object_to_array(timeseriesUtils.groupsOptionsModesEnum);
	/**
	 * Current display timeseries mode.
	 */
	const current_groups_options_mode = ref(init_groups_option_mode());

	let last_timeseries_groups_loaded = null;

	const custom_metric = { label: i18n('page_stats.custom_metrics'), currently_active: false };

	const page_snapshots = "timeseries";

	const ts_menu_ready = ref(false);

	function init_groups_option_mode() {
	    let groups_mode = ntopng_url_manager$1.get_url_entry("timeseries_groups_mode");
	    if (groups_mode != null && groups_mode != "") {
		return timeseriesUtils.getGroupOptionMode(groups_mode);
	    }
	    return groups_options_modes[0];
	}

	function set_default_source_in_url() {
	    let source_type = metricsManager.get_current_page_source_type();
	    if (props.source_value != null && props.source_value != "") {
		let value_url = metricsManager.get_source_type_key_value_url(source_type);
		ntopng_url_manager$1.set_key_to_url(value_url, props.source_value);
	    }
	    if (source_type.sub_value && props.source_sub_value != null && props.source_sub_value != "") {
		let sub_value_url = metricsManager.get_source_type_key_sub_value_url(source_type);
		ntopng_url_manager$1.set_key_to_url(sub_value_url, props.source_sub_value);
	    }
	}

	onBeforeMount(async () => {
	    set_default_source_in_url();
	    await load_datatable_data();
	});

	onMounted(async () => {
	    init();
	    await Promise.all([
		ntopng_sync.on_ready(id_date_time_picker),
	    ]);
	    // chart.value.register_status();
	});

	async function init() {
	    //get_default_timeseries_groups
	    let push_custom_metric = true;
	    let timeseries_groups = await metricsManager.get_timeseries_groups_from_url(http_prefix);
	    let metric_ts_schema;
	    if (timeseries_groups == null) {
		push_custom_metric = false;
		metric_ts_schema = ntopng_url_manager$1.get_url_entry("ts_schema");
		if (metric_ts_schema == "") { metric_ts_schema = null; }
		timeseries_groups = await metricsManager.get_default_timeseries_groups(http_prefix, metric_ts_schema);
	    }
	    metrics.value = await get_metrics(push_custom_metric);
	    
	    if (push_custom_metric == true) {
		selected_metric.value = custom_metric;
	    } else {
		selected_metric.value = metricsManager.get_default_metric(metrics.value, metric_ts_schema);
	    }
	    ts_menu_ready.value = true;
	    await load_charts_data(timeseries_groups);
	}

	let last_push_custom_metric = null;
	async function get_metrics(push_custom_metric, force_refresh) {
	    if (!force_refresh && last_push_custom_metric == push_custom_metric) { return metrics.value; }
	    
	    let metrics = await metricsManager.get_metrics(http_prefix);
	    if (push_custom_metric) {
		metrics.push(custom_metric);
	    }
	    if (cache_snapshots == null || force_refresh) {
		cache_snapshots = await get_snapshots_metrics();
	    }
	    if(props.enable_snapshots) {
	      let snapshots_metrics = cache_snapshots;
	      snapshots_metrics.forEach((sm) => metrics.push(sm));
	    }
	    /* Order Metrics */
	    metrics.sort(NtopUtils$1.sortAlphabetically);
	    
	    return metrics;
	}

	async function get_snapshots_metrics() {
	    if (!props.enable_snapshots) { return; }
	    let url = `${http_prefix}/lua/pro/rest/v2/get/filters/snapshots.lua?page=${page_snapshots}`;
	    
	    let snapshots_obj = await ntopng_utility$1.http_request(url);
	    let snapshots = ntopng_utility$1.object_to_array(snapshots_obj);
	    let metrics_snapshots = snapshots.map((s) => {
		return {
	            ...s,
	            is_snapshot: true,
	            label: `${s.name}`,
		    group: "Snapshots",
		};
	    });
	    console.log(snapshots);
	    return metrics_snapshots;
	}

	async function get_selected_timeseries_groups() {
	    let metric = selected_metric.value;
	    return get_timeseries_groups_from_metric(metric);
	}

	async function get_timeseries_groups_from_metric(metric) {
	    let source_type = metricsManager.get_current_page_source_type();
	    let source = await metricsManager.get_default_source(http_prefix, source_type);
	    let ts_group = metricsManager.get_ts_group(source_type, source, metric);
	    let timeseries_groups = [ts_group];
	    return timeseries_groups;
	}

	async function add_metric_from_metric_schema(metric_schema, metric_query) {
	    let metric = metrics.value.find((m) => m.schema == metric_schema && m.query == metric_query);
	    if (metric == null) {
		console.error(`metric = ${metric_schema}, query = ${metric_query} not found.`);
		return;
	    }
	    let timeseries_groups = await get_timeseries_groups_from_metric(metric);
	    modal_timeseries.value.set_timeseries_groups(last_timeseries_groups_loaded);
	    modal_timeseries.value.add_ts_group(timeseries_groups[0], true);
	}

	async function select_metric(metric) {
	    if (metric.is_snapshot == true) {
		let url_parameters = metric.filters;
		let timeseries_url_params = ntopng_url_manager$1.get_url_entry("timeseries_groups", url_parameters);
		let timeseries_groups = await metricsManager.get_timeseries_groups_from_url(http_prefix, timeseries_url_params);
		current_groups_options_mode.value = timeseriesUtils.getGroupOptionMode(ntopng_url_manager$1.get_url_entry("timeseries_groups_mode", url_parameters));
		await load_charts_data(timeseries_groups);
	    } else {
		await load_charts_selected_metric();
		refresh_metrics(false);
	    }
	}

	async function load_charts_selected_metric() {
	    let timeseries_groups = await get_selected_timeseries_groups();
	    await load_charts_data(timeseries_groups);
	}

	function epoch_change(new_epoch) {    
	    console.log(new_epoch);
	    let push_custom_metric = selected_metric.value.label == custom_metric.label;
	    load_charts_data(last_timeseries_groups_loaded);    
	    reload_table_data();
	    refresh_metrics(push_custom_metric, true);
	}

	function chart_reloaded(chart_options) {
	    console.log("chart reloaded");
	}

	function show_modal_snapshot() {
	    modal_snapshot.value.show();
	}

	function show_manage_timeseries() {
	    if (last_timeseries_groups_loaded == null) { return; }
	    modal_timeseries.value.show(last_timeseries_groups_loaded);
	}
	/**
	 * Function called by Chart component to draw or update that return chart options.
	 **/
	function get_f_get_custom_chart_options(chart_index) {
	    console.log("get_f_");
	    return async (url) => {
		console.log("get_charts_options");	
		return charts_options_items.value[chart_index].chart_options;
	    }
	}

	let cache_snapshots = null;
	function refresh_snapshots() {
	    let push_custom_metric = selected_metric.value.label == custom_metric.label;
	    refresh_metrics(push_custom_metric, true);
	}

	async function refresh_metrics(push_custom_metric, force_refresh) {
	    metrics.value = await get_metrics(push_custom_metric, force_refresh);
	    if (push_custom_metric) {
		selected_metric.value = custom_metric;
	    }
	}

	async function apply_modal_timeseries(timeseries_groups) {
	    console.log("apply modal-timeseries in page-stats");
	    refresh_metrics(true);
	    await load_charts_data(timeseries_groups);
	}

	function change_groups_options_mode() {    
	    load_charts_data(last_timeseries_groups_loaded, true);
	}

	let ts_charts_options;
	async function load_charts_data(timeseries_groups, not_reload) {
	    let status = ntopng_status_manager$1.get_status();
	    let ts_compare = get_ts_compare(status);
	    if (!not_reload) {
		ts_charts_options = await timeseriesUtils.getTsChartsOptions(http_prefix, status, ts_compare, timeseries_groups, props.is_ntop_pro);
	    }
	    console.log(ts_charts_options);
	    console.log(timeseries_groups);

	    // update timeseries_groups source label
	    set_timeseries_groups_source_label(timeseries_groups, ts_charts_options);
	    
	    let charts_options = timeseriesUtils.tsArrayToApexOptionsArray(ts_charts_options, timeseries_groups, current_groups_options_mode.value, ts_compare);

	    set_charts_options_items(charts_options);
	    set_stats_rows(ts_charts_options, timeseries_groups, status);
	    
	    // set last_timeseries_groupd_loaded
	    last_timeseries_groups_loaded = timeseries_groups;
	    console.log("SET last_timeseries_groups_loaded");
	    console.log(last_timeseries_groups_loaded);
	    // update url params
	    update_url_params();
	}

	function set_timeseries_groups_source_label(timeseries_groups, ts_charts_options) {    
	    timeseries_groups.forEach((ts_group, i) => {
		let ts_options = ts_charts_options[i];
		let label = ts_options?.query?.label;
		if (label != null) {
		    ts_group.source.label = label;
		}
	    });
	}

	function update_url_params() {
	    ntopng_url_manager$1.set_key_to_url("timeseries_groups_mode", current_groups_options_mode.value.value);
	    metricsManager.set_timeseries_groups_in_url(last_timeseries_groups_loaded);
	}

	function set_charts_options_items(charts_options) {
	    charts_options_items.value = charts_options.map((options, i) => {
		return {
		    key: ntopng_utility$1.get_random_string(),
		    chart_options: options,
		};
	    });
	}

	function get_ts_compare(status) {
	    // 5m, 30m, 1h, 1d, 1w, 1M, 1Y
	    let r = Number.parseInt((status.epoch_end - status.epoch_begin) / 60);
	    if (r <= 5) {
		return "5m";
	    } else if (r <= 30) {
		return "30m";
	    } else if (r <= 60) {
		return "1h";
	    } else if (r <= 60 * 24) {
		return "1d";
	    } else if (r <= 60 * 24 * 7) {
		return "1w";
	    } else if (r <= 60 * 24 * 30) {
		return "1M";
	    } else {
		return "1Y";
	    }
	}

	async function get_datatable_url() {
	    let source_type = metricsManager.get_current_page_source_type();
	    let source = await metricsManager.get_default_source(http_prefix, source_type);
	    let ts_group = {
		source_type,
		source,
		metric: {},
	    };
	    if (source_type.sub_value) {
		let sub_source = await metricsManager.get_default_sub_source(http_prefix, source_type.sub_value);
		ts_group.sub_source = sub_source;
	    }
	    let ts_query = timeseriesUtils.getTsQuery(ts_group);
	    let v = source_type.table_value;    
	    let data_url = `${http_prefix}/lua/pro/rest/v2/get/${v}/top/ts_stats.lua`;
	    //todo: get ts_query
	    let p_obj = {
		zoom: '5m',
		ts_query,
		// ts_query: `ifid:${ntopng_url_manager.get_url_entry('ifid')}`,
		epoch_begin: `${ntopng_url_manager$1.get_url_entry('epoch_begin')}`,
		epoch_end: `${ntopng_url_manager$1.get_url_entry('epoch_end')}`,
		detail_view: `top_protocols`,
		new_charts: `true`
	    };
	    
	    let p_url_request =  ntopng_url_manager$1.add_obj_to_url(p_obj, '');
	    return `${data_url}?${p_url_request}`;
	}

	async function reload_table_data() {
	    // NtopUtils.showOverlays();
	    if (enable_table == false || !props.is_ntop_pro) { return; }
	    const url = await get_datatable_url();
	    top_applications_table.value.update_url(url);
	    top_applications_table.value.reload();
	    // NtopUtils.hideOverlays();
	}

	async function load_datatable_data() {
	    if (enable_table == false || !props.is_ntop_pro) { return; } 
	    const url = await get_datatable_url();
	    set_table_configuration(url);
	}
	function set_table_configuration(url) {
	    const default_sorting_columns = 2; /* Percentage column */
	    let columns = [
		{ columnName: i18n("application"), name: 'application', data: 'protocol', className: 'text-nowrap', responsivePriority: 1, handlerId: "page-stats-action-link-application", render: (data, type, service) => {
		    let handler = {
			handlerId: "page-stats-action-link-application",
			onClick: () => {
			    console.log(data);
			    console.log(service);
			    let schema = `top:${service.ts_schema}`;
			    add_metric_from_metric_schema(schema, service.ts_query);
			},
		    };
		    return DataTableUtils$1.createLinkCallback({ text: data.label, handler });
		},},
		{ columnName: i18n("traffic"), name: 'traffic', data: 'traffic', orderable: false, className: 'text-nowrap', responsivePriority: 1,
		  render: (data) => {
		      return NtopUtils$1.bytesToSize(data)
		  }, 
		},
		{ columnName: i18n("percentage"), name: 'traffic_perc', data: 'percentage', className: 'text-nowrap', responsivePriority: 1,
		  render: (data) => {
		      const percentage = data.toFixed(1);
		      return NtopUtils$1.createProgressBar(percentage)
		  } 
		}
	    ];  
	    
	    /* If history is enabled, then add an href to Historical Flows */
	    if(props.is_history_enabled) {
		let handlerIdJumpHistorical = "page-stats-action-jump-historical";
		columns.push({
		    columnName: i18n("actions"),
		    width: '5%',
		    name: 'actions',
		    className: 'text-center',
		    orderable: false,
		    responsivePriority: 0,
		    handlerId: handlerIdJumpHistorical,
		    render: (data, type, service) => {
			const jump_to_historical = {
			    handlerId: handlerIdJumpHistorical,
			    onClick: () => {
				let l7_proto = ntopng_url_manager$1.serialize_param("l7proto", `${service.protocol.id};eq`);
				let historical_flows_url = `${http_prefix}/lua/pro/db_search.lua?epoch_begin=${ntopng_url_manager$1.get_url_entry('epoch_begin')}&epoch_end=${ntopng_url_manager$1.get_url_entry('epoch_end')}&${l7_proto}`;
				let source_type = metricsManager.get_current_page_source_type();
				let params = "";
				if(source_type.value == "host") {
				    let ifid = `ifid=${ntopng_url_manager$1.get_url_entry('ifid')}`;
				    let host = ntopng_url_manager$1.serialize_param("ip", `${host};eq`);
				    params = `${ifid}&${host}`;
				} else if (source_type.value == "ifid"){
				    let ifid = `ifid=${ntopng_url_manager$1.get_url_entry('ifid')}`;
				    params = ifid;
				} else {
				    throw "page-stats:set_table_configuration source_type not managed";
				}
				historical_flows_url = `${historical_flows_url}&${params}`;
				console.log(historical_flows_url);
				window.open(historical_flows_url);
			    }
			};
			return DataTableUtils$1.createActionButtons([
			    { class: 'dropdown-item', href: '#', title: i18n('db_explorer.historical_data'), handler: jump_to_historical },
			]);
		    }
		});
	    }
	    
	    const datatable_config = {
		table_buttons: [ ],
		columns_config: columns,
		data_url: url,
		enable_search: true,
		table_config: { serverSide: false, order: [[ default_sorting_columns, 'desc' ]] }
	    };
	    init_config_table.value = true;
	    config_app_table.value = datatable_config;
	}

	let stats_columns = [
	    { id: "metric", label: _i18n("page_stats.metric") },
	    { id: "avg", label: _i18n("page_stats.average") },
	    { id: "perc_95", label: _i18n("page_stats.95_perc") },
	    { id: "max", label: _i18n("page_stats.max") },
	    { id: "min", label: _i18n("page_stats.min") },
	    { id: "total", label: _i18n("page_stats.total") },
	];

	const stats_rows = ref([]);

	function set_stats_rows(ts_charts_options, timeseries_groups, status) {
	    let extend_serie_name = true;
	    const f_get_total_formatter_type = (type) => {
		if (type == "bps") { return "bytes_network"; }
		return type;
	    };    
	    stats_rows.value = [];
	    ts_charts_options.forEach((options, i) => {
		let ts_group = timeseries_groups[i];
		options.series.forEach((s, j) => {
		    let ts_id = timeseriesUtils.getSerieId(s);
		    let s_metadata = ts_group.metric.timeseries[ts_id];
		    let formatter = formatterUtils.getFormatter(ts_group.metric.measure_unit);
		    let ts_stats = options.statistics?.by_serie[j];
		    if (ts_stats == null) {
			return;
		    }
		    let name = timeseriesUtils.getSerieName(s_metadata.label, ts_id, ts_group, extend_serie_name);
		    let total = null;
		    let total_formatter_type = f_get_total_formatter_type(ts_group.metric.measure_unit);
		    let total_formatter = formatterUtils.getFormatter(total_formatter_type);
		    if (ts_stats.total != null) {
			let interval = status.epoch_end - status.epoch_begin;
			total = interval * ts_stats.average;
		    }
		    
		    let row = {
			metric: name,
			total: total_formatter(total),
			perc_95: formatter(ts_stats["95th_percentile"]),
			avg: formatter(ts_stats.average),
			max: formatter(ts_stats.max_val),
			min: formatter(ts_stats.min_val),
		    };
		    stats_rows.value.push(row);
		});
	    });
	}

	function print_stats_column(col) {
	    return col.label;
	}

	function print_stats_row(col, row) {
	    let label = row[col.id];
	    return label;
	}

	const modal_traffic_extraction = ref(null);
	function show_modal_traffic_extraction() {
	    modal_traffic_extraction.value.show();
	}


	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock(Fragment, null, [
	    createBaseVNode("div", _hoisted_1$n, [
	      createVNode(script$t),
	      createBaseVNode("div", _hoisted_2$m, [
	        createVNode(script$z, {
	          style: {"margin-top":"0.5rem"},
	          id: unref(id_date_time_picker),
	          enable_refresh: true,
	          ref_key: "date_time_picker",
	          ref: date_time_picker,
	          onEpoch_change: epoch_change
	        }, {
	          begin: withCtx(() => []),
	          extra_buttons: withCtx(() => [
	            (__props.enable_snapshots)
	              ? (openBlock(), createElementBlock("button", {
	                  key: 0,
	                  class: "btn btn-link btn-sm",
	                  onClick: show_modal_snapshot,
	                  title: _i18n('page_stats.manage_snapshots_btn')
	                }, _hoisted_5$k, 8 /* PROPS */, _hoisted_3$l))
	              : createCommentVNode("v-if", true),
	            (__props.traffic_extraction_permitted)
	              ? (openBlock(), createElementBlock("button", {
	                  key: 1,
	                  class: "btn btn-link btn-sm",
	                  onClick: show_modal_traffic_extraction,
	                  title: _i18n('traffic_recording.pcap_download')
	                }, _hoisted_8$i, 8 /* PROPS */, _hoisted_6$k))
	              : createCommentVNode("v-if", true)
	          ]),
	          _: 1 /* STABLE */
	        }, 8 /* PROPS */, ["id"]),
	        createCommentVNode(" select metric "),
	        withDirectives(createBaseVNode("div", _hoisted_9$g, [
	          createBaseVNode("div", _hoisted_10$d, [
	            createVNode(script$A, {
	              selected_option: selected_metric.value,
	              "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_metric).value = $event)),
	              options: metrics.value,
	              onSelect_option: select_metric
	            }, null, 8 /* PROPS */, ["selected_option", "options"])
	          ]),
	          createBaseVNode("div", _hoisted_11$d, [
	            createVNode(script$A, {
	              selected_option: current_groups_options_mode.value,
	              "onUpdate:selected_option": _cache[1] || (_cache[1] = $event => ((current_groups_options_mode).value = $event)),
	              options: unref(groups_options_modes),
	              onSelect_option: change_groups_options_mode
	            }, null, 8 /* PROPS */, ["selected_option", "options"])
	          ]),
	          (__props.is_ntop_pro)
	            ? (openBlock(), createElementBlock("button", {
	                key: 0,
	                type: "button",
	                onClick: show_manage_timeseries,
	                class: "btn btn-sm btn-primary inline",
	                style: {"vertical-align":"super"}
	              }, " Manage Timeseries "))
	            : createCommentVNode("v-if", true)
	        ], 512 /* NEED_PATCH */), [
	          [vShow, ts_menu_ready.value]
	        ]),
	        (openBlock(true), createElementBlock(Fragment, null, renderList(charts_options_items.value, (item, i) => {
	          return (openBlock(), createElementBlock("div", {
	            key: item.key,
	            class: "m-3",
	            style: {"height":"300px"}
	          }, [
	            createVNode(script$B, {
	              id: unref(id_chart) + i,
	              ref_for: true,
	              ref: el => { charts.value[i] = el; },
	              chart_type: unref(chart_type),
	              register_on_status_change: false,
	              get_custom_chart_options: get_f_get_custom_chart_options(i),
	              onZoom: epoch_change,
	              onChart_reloaded: chart_reloaded
	            }, null, 8 /* PROPS */, ["id", "chart_type", "get_custom_chart_options"])
	          ]))
	        }), 128 /* KEYED_FRAGMENT */))
	      ]),
	      createBaseVNode("div", _hoisted_12$c, [
	        createBaseVNode("div", _hoisted_13$b, [
	          createVNode(script$r, {
	            id: "page_stats_bootstrap_table",
	            columns: unref(stats_columns),
	            rows: stats_rows.value,
	            print_html_column: (col) => print_stats_column(col),
	            print_html_row: (col, row) => print_stats_row(col, row)
	          }, null, 8 /* PROPS */, ["columns", "rows", "print_html_column", "print_html_row"])
	        ])
	      ]),
	      (unref(enable_table) == true && __props.is_ntop_pro)
	        ? (openBlock(), createElementBlock("div", _hoisted_14$8, [
	            createBaseVNode("div", _hoisted_15$7, [
	              createBaseVNode("div", _hoisted_16$6, [
	                _hoisted_17$6,
	                createTextVNode(" " + toDisplayString(_i18n('page_stats.top_applications')), 1 /* TEXT */)
	              ]),
	              (init_config_table.value)
	                ? (openBlock(), createBlock(script$s, {
	                    key: 0,
	                    ref_key: "top_applications_table",
	                    ref: top_applications_table,
	                    table_buttons: config_app_table.value.table_buttons,
	                    columns_config: config_app_table.value.columns_config,
	                    data_url: config_app_table.value.data_url,
	                    enable_search: config_app_table.value.enable_search,
	                    table_config: config_app_table.value.table_config
	                  }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"]))
	                : createCommentVNode("v-if", true)
	            ])
	          ]))
	        : createCommentVNode("v-if", true)
	    ]),
	    (__props.enable_snapshots)
	      ? (openBlock(), createBlock(script$x, {
	          key: 0,
	          ref_key: "modal_snapshot",
	          ref: modal_snapshot,
	          csrf: __props.csrf,
	          page: page_snapshots,
	          onAdded_snapshot: refresh_snapshots,
	          onDeleted_snapshots: refresh_snapshots,
	          onDeleted_all_snapshots: refresh_snapshots
	        }, null, 8 /* PROPS */, ["csrf"]))
	      : createCommentVNode("v-if", true),
	    (__props.is_ntop_pro)
	      ? (openBlock(), createBlock(script$v, {
	          key: 1,
	          ref_key: "modal_timeseries",
	          ref: modal_timeseries,
	          onApply: apply_modal_timeseries
	        }, null, 512 /* NEED_PATCH */))
	      : createCommentVNode("v-if", true),
	    createVNode(script$u, {
	      id: "page_stats_modal_traffic_extraction",
	      ref_key: "modal_traffic_extraction",
	      ref: modal_traffic_extraction
	    }, null, 512 /* NEED_PATCH */)
	  ], 64 /* STABLE_FRAGMENT */))
	}
	}

	};

	var css_248z$5 = "\n.inline[data-v-937058e4] {\n    display: inline-block;\n}\n.select2-size[data-v-937058e4] {\n    min-width: 18rem;\n}\n";
	styleInject(css_248z$5);

	script$q.__scopeId = "data-v-937058e4";
	script$q.__file = "http_src/vue/page-stats.vue";

	var script$p = defineComponent({
	  components: {
	  },
	  props: {
	    id: String,
	    tab_list: Array,
	  },
	  emits: ["click_item"],
	  /** This method is the first method of the component called, it's called before html template creation. */
	  created() {
	  },
	  data() {
	    return {
	      old_tab: null
	    };
	  },
	  /** This method is the first method called after html template creation. */
	  mounted() {
	    let tmp;
	    this.tab_list.forEach(function(tab) {
	      if(tab.active) {
	        tmp = tab;
	      }
	    });

	    if(tmp == undefined)
	      tmp = this.tab_list[0];

	    this.old_tab = tmp.id || tmp.name;
	    ntopng_sync.ready(this.$props["id"]);
	  },
	  methods: {
	    change_tab: function(tab) {
	      if((!tab.id || this.old_tab != tab.id) &&
	         (!tab.name || this.old_tab != tab.name)) {
	        this.old_tab = tab.id || tab.name;
	        this.$emit('click_item', tab);
	      }
	    }
	  },
	});

	const _hoisted_1$m = { class: "card-header mb-2" };
	const _hoisted_2$l = {
	  class: "nav nav-tabs card-header-tabs",
	  role: "tablist"
	};
	const _hoisted_3$k = ["onClick"];
	const _hoisted_4$k = ["onClick"];

	function render$f(_ctx, _cache, $props, $setup, $data, $options) {
	  return (openBlock(), createElementBlock("div", _hoisted_1$m, [
	    createBaseVNode("ul", _hoisted_2$l, [
	      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.tab_list, (tab) => {
	        return (openBlock(), createElementBlock(Fragment, null, [
	          (tab.active)
	            ? (openBlock(), createElementBlock("li", {
	                key: 0,
	                onClick: $event => (_ctx.change_tab(tab)),
	                class: normalizeClass([{ 'active': tab.active }, "nav-item nav-link"])
	              }, toDisplayString(tab.title), 11 /* TEXT, CLASS, PROPS */, _hoisted_3$k))
	            : (openBlock(), createElementBlock("a", {
	                key: 1,
	                onClick: $event => (_ctx.change_tab(tab)),
	                href: "#",
	                class: "nav-item nav-link"
	              }, toDisplayString(tab.title), 9 /* TEXT, PROPS */, _hoisted_4$k))
	        ], 64 /* STABLE_FRAGMENT */))
	      }), 256 /* UNKEYED_FRAGMENT */))
	    ])
	  ]))
	}

	script$p.render = render$f;
	script$p.__file = "http_src/vue/tab-list.vue";

	var script$o = {
	  __name: 'modal-delete-confirm',
	  props: {
	    body: String,
	    title: String,
	},
	  emits: ['delete'],
	  setup(__props, { expose, emit }) {

	const modal_id = ref(null);


	const showed = () => {};



	const show = () => {
	    modal_id.value.show();
	};

	const delete_ = () => {
	    emit('delete');
	    close();
	};

	const close = () => {
	    modal_id.value.close();
	};


	expose({ show, close });

	onMounted(() => {
	});

	const _i18n = (t) => i18n(t);


	return (_ctx, _cache) => {
	  return (openBlock(), createBlock(script$y, {
	    onShowed: _cache[0] || (_cache[0] = $event => (showed())),
	    ref_key: "modal_id",
	    ref: modal_id
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
	    ]),
	    body: withCtx(() => [
	      createTextVNode(toDisplayString(__props.body), 1 /* TEXT */)
	    ]),
	    footer: withCtx(() => [
	      createBaseVNode("button", {
	        type: "button",
	        onClick: delete_,
	        class: "btn btn-danger"
	      }, toDisplayString(_i18n('delete')), 1 /* TEXT */)
	    ]),
	    _: 1 /* STABLE */
	  }, 512 /* NEED_PATCH */))
	}
	}

	};

	script$o.__file = "http_src/vue/modal-delete-confirm.vue";

	const change_asset_table_tab_event = "change_asset_table_tab_event";

	var script$n = {
	  components: {	  
	    'datatable': script$s,
	    'modal-delete-confirm': script$o,
	    'tab-list': script$p,
	  },
	  props: {
	    page_csrf: String,
	    url_params: Object,
	    view: String,
	    table_filters: Array,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    ntopng_url_manager$1.set_key_to_url('asset_family', this.$props.url_params.asset_family);
	    start_datatable$6(this);
	  },
	  mounted() {
	    this.asset_table_tab = ntopng_url_manager$1.get_url_entry("view") || 'standard';
	    this.tab_list.forEach((i) => {
	      this.asset_table_tab == i.id ? i.active = true : i.active = false;
	    });
	    ntopng_events_manager$1.on_custom_event("page_asset_table", ntopng_custom_events.DATATABLE_LOADED, () => {
	      if(ntopng_url_manager$1.get_url_entry('host'))
	        this.hide_dropdowns();
	    });
	    ntopng_events_manager$1.on_custom_event("change_asset_table_tab", change_asset_table_tab_event, (tab) => {
		    let table = this.get_active_table();
	      ntopng_url_manager$1.set_key_to_url('view', tab);
	      table.destroy_table();
	      this.asset_table_tab = tab;
	    });

	    $("#btn-delete-all").click(() => this.show_delete_all_dialog());
	  },    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      config_devices_standard: null,
	      config_devices_centrality: null,
	      title_delete: i18n('map_page.delete_assets'),
	      body_delete: i18n('map_page.delete_assets_message'),
	      title_download: i18n('map_page.download'),
	      body_download: i18n('map_page.download_message'),
	      get_url: null,
	      asset_table_tab: null,
	      tab_list: [
	        { 
	          title: i18n('map_page.standard_view'),
	          active: (view == 'standard'),
	          id: 'standard'
	        },
	        { 
	          title: i18n('map_page.centrality_view'),
	          active: (view == 'centrality'),
	          id: 'centrality'
	        },
	      ]
	    };
	  },
	  methods: {
	    destroy: function() {
	      let table = this.get_active_table();
	      table.destroy_table();
	    },
	    /* Method used to switch active table tab */
	    click_item: function(item) {
	      this.tab_list.forEach((i) => i.active = false);
	      item.active = true;
	      ntopng_events_manager$1.emit_custom_event(change_asset_table_tab_event, item.id);
	    },
	    delete_all: async function() {
	      let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
	      let params = {
	        ifid: this.url_params.ifid,
	        action: 'reset',
	        page: this.url_params.page,
	        csrf: this.$props.page_csrf,
	        map: this.url_params.map
	      };
	      try {
	        let headers = {
	          'Content-Type': 'application/json'
	        };
	        await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	        this.reload_table();
	      } catch(err) {
	        this.reload_table();  
	      }      
	    },
	    hide_dropdowns: function() {      
	      $(`#network_dropdown`).removeClass('d-inline');
	      $(`#vlan_id_dropdown`).removeClass('d-inline');
	      $(`#network_dropdown`).attr('hidden', 'hidden');
	      $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
	    }, 
	    reload_table: function() {
	      let table = this.get_active_table();
	      NtopUtils.showOverlays();
	      table.reload();
	      NtopUtils.hideOverlays();
	    },
	    get_active_table: function() {
	      return this.$refs[`table_asset_${this.asset_table_tab}`];
	    },
	    show_delete_all_dialog: function() {
	      this.$refs["modal_delete_all"].show();
	    },
	  },
	};  

	function start_datatable$6(DatatableVue) {
	  const datatableButton = [];
	  let columns = [];
	  
	  DatatableVue.get_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, url_params);
	  
	  /* Manage the buttons close to the search box */
	  datatableButton.push({
	    text: '<i class="fas fa-sync"></i>',
	    className: 'btn-link',
	    action: function (e, dt, node, config) {
	      DatatableVue.reload_table();
	    }
	  });
	  
	  let tmp_params = url_params;
	  tmp_params['view'] = 'standard';
	  
	  let defaultDatatableConfig = {
	    table_buttons: datatableButton,
	    columns_config: [],
	    data_url: NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params),
	    enable_search: true,
	  };

	  let table_filters = [];
	  for (let filter of (DatatableVue.$props.table_filters || [])) {
	    filter.callbackFunction = (table, value) => {
	      tmp_params['view'] = DatatableVue.asset_table_tab;
	      tmp_params[filter.filterMenuKey] = value.id;
	      ntopng_url_manager$1.set_key_to_url(filter.filterMenuKey, value.id);
	      table.ajax.url(NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params));
	      NtopUtils.showOverlays();
	      table.ajax.reload();
	      NtopUtils.hideOverlays();
	    },
	    table_filters.push(filter);
	  }
	  
	  /* Standard table configuration */  

	  columns = [
	    { columnName: i18n("map_page.client"), name: 'client', data: 'client', className: 'text-nowrap', responsivePriority: 1 },
	    { columnName: i18n("map_page.server"), name: 'server', data: 'server', className: 'text-nowrap', responsivePriority: 1 },
	    { columnName: i18n("map_page.asset_family"), name: 'family', data: 'family', className: 'text-nowrap', responsivePriority: 2 },
	    { columnName: i18n("map_page.last_seen"), name: 'last_seen', data: 'last_seen',  className: 'text-center', responsivePriority: 2 },
	  ];
	  
	  let configDevices = ntopng_utility.clone(defaultDatatableConfig);
	  configDevices.table_config = { serverSide: false, order: [[ 3 /* Last Seen */, 'desc' ]] };
	  configDevices.columns_config = columns;
	  configDevices.table_filters = table_filters;
	  DatatableVue.config_devices_standard = configDevices;


	  /* Centrality table configuration */

	  tmp_params['view'] = 'centrality';  
	  defaultDatatableConfig.data_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params);

	  columns = [
	    { columnName: i18n("map_page.host"), name: 'host', data: 'host', className: 'text-nowrap', render: (data, type) => { return data.label }, responsivePriority: 1 },
	    { columnName: i18n("map_page.asset_total_edges"), name: 'total_edges', data: 'total_edges', className: 'text-nowrap', responsivePriority: 1 },
	    { columnName: i18n("map_page.asset_in_edges"), name: 'in_edges', data: 'in_edges', className: 'text-nowrap', responsivePriority: 2 },
	    { columnName: i18n("map_page.asset_out_edges"), name: 'out_edges', data: 'out_edges',  className: 'text-center', responsivePriority: 2 },
	  ];
	  
	  let centralityConfigDevices = ntopng_utility.clone(defaultDatatableConfig);
	  centralityConfigDevices.table_config = { serverSide: false, order: [[ 1 /* Total Edges */, 'desc' ]] };
	  centralityConfigDevices.columns_config = columns;
	  centralityConfigDevices.table_filters = table_filters;

	  console.log(configDevices);
	  console.log(centralityConfigDevices);
	  
	  DatatableVue.config_devices_centrality = centralityConfigDevices;
	}

	const _hoisted_1$l = { class: "row" };
	const _hoisted_2$k = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$j = /*#__PURE__*/createBaseVNode("div", {
	  class: "alert alert-danger d-none",
	  id: "alert-row-buttons",
	  role: "alert"
	}, null, -1 /* HOISTED */);
	const _hoisted_4$j = { class: "card" };
	const _hoisted_5$j = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_6$j = { class: "card-body" };
	const _hoisted_7$i = { id: "table_asset" };
	const _hoisted_8$h = /*#__PURE__*/createTextVNode(" :table_config=\"config_devices_standard.table_config\"> ");
	const _hoisted_9$f = /*#__PURE__*/createTextVNode(" :table_config=\"config_devices_centrality.table_config\"> ");
	const _hoisted_10$c = { class: "card-footer" };
	const _hoisted_11$c = {
	  type: "button",
	  id: "btn-delete-all",
	  class: "btn btn-danger me-1"
	};
	const _hoisted_12$b = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
	const _hoisted_13$a = ["href"];
	const _hoisted_14$7 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
	const _hoisted_15$6 = [
	  _hoisted_14$7
	];

	function render$e(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
	  const _component_tab_list = resolveComponent("tab-list");
	  const _component_datatable = resolveComponent("datatable");

	  return (openBlock(), createElementBlock("div", _hoisted_1$l, [
	    createBaseVNode("div", _hoisted_2$k, [
	      _hoisted_3$j,
	      createBaseVNode("div", _hoisted_4$j, [
	        _hoisted_5$j,
	        createBaseVNode("div", _hoisted_6$j, [
	          createBaseVNode("div", _hoisted_7$i, [
	            createVNode(_component_modal_delete_confirm, {
	              ref: "modal_delete_all",
	              title: $data.title_delete,
	              body: $data.body_delete,
	              onDelete: $options.delete_all
	            }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
	            createVNode(_component_tab_list, {
	              ref: "asset_tab_list",
	              id: "asset_tab_list",
	              tab_list: $data.tab_list,
	              onClick_item: $options.click_item
	            }, null, 8 /* PROPS */, ["tab_list", "onClick_item"]),
	            ($data.asset_table_tab == 'standard')
	              ? (openBlock(), createBlock(_component_datatable, {
	                  key: 0,
	                  ref: "table_asset_standard",
	                  table_buttons: $data.config_devices_standard.table_buttons,
	                  columns_config: $data.config_devices_standard.columns_config,
	                  data_url: $data.config_devices_standard.data_url,
	                  enable_search: $data.config_devices_standard.enable_search,
	                  filter_buttons: $data.config_devices_standard.table_filters
	                }, {
	                  default: withCtx(() => [
	                    _hoisted_8$h
	                  ]),
	                  _: 1 /* STABLE */
	                }, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons"]))
	              : createCommentVNode("v-if", true),
	            ($data.asset_table_tab == 'centrality')
	              ? (openBlock(), createBlock(_component_datatable, {
	                  key: 1,
	                  ref: "table_asset_centrality",
	                  table_buttons: $data.config_devices_centrality.table_buttons,
	                  columns_config: $data.config_devices_centrality.columns_config,
	                  data_url: $data.config_devices_centrality.data_url,
	                  enable_search: $data.config_devices_centrality.enable_search,
	                  filter_buttons: $data.config_devices_centrality.table_filters
	                }, {
	                  default: withCtx(() => [
	                    _hoisted_9$f
	                  ]),
	                  _: 1 /* STABLE */
	                }, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons"]))
	              : createCommentVNode("v-if", true)
	          ])
	        ]),
	        createBaseVNode("div", _hoisted_10$c, [
	          createBaseVNode("button", _hoisted_11$c, [
	            _hoisted_12$b,
	            createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_assets")), 1 /* TEXT */)
	          ]),
	          createBaseVNode("a", {
	            href: $data.get_url,
	            class: "btn btn-primary",
	            role: "button",
	            "aria-disabled": "true",
	            download: "asset_map.json",
	            target: "_blank"
	          }, _hoisted_15$6, 8 /* PROPS */, _hoisted_13$a)
	        ])
	      ])
	    ])
	  ]))
	}

	script$n.render = render$e;
	script$n.__file = "http_src/vue/page-asset-table.vue";

	var script$m = {
	  components: {	  
	    'datatable': script$s,
	    'modal-delete-confirm': script$o,
	  },
	  props: {
	    page_csrf: String,
	    url_params: Object,
	    view: String,
	    table_filters: Array,
	    is_admin: Boolean,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    start_datatable$5(this);
	  },
	  mounted() {  
	    $("#btn-delete-all").click(() => this.show_delete_all_dialog());
	    
	    ntopng_events_manager.on_custom_event("page_periodicity_table", ntopng_custom_events.DATATABLE_LOADED, () => {
	      if(ntopng_url_manager$1.get_url_entry('host'))
	        this.hide_dropdowns();
	    });
	  },    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      base_url: `${http_prefix}/lua/pro/enterprise/get_map.lua`,
	      config_devices_standard: null,
	      config_devices_centrality: null,
	      title_delete: i18n('map_page.delete_services'),
	      body_delete: i18n('map_page.delete_services_message'),
	      title_download: i18n('map_page.download'),
	      body_download: i18n('map_page.download_message'),
	      get_url: null,
	    };
	  },
	  methods: { 
	    hide_dropdowns: function() {
	      $(`#network_dropdown`).attr('hidden', 'hidden');
	      $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
	      $(`#network_dropdown`).removeClass('d-inline');
	      $(`#vlan_id_dropdown`).removeClass('d-inline');
	    }, 
	    delete_all: async function() {
	      let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
	      let params = {
	        ifid: this.url_params.ifid,
	        action: 'reset',
	        page: this.url_params.page,
	        csrf: this.$props.page_csrf,
	        map: this.url_params.map
	      };
	      try {
	        let headers = {
	          'Content-Type': 'application/json'
	        };
	        await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	        this.reload_table();
	      } catch(err) {
	        this.reload_table();  
	      }      
	    },
	    reload_table: function() {
	      let table = this.get_active_table();
	      NtopUtils.showOverlays();
	      table.reload();
	      NtopUtils.hideOverlays();
	    },
	    destroy: function() {
	      let table = this.get_active_table();
	      table.destroy_table();
	    },
	    get_active_table: function() {
	      return this.$refs[`table_periodicity`];
	    },
	    show_delete_all_dialog: function() {
	      this.$refs["modal_delete_all"].show();
	    },  
	  },
	};  

	function start_datatable$5(DatatableVue) {
	  const datatableButton = [];
	  let columns = [];
	  let default_sorting_columns = 0;
	  DatatableVue.get_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, url_params);
	  
	  /* Manage the buttons close to the search box */
	  datatableButton.push({
	    text: '<i class="fas fa-sync"></i>',
	    className: 'btn-link',
	    action: function (e, dt, node, config) {
	      DatatableVue.reload_table();
	    }
	  });
	  
	  let tmp_params = ntopng_utility.clone(url_params);
	  tmp_params['view'] = null;
	  let defaultDatatableConfig = {
	    table_buttons: datatableButton,
	    columns_config: [],
	    data_url: NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params),
	    enable_search: true,
	  };

	  let table_filters = [];
	  for (let filter of (DatatableVue.$props.table_filters || [])) {
	    filter.callbackFunction = (table, value) => {
	      tmp_params[filter.filterMenuKey] = value.id;
	      ntopng_url_manager$1.set_key_to_url(filter.filterMenuKey, value.id);
	      table.ajax.url(NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params));
	      NtopUtils.showOverlays();
	      table.ajax.reload();
	      NtopUtils.hideOverlays();
	    },
	    table_filters.push(filter);
	  }
	  
	  /* Standard table configuration */  

	  columns = [
	    { columnName: i18n('map_page.last_seen'), name: 'last_seen', data: 'last_seen', className: 'text-center text-nowrap', render: (data, type) => { return data.value }, responsivePriority: 2 },
	    { columnName: i18n('map_page.client'), name: 'client', data: 'client', className: 'text-nowrap', responsivePriority: 2 },
	    { columnName: i18n('map_page.server'), name: 'server', data: 'server', className: 'text-nowrap', responsivePriority: 2 },
	    { columnName: i18n('map_page.port'), name: 'port', data: 'port',  className: 'text-center', responsivePriority: 4 },
	    { columnName: i18n('map_page.protocol'), name: 'l7proto', data: 'protocol', className: 'text-nowrap', responsivePriority: 3 },
	    { columnName: i18n('map_page.first_seen'), name: 'first_seen', data: 'first_seen', visible: false, responsivePriority: 3 },
	    { columnName: i18n('map_page.observations'), name: 'observations', data: 'observations', className: 'text-center', responsivePriority: 4 },
	    { columnName: i18n('map_page.frequency'), name: 'frequency', data: 'frequency', className: 'text-center', orderable: true, responsivePriority: 4, render: ( data, type, row ) => {
	        return (type == "sort" || type == 'type') ? data : data + " sec"; 
	      }
	    },
	  ];

	  default_sorting_columns = 6; /* Observation column */

	  /* Extra table configuration */
	  let table_config = {
	    serverSide: true,
	    order: [[ default_sorting_columns, 'desc' ]]
	  };
	  
	  let configDevices = ntopng_utility.clone(defaultDatatableConfig);
	  configDevices.table_buttons = defaultDatatableConfig.table_buttons;
	  configDevices.data_url = `${configDevices.data_url}`;
	  configDevices.columns_config = columns;
	  configDevices.table_filters = table_filters;
	  configDevices.table_config = ntopng_utility.clone(table_config);
	  DatatableVue.config_devices_standard = configDevices;
	}

	const _hoisted_1$k = { class: "row" };
	const _hoisted_2$j = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$i = /*#__PURE__*/createBaseVNode("div", {
	  class: "alert alert-danger d-none",
	  id: "alert-row-buttons",
	  role: "alert"
	}, null, -1 /* HOISTED */);
	const _hoisted_4$i = { class: "card" };
	const _hoisted_5$i = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_6$i = { class: "card-body" };
	const _hoisted_7$h = { id: "periodicity-table" };
	const _hoisted_8$g = { class: "card-footer" };
	const _hoisted_9$e = {
	  key: 0,
	  type: "button",
	  id: "btn-delete-all",
	  class: "btn btn-danger me-1"
	};
	const _hoisted_10$b = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
	const _hoisted_11$b = ["href"];
	const _hoisted_12$a = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
	const _hoisted_13$9 = [
	  _hoisted_12$a
	];

	function render$d(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
	  const _component_datatable = resolveComponent("datatable");

	  return (openBlock(), createElementBlock("div", _hoisted_1$k, [
	    createBaseVNode("div", _hoisted_2$j, [
	      _hoisted_3$i,
	      createBaseVNode("div", _hoisted_4$i, [
	        _hoisted_5$i,
	        createBaseVNode("div", _hoisted_6$i, [
	          createBaseVNode("div", _hoisted_7$h, [
	            createVNode(_component_modal_delete_confirm, {
	              ref: "modal_delete_all",
	              title: $data.title_delete,
	              body: $data.body_delete,
	              onDelete: $options.delete_all
	            }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
	            createVNode(_component_datatable, {
	              ref: "table_periodicity",
	              table_buttons: $data.config_devices_standard.table_buttons,
	              columns_config: $data.config_devices_standard.columns_config,
	              data_url: $data.config_devices_standard.data_url,
	              enable_search: $data.config_devices_standard.enable_search,
	              filter_buttons: $data.config_devices_standard.table_filters,
	              table_config: $data.config_devices_standard.table_config,
	              base_url: $data.base_url,
	              base_params: $props.url_params
	            }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons", "table_config", "base_url", "base_params"])
	          ])
	        ]),
	        createBaseVNode("div", _hoisted_8$g, [
	          ($props.is_admin)
	            ? (openBlock(), createElementBlock("button", _hoisted_9$e, [
	                _hoisted_10$b,
	                createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
	              ]))
	            : createCommentVNode("v-if", true),
	          createBaseVNode("a", {
	            href: $data.get_url,
	            class: "btn btn-primary",
	            role: "button",
	            "aria-disabled": "true",
	            download: "periodicity_map.json",
	            target: "_blank"
	          }, _hoisted_13$9, 8 /* PROPS */, _hoisted_11$b)
	        ])
	      ])
	    ])
	  ]))
	}

	script$m.render = render$d;
	script$m.__file = "http_src/vue/page-periodicity-table.vue";

	/**
	    (C) 2022 - ntop.org    
	*/


	const defaultOptions = { 
	  autoResize: true, 
	  nodes: { 
	      shape: "dot", 
	      scaling: {
	          min: 10,
	          max: 30,
	          label: {
	              min: 15,
	              max: 15,
	          },
	      },
	      shadow: false,
	  },
	  edges: {
	      width: 0.15,
	      color: { inherit: "from" },
	      smooth: {
	          type: "continuous",
	          roundness: 0
	      },
	  },
	  interaction: {
	      tooltipDelay: 150,
	      hideEdgesOnDrag: true,
	      hideEdgesOnZoom: true,
	      hover: true,
	      tooltipDelay: 0,
	  },
	  physics: {
	    barnesHut: {
	        springConstant: 0,
	        avoidOverlap: 0.3,
	        gravitationalConstant: -1000,
	        damping: 0.65,
	        centralGravity: 0
	    },
	    stabilization: {
	        onlyDynamicEdges: false
	    }
	  },
	  groups: {
	      unknown: {
	          shape: "dot",
	      },
	      printer: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf02f",
	          size: 50,
	          weight: 700,
	        },
	      },

	      video: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf03d",
	          size: 50,
	          weight: 700,
	        },
	      },

	      workstation: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf109",
	          size: 50,
	          weight: 700,
	        },
	      },

	      laptop: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf109",
	          size: 50,
	          weight: 700,
	        },
	      },

	      tablet: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf10a",
	          size: 50,
	          weight: 700,
	        },
	      },

	      phone: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf10b",
	          size: 50,
	          weight: 700,
	        },
	      },

	      tv: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf26c",
	          size: 50,
	          weight: 700,
	        },
	      },

	      networking: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf0b2",
	          size: 50,
	          weight: 700,
	        },
	      },

	      wifi: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf1eb",
	          size: 50,
	          weight: 700,
	        },
	      },

	      nas: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf1c0",
	          size: 50,
	          weight: 700,
	        },
	      },

	      multimedia: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\uf001",
	          size: 50,
	          weight: 700,
	        },
	      },

	      iot: {
	        shape: "icon",
	        icon: {
	          face: "'FontAwesome'",
	          code: "\ue012",
	          size: 50,
	          weight: 700,
	        },
	      },

	  },
	};

	const ntopng_map_manager = {
	  /**
	   * Change the status of a service.
	   * @param {string} service_id id of the service.
	   * @param {string} new_state id of the new status of the service.
	   * @param {function} callback function to be called on success.
	   */
	  toggle_state: function(service_id, new_state, callback, csrf) {
	    const request = $.post(`${http_prefix}/lua/pro/enterprise/switch_service_state.lua`, { 
	      service_id: service_id, service_status: new_state, csrf: csrf
	    });
	    request.then((data) => {
	      if(data.success && callback) 
	        callback();
	    });
	  },
	  get_default_options: function() {
	    return defaultOptions;
	  },
	};

	const change_service_table_tab_event = "change_service_table_tab_event";

	var script$l = {
	  components: {	  
	    'datatable': script$s,
	    'modal-delete-confirm': script$o,
	    'tab-list': script$p,
	  },
	  props: {
	    page_csrf: String,
	    url_params: Object,
	    view: String,
	    table_filters: Array,
	    is_admin: Boolean,
	    service_acceptance: Array,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    start_datatable$4(this);
	  },
	  mounted() {
	    this.service_table_tab = this.$props.url_params.view;
	    this.tab_list.forEach((i) => {
	      this.service_table_tab == i.id ? i.active = true : i.active = false;
	    });

	    ntopng_events_manager$1.on_custom_event("page_service_table", ntopng_custom_events.DATATABLE_LOADED, () => {
	      if(ntopng_url_manager$1.get_url_entry('host'))
	        this.hide_dropdowns();
	    });

	    ntopng_events_manager$1.on_custom_event("change_service_table_tab", change_service_table_tab_event, (tab) => {
		    let table = this.get_active_table();
	      ntopng_url_manager$1.set_key_to_url('view', tab);
	      table.delete_button_handlers(this.service_table_tab);
	      table.destroy_table();
	      this.service_table_tab = tab;
	    });
	    $("#btn-delete-all").click(() => this.show_delete_all_dialog());
	  },    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      config_devices_standard: null,
	      config_devices_centrality: null,
	      title_delete: i18n('map_page.delete_services'),
	      body_delete: i18n('map_page.delete_services_message'),
	      get_url: null,
	      service_table_tab: null,
	      tab_list: [
	        { 
	          title: i18n('map_page.standard_view'),
	          active: (view == 'standard'),
	          id: 'standard'
	        },
	        { 
	          title: i18n('map_page.centrality_view'),
	          active: (view == 'centrality'),
	          id: 'centrality'
	        },
	      ]
	    };
	  },
	  methods: { 
	    hide_dropdowns: function() {
	      $(`#network_dropdown`).attr('hidden', 'hidden');
	      $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
	      $(`#network_dropdown`).removeClass('d-inline');
	      $(`#vlan_id_dropdown`).removeClass('d-inline');
	    }, 
	    destroy: function() {
	      let table = this.get_active_table();
	      table.delete_button_handlers(this.service_table_tab);
	      table.destroy_table();
	    },
	    /* Method used to switch active table tab */
	    click_item: function(item) {
	      this.tab_list.forEach((i) => i.active = false);
	      item.active = true;
	      ntopng_events_manager$1.emit_custom_event(change_service_table_tab_event, item.id);
	    },
	    create_action_buttons: function(data, type, service) {
	      const reload = this.reload_table;
	      const csrf = this.$props.page_csrf;
	      const toggle_allowed_state = {
	        onClick: () => {
	          ntopng_map_manager.toggle_state(service.hash_id, this.$props.service_acceptance[0].id, reload, csrf);
	        }
	      };
	      const toggle_denied_state = {
	        onClick: () => {
	          ntopng_map_manager.toggle_state(service.hash_id, this.$props.service_acceptance[1].id, reload, csrf);
	        }
	      };
	      const toggle_undecided_state = {
	        onClick: () => {
	          ntopng_map_manager.toggle_state(service.hash_id, this.$props.service_acceptance[2].id, reload, csrf);
	        }
	      };

	      if (type !== "display") return data;
	      const currentStatus = service.acceptance;
	      const allowedButton = { class: 'dropdown-item', href: '#', title: this.$props.service_acceptance[0].label, handler: toggle_allowed_state };
	      const deniedButton = { class: 'dropdown-item', href: '#', title: this.$props.service_acceptance[1].label, handler: toggle_denied_state };
	      const undecidedButton = { class: 'dropdown-item disabled', href: '#', title: this.$props.service_acceptance[2].label, handler: toggle_undecided_state };
	      
	      switch (currentStatus) {
	        case 0: /* Allowed */   { allowedButton.class = 'dropdown-item active'; break; }
	        case 1: /* Denied */    { deniedButton.class = 'dropdown-item active'; break; }
	        case 2: /* Undecided */ { undecidedButton.class = 'dropdown-item active disabled'; break; }
	      }
	      return DataTableUtils.createActionButtons([undecidedButton, allowedButton, deniedButton]);
	    },
	    delete_all: async function() {
	      let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
	      let params = {
	        ifid: this.url_params.ifid,
	        action: 'reset',
	        page: this.url_params.page,
	        csrf: this.$props.page_csrf,
	        map: this.url_params.map
	      };
	      try {
	        let headers = {
	          'Content-Type': 'application/json'
	        };
	        await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	        this.reload_table();
	      } catch(err) {
	        this.reload_table();  
	      }      
	    },
	    reload_table: function() {
	      let table = this.get_active_table();
	      NtopUtils.showOverlays();
	      table.reload();
	      NtopUtils.hideOverlays();
	    },
	    get_active_table: function() {
	      return this.$refs[`table_service_${this.service_table_tab}`];
	    },
	    switch_to_standard: function() {
	      let new_url = this.url_params;
	      new_url['view'] = 'standard';
	      document.location.href = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/network_maps.lua`, url_params);
	    },
	    switch_to_centrality: function() {
	      let new_url = this.url_params;
	      new_url['view'] = 'centrality';
	      document.location.href = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/network_maps.lua`, url_params);
	    },
	    show_delete_all_dialog: function() {
	      this.$refs["modal_delete_all"].show();
	    },  
	  },
	};  

	function start_datatable$4(DatatableVue) {
	  const datatableButton = [];
	  let columns = [];
	  let default_sorting_columns = 0;
	  DatatableVue.get_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, url_params);
	  
	  /* Manage the buttons close to the search box */
	  datatableButton.push({
	    text: '<i class="fas fa-sync"></i>',
	    className: 'btn-link',
	    action: function (e, dt, node, config) {
	      DatatableVue.reload_table();
	    }
	  });
	  
	  let tmp_params = url_params;
	  tmp_params['view'] = 'standard';
	  
	  let defaultDatatableConfig = {
	    table_buttons: datatableButton,
	    columns_config: [],
	    data_url: NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params),
	    enable_search: true,
	  };

	  let table_filters = [];
	  for (let filter of (DatatableVue.$props.table_filters || [])) {
	    filter.callbackFunction = (table, value) => {
	      tmp_params['view'] = DatatableVue.service_table_tab;
	      tmp_params[filter.filterMenuKey] = value.id;
	      ntopng_url_manager$1.set_key_to_url(filter.filterMenuKey, value.id);
	      table.ajax.url(NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params));
	      NtopUtils.showOverlays();
	      table.ajax.reload();
	      NtopUtils.hideOverlays();
	    },
	    table_filters.push(filter);
	  }
	  
	  /* Standard table configuration */  

	  columns = [
	    { columnName: i18n("map_page.last_seen"), name: 'last_seen', data: 'last_seen', className: 'text-center text-nowrap', render: (data, type) => { return data.value }, responsivePriority: 2, createdCell: DataTableRenders.applyCellStyle },
	    { columnName: i18n("map_page.client"), name: 'client', data: 'client', className: 'text-nowrap', responsivePriority: 2 },
	    { columnName: i18n("map_page.server"), name: 'server', data: 'server', className: 'text-nowrap', responsivePriority: 2 },
	    { columnName: i18n("map_page.port"), name: 'port', data: 'port',  className: 'text-center', responsivePriority: 4 },
	    { columnName: i18n("map_page.protocol"), name: 'l7proto', data: 'protocol', className: 'text-nowrap', responsivePriority: 3 },
	    { columnName: i18n("map_page.first_seen"), name: 'first_seen', data: 'first_seen', visible: false, responsivePriority: 3 },
	    { columnName: i18n("map_page.num_uses"), name: 'num_uses', data: 'num_uses',  className: 'text-center text-nowrap', responsivePriority: 4 },
	    { columnName: i18n("map_page.info"), name: 'info', data: 'info', responsivePriority: 5 },
	  ];

	  default_sorting_columns = 6; /* Num Uses */

	  if(DatatableVue.is_admin) {
	    columns.push({ columnName: i18n("map_page.status"), name: 'service_acceptance', data: 'service_acceptance', className: 'text-center', orderable: false, responsivePriority: 1, render: (data, type, service) => {
	        return DatatableVue.create_action_buttons(data, type, service);
	      }
	    });
	  }
	  
	  /* Extra table configuration */
	  let table_config = {
	    serverSide: true,
	    order: [[ default_sorting_columns, 'desc' ]]
	  };
	  
	  let configDevices = ntopng_utility.clone(defaultDatatableConfig);
	  configDevices.table_buttons = defaultDatatableConfig.table_buttons;
	  configDevices.data_url = `${configDevices.data_url}`;
	  configDevices.columns_config = columns;
	  configDevices.table_filters = table_filters;
	  configDevices.table_config = ntopng_utility.clone(table_config);
	  DatatableVue.config_devices_standard = configDevices;

	  /* Centrality table configuration */

	  tmp_params['view'] = 'centrality';  
	  defaultDatatableConfig.data_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params);

	  columns = [
	    { columnName: i18n("map_page.host"), name: 'host', data: 'host', className: 'text-nowrap', responsivePriority: 1 },
	    { columnName: i18n("map_page.total_edges"), name: 'total_edges', data: 'total_edges', className: 'text-nowrap', responsivePriority: 1 },
	    { columnName: i18n("map_page.rank"), name: 'rank', data: 'rank', className: 'text-center', responsivePriority: 2 },
	    { columnName: i18n("map_page.in_edges"), name: 'in_edges', data: 'in_edges', className: 'text-nowrap', responsivePriority: 2 },
	    { columnName: i18n("map_page.out_edges"), name: 'out_edges', data: 'out_edges',  className: 'text-center', responsivePriority: 2 },
	  ];
	  
	  default_sorting_columns = 2; /* Rank */
	  table_config.order = [[ default_sorting_columns, 'desc' ]];
	  configDevices = ntopng_utility.clone(defaultDatatableConfig);
	  configDevices.table_buttons = defaultDatatableConfig.table_buttons;
	  configDevices.data_url = `${configDevices.data_url}`;
	  configDevices.columns_config = columns;
	  configDevices.table_filters = table_filters;
	  configDevices.table_config = ntopng_utility.clone(table_config);
	  DatatableVue.config_devices_centrality = configDevices;
	}

	const _hoisted_1$j = { class: "row" };
	const _hoisted_2$i = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$h = /*#__PURE__*/createBaseVNode("div", {
	  class: "alert alert-danger d-none",
	  id: "alert-row-buttons",
	  role: "alert"
	}, null, -1 /* HOISTED */);
	const _hoisted_4$h = { class: "card" };
	const _hoisted_5$h = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_6$h = { class: "card-body" };
	const _hoisted_7$g = { id: "table_service" };
	const _hoisted_8$f = { class: "card-footer" };
	const _hoisted_9$d = {
	  type: "button",
	  id: "btn-delete-all",
	  class: "btn btn-danger me-1"
	};
	const _hoisted_10$a = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
	const _hoisted_11$a = ["href"];
	const _hoisted_12$9 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
	const _hoisted_13$8 = [
	  _hoisted_12$9
	];

	function render$c(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
	  const _component_tab_list = resolveComponent("tab-list");
	  const _component_datatable = resolveComponent("datatable");

	  return (openBlock(), createElementBlock("div", _hoisted_1$j, [
	    createBaseVNode("div", _hoisted_2$i, [
	      _hoisted_3$h,
	      createBaseVNode("div", _hoisted_4$h, [
	        _hoisted_5$h,
	        createBaseVNode("div", _hoisted_6$h, [
	          createBaseVNode("div", _hoisted_7$g, [
	            createVNode(_component_modal_delete_confirm, {
	              ref: "modal_delete_all",
	              title: $data.title_delete,
	              body: $data.body_delete,
	              onDelete: $options.delete_all
	            }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
	            createVNode(_component_tab_list, {
	              ref: "service_tab_list",
	              id: "service_tab_list",
	              tab_list: $data.tab_list,
	              onClick_item: $options.click_item
	            }, null, 8 /* PROPS */, ["tab_list", "onClick_item"]),
	            ($data.service_table_tab == 'standard')
	              ? (openBlock(), createBlock(_component_datatable, {
	                  key: 0,
	                  ref: "table_service_standard",
	                  table_buttons: $data.config_devices_standard.table_buttons,
	                  columns_config: $data.config_devices_standard.columns_config,
	                  data_url: $data.config_devices_standard.data_url,
	                  enable_search: $data.config_devices_standard.enable_search,
	                  filter_buttons: $data.config_devices_standard.table_filters,
	                  table_config: $data.config_devices_standard.table_config
	                }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons", "table_config"]))
	              : createCommentVNode("v-if", true),
	            ($data.service_table_tab == 'centrality')
	              ? (openBlock(), createBlock(_component_datatable, {
	                  key: 1,
	                  ref: "table_service_centrality",
	                  table_buttons: $data.config_devices_centrality.table_buttons,
	                  columns_config: $data.config_devices_centrality.columns_config,
	                  data_url: $data.config_devices_centrality.data_url,
	                  enable_search: $data.config_devices_centrality.enable_search,
	                  filter_buttons: $data.config_devices_centrality.table_filters,
	                  table_config: $data.config_devices_centrality.table_config
	                }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons", "table_config"]))
	              : createCommentVNode("v-if", true)
	          ])
	        ]),
	        createBaseVNode("div", _hoisted_8$f, [
	          createCommentVNode("\n        {% if is_admin then %}\n          <form class=\"d-inline\" id='switch-state-form'>\n            <div class=\"form-group mb-3 d-inline\">\n              <label>{* i18n(\"map_page.set_state\", {label = \"<span class='count'></span>\"}) *}</label>\n              <select name=\"new_state\" class=\"form-select d-inline\" style=\"width: 16rem\" {{ ternary(map.services_num == 0, \"disabled='disabled'\", \"\") }}>\n              {% for _, status in pairsByField(map.filters.service_status_filters, label, asc_insensitive) do %}\n                <option value=\"{{ status.id }}\">{* status.label *}</option>\n              {% end %}\n              </select>\n              <button class=\"btn btn-secondary d-inline\" class=\"btn-switch-state\" {{ ternary(map.services_num == 0, \"disabled='disabled'\", \"\") }}>\n                <i class=\"fas fa-random\"></i> {{ i18n(\"set\") }}\n              </button>\n            </div>\n          </form>\n        {% end %}\n    "),
	          createBaseVNode("button", _hoisted_9$d, [
	            _hoisted_10$a,
	            createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
	          ]),
	          createBaseVNode("a", {
	            href: $data.get_url,
	            class: "btn btn-primary",
	            role: "button",
	            "aria-disabled": "true",
	            download: "service_map.json",
	            target: "_blank"
	          }, _hoisted_13$8, 8 /* PROPS */, _hoisted_11$a)
	        ])
	      ])
	    ])
	  ]))
	}

	script$l.render = render$c;
	script$l.__file = "http_src/vue/page-service-table.vue";

	const _hoisted_1$i = {
	  id: "empty-map-message",
	  class: "alert alert-info",
	  hidden: ""
	};
	const _hoisted_2$h = ["id"];


	var script$k = {
	  __name: 'network-map',
	  props: {
	  empty_message: String,
	  event_listeners: Object,
	  page_csrf: String,
	  url: String,
	  url_params: Object,
	  map_id: String,
	},
	  setup(__props, { expose }) {

	const props = __props;

	const MIN_SCALE = 0.15;
	const dataRequest = { 
	  ifid: props.url_params.ifid, 
	  action: 'load_graph', 
	  map: props.url_params.map_id
	};



	let network = null;
	let nodes_dataset = {};
	let edges_dataset = {};
	let container = null;
	let max_entries = false;
	let update_view_state_id = null;
	let url_params = {};
	let is_destroyed = false;

	onMounted(async () => {
	  load_scale();
	  url_params = props.url_params;
	  container = document.getElementById(props.map_id);
	  
	  // if an host has been defined inside the URL query then add it to the request
	  const url = NtopUtils.buildURL(props.url, url_params); 
	  await $.get(url, dataRequest, function(response) {
	    const {nodes, edges, max_entry_reached} = response.rsp;
	    max_entries = max_entry_reached;
	    nodes_dataset = new vis.DataSet(nodes);
	    edges_dataset = new vis.DataSet(edges);
	    const datasets = {nodes: nodes_dataset, edges: edges_dataset};
	    empty_network(datasets);
	    network = new vis.Network(container, datasets, ntopng_map_manager.get_default_options());
	    save_topology_view();
	    set_event_listener();
	    ntopng_events_manager$1.emit_custom_event(ntopng_custom_events.VIS_DATA_LOADED);
		});
	});

	onBeforeUnmount(() => {
	  if (is_destroyed == true) { return; }
	  destroy();
	});

	const jump_to_host = (params) => {
	  const tmpHost = params.id.split('@');
	  url_params['host'] = tmpHost[0];
	  url_params['vlan_id'] = tmpHost[1];
	  ntopng_url_manager$1.set_key_to_url('host', url_params['host']);
	  ntopng_url_manager$1.set_key_to_url('vlan_id', url_params['vlan_id']);
	  ntopng_events_manager$1.emit_custom_event(ntopng_custom_events.CHANGE_PAGE_TITLE, params);
	  reload();
	};

	const empty_network = (datasets) => {
	  if(datasets.nodes.length == 0 && datasets.edges.length == 0) {
	    $(`#empty-map-message`).removeAttr('hidden');
	  } else {
	    $(`#empty-map-message`).attr('hidden', 'hidden');
	  }
	};

	const load_scale = () => {
	  // load old scale for resizable containers
	  const oldScale = NtopUtils.loadElementScale($(`.resizable-y-container`));

	  if(oldScale === undefined) {
	    const scale = {width: $(`.resizable-y-container`).width(), height: $(`.resizable-y-container`).height()};
	    NtopUtils.saveElementScale($(this), scale);
	    return;
	  }

	  $(`.resizable-y-container`).width(oldScale.width);
	  $(`.resizable-y-container`).height(oldScale.height);
	  $(`.resizable-y-container`).on('mouseup', function() {
	    const scale = {width: $(`.resizable-y-container`).width(), height: $(`.resizable-y-container`).height()};
	    NtopUtils.saveElementScale($(this), scale);
	  });

	  $(`button[data-toggle="tooltip"]`).tooltip();
	};

	const set_event_listener = () => {
	  /* Default event listeners */
	  network.on('hoverEdge', function() {
	    $(`.vis-tooltip`).css('position', 'absolute');
	  });
	  
	  network.on("doubleClick", function (params) {
	    jump_to_host(nodes_dataset.get(params.nodes[0]));
	  });

	  network.on('zoom', function(e) {
	    update_view_state_id = zoom_in_and_save_topology();
	  });

	  network.on("dragEnd", function(e) {
	    drag();
	  });

	  /* Given event listeners */
	  for (const item in (props.event_listeners || {})) {
	    network.on(item, props.event_listeners[item]);
	  }
	};

	const save_topology_view = () => {
	  if(!network) return;
	  // get all nodes position
	  const positions = network.getPositions(network.body.data.nodes.map(x => x.id));

	  // save the nodes position, the network scale and the network view position
	  const info = {
	    positions: positions,
	    network: {
	      scale: network.getScale(),
	      position: network.getViewPosition()
	    }
	  };

	  $.post(props.url, {
	    ...url_params,
	    ...{ 
	      csrf: props.page_csrf,
	      JSON: JSON.stringify(info), 
	      action: 'save_view' 
	    }
	  });
	};

	const zoom_in_and_save_topology = () => {
	  if (network.getScale() <= MIN_SCALE) {
	    network.moveTo({
	      scale: MIN_SCALE + 0.25,
	      position: { x: 0, y: 0 },
	      animation: { duration: 1000, easingFunction: 'easeInOutCubic' }
	    });
	  }

	  clearTimeout(update_view_state_id);


	  return setTimeout(save_topology_view);
	};

	const autolayout = () => {
	  if (network === undefined) {
	    console.error("The network is undefined!");
	    return;
	  }

	  if (!(network instanceof vis.Network)) {
	    console.error("Not a vis.Network instance!");
	    return;
	  }

	  network.stabilize();
	  setTimeout(() => { save_topology_view(); }, 1000);
	};

	const drag = () => {
	  if (update_view_state_id) {
	    clearTimeout(update_view_state_id);
	  }

	  save_topology_view();
	};

	const destroy = () => {
	  network.destroy(true);
	  is_destroyed = true;
	};

	const is_max_entry_reached = () => {
	  return max_entries;
	};

	const update_url_params = (new_url_params) => {
	  url_params = new_url_params;
	};

	const reload = async () => {
	  console.log(url_params);
	  const url = NtopUtils.buildURL(props.url, url_params); 
	  await $.get(url, dataRequest, function(response) {
	    const {nodes, edges, max_entry_reached} = response.rsp;
	    max_entries = max_entry_reached;
	    nodes_dataset = new vis.DataSet(nodes);
	    edges_dataset = new vis.DataSet(edges);
	    const datasets = { nodes: nodes_dataset, edges: edges_dataset };
	    empty_network(datasets);
	    if(network)
	      network.setData(datasets);
	    
	    ntopng_events_manager$1.emit_custom_event(ntopng_custom_events.VIS_DATA_LOADED);
		  save_topology_view();
	  });
	};


	expose({ reload, destroy, is_max_entry_reached, autolayout, update_url_params });

	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock(Fragment, null, [
	    createBaseVNode("div", _hoisted_1$i, toDisplayString(__props.empty_message), 1 /* TEXT */),
	    createBaseVNode("div", {
	      class: "d-flex justify-content-center align-items-center resizable-y-container",
	      style: {"width":"100%","height":"60vh"},
	      id: __props.map_id
	    }, null, 8 /* PROPS */, _hoisted_2$h)
	  ], 64 /* STABLE_FRAGMENT */))
	}
	}

	};

	script$k.__file = "http_src/vue/network-map.vue";

	var script$j = {
	  __name: 'modal-autolayout-confirm',
	  props: {
	    body: String,
	    title: String,
	},
	  emits: ['autolayout'],
	  setup(__props, { expose, emit }) {

	const modal_id = ref(null);


	const showed = () => {};



	const show = () => {
	    modal_id.value.show();
	};

	const autolayout_ = () => {
	    emit('autolayout');
	    close();
	};

	const close = () => {
	    modal_id.value.close();
	};


	expose({ show, close });

	onMounted(() => {
	});

	const _i18n = (t) => i18n(t);


	return (_ctx, _cache) => {
	  return (openBlock(), createBlock(script$y, {
	    onShowed: _cache[0] || (_cache[0] = $event => (showed())),
	    ref_key: "modal_id",
	    ref: modal_id
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
	    ]),
	    body: withCtx(() => [
	      createTextVNode(toDisplayString(__props.body), 1 /* TEXT */)
	    ]),
	    footer: withCtx(() => [
	      createBaseVNode("button", {
	        type: "button",
	        onClick: autolayout_,
	        class: "btn btn-primary"
	      }, toDisplayString(_i18n('confirm')), 1 /* TEXT */)
	    ]),
	    _: 1 /* STABLE */
	  }, 512 /* NEED_PATCH */))
	}
	}

	};

	script$j.__file = "http_src/vue/modal-autolayout-confirm.vue";

	const change_filter_event$2 = "change_filter_event";

	var script$i = {
	  components: {	  
	    'network-map': script$k,
	    'modal-delete-confirm': script$o,
	    'modal-autolayout-confirm': script$j,
	    'select-search': script$A,
	  },
	  props: {
	    page_csrf: String,
	    ifid: Number,
	    url_params: Object,
	    map_id: String,
	    is_admin: Boolean,
	    all_filter_list: Object,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    start_vis_network_map$2(this);
	  },
	  mounted() {
	    const max_entries_reached = this.max_entry_reached;
	    const reload_map = this.reload_map;
	    if(this.$props.url_params.host && this.$props.url_params.host != '') {
	      this.hide_dropdowns();
	    }

	    ntopng_events_manager$1.on_custom_event("page_service_map", ntopng_custom_events.CHANGE_PAGE_TITLE, (node) => {
	      this.hide_dropdowns();
	    });

	    ntopng_events_manager$1.on_custom_event("change_filter_event", change_filter_event$2, (filter) => {
	      this.active_filter_list[filter.id] = filter;
	      ntopng_url_manager.set_key_to_url(filter.filter_name, filter.key);
	      this.url_params[filter.filter_name] = filter.key;
	      this.update_and_reload_map();
	    });

	    ntopng_events_manager$1.on_custom_event(this.get_map(), ntopng_custom_events.VIS_DATA_LOADED, (filter) => {
	      if(max_entries_reached()) {
	        $(`#max-entries-reached`).removeAttr('hidden');
	      } else {
	        $(`#max-entries-reached`).attr('hidden', 'hidden');
	      }
	    });

	    /* Remove invalid filters */
	    let entries = ntopng_url_manager.get_url_entries();
	    for(const [key, value] of entries) {
	      this.url_params[key] = value;
	    }

	    //this.update_and_reload_map()
	    
	    $(`#reload-graph`).click(function(e){
	      reload_map();
	    });
	    
	    setTimeout(() => NtopUtils.hideOverlays(), 0);

	    $("#btn-delete-all").click(() => this.show_delete_all_dialog());
	    $("#autolayout").click(() => this.show_autolayout_dialog());
	  },    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      container: null,
	      update_view_state_id: null,
	      get_url: null,
	      download_url: null,
	      filter_list: [],
	      active_filter_list: [],
	      event_listeners: {},
	      title_delete: i18n('map_page.delete_services'),
	      body_delete: i18n('map_page.delete_services_message'),
	      title_autolayout: i18n('map_page.autolayout_services'),
	      body_autolayout: i18n('map_page.autolayout_services_message'),
	      no_services_message: i18n('map_page.no_services'),
	      max_entry_title: i18n('max_entries_reached'),
	    };
	  },
	  methods: { 
	    destroy: function() {
	      let map = this.get_map();
	      map.destroy();
	    },
	    /* Method used to switch active table tab */
	    click_item: function(filter) {
	      ntopng_events_manager$1.emit_custom_event(change_filter_event$2, filter);
	    },
	    get_map: function() {
	      return this.$refs[`service_map`];
	    },
	    max_entry_reached: function() {
	      let map = this.get_map();
	      return map.is_max_entry_reached();
	    },
	    reload_map: async function() {
	      NtopUtils.showOverlays();
	      let map = this.get_map();
	      await map.reload();
	      NtopUtils.hideOverlays();
	    },
	    update_and_reload_map: async function() {
	      let map = this.get_map();
	      NtopUtils.showOverlays();
	      map.update_url_params(this.url_params);
	      await map.reload();
	      NtopUtils.hideOverlays();
	    },
	    autolayout: function() {
	      let map = this.get_map();
	      map.autolayout();
	    },
	    show_delete_all_dialog: function() {
	      this.$refs["modal_delete_all"].show();
	    },  
	    show_autolayout_dialog: function() {
	      this.$refs["modal_autolayout"].show();
	    }, 
	    hide_dropdowns: function() {
	      $(`#network_dropdown`).attr('hidden', 'hidden');
	      $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
	    }, 
	    delete_all: async function() {
	      let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
	      let params = {
	        ifid: this.url_params.ifid,
	        action: 'reset',
	        csrf: this.$props.page_csrf,
	        map: this.url_params.map
	      };
	      try {
	        let headers = {
	          'Content-Type': 'application/json'
	        };
	        await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	      } finally {
	        this.reload_map();
	      }      
	    },
	  },
	};  

	function start_vis_network_map$2(NetworkMapVue) {
	  /* Format the filter list, to add the dropdowns */
	  for (const filter_name in NetworkMapVue.$props.all_filter_list) {
	    NetworkMapVue.filter_list.push(NetworkMapVue.$props.all_filter_list[filter_name]);
	    const active_filter = ntopng_url_manager.get_url_entry(filter_name);
	    /* Put the filter name into the filters */
	    for(let [_, value] of Object.entries(NetworkMapVue.$props.all_filter_list[filter_name])) {
	      value['filter_name'] = filter_name;
	      if(active_filter) {
	        /* If there is a filter selected in the url push that as active */
	        if(value.id == active_filter) 
	          NetworkMapVue.active_filter_list.push(value);
	      } else {
	        /* push the default filter as active */
	        if(value.currently_active == true) 
	          NetworkMapVue.active_filter_list.push(value);
	      }
	    }
	  }

	  NetworkMapVue.get_url = `${http_prefix}/lua/pro/rest/v2/get/interface/map/data.lua`;
	  NetworkMapVue.download_url = NtopUtils.buildURL(NetworkMapVue.get_url, NetworkMapVue.$props.url_params);
	  NetworkMapVue.event_listeners = {};
	}

	const _hoisted_1$h = { class: "row" };
	const _hoisted_2$g = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$g = { class: "card card-shadow" };
	const _hoisted_4$g = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_5$g = { class: "card-body" };
	const _hoisted_6$g = { id: "table_service" };
	const _hoisted_7$f = { class: "d-flex align-items-center justify-content-end mb-2" };
	const _hoisted_8$e = ["title"];
	const _hoisted_9$c = /*#__PURE__*/createBaseVNode("i", { class: "text-danger fa-solid fa-triangle-exclamation" }, null, -1 /* HOISTED */);
	const _hoisted_10$9 = [
	  _hoisted_9$c
	];
	const _hoisted_11$9 = { class: "d-flex ms-auto" };
	const _hoisted_12$8 = { class: "m-1" };
	const _hoisted_13$7 = /*#__PURE__*/createBaseVNode("button", {
	  type: "button",
	  id: "reload-graph",
	  class: "btn btn-link btn-reload-graph"
	}, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
	], -1 /* HOISTED */);
	const _hoisted_14$6 = /*#__PURE__*/createBaseVNode("button", {
	  type: "button",
	  id: "autolayout",
	  class: "btn btn-link btn-stabilize"
	}, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-magic" })
	], -1 /* HOISTED */);
	const _hoisted_15$5 = { class: "card-footer" };
	const _hoisted_16$5 = {
	  type: "button",
	  id: "btn-delete-all",
	  class: "btn btn-danger me-1"
	};
	const _hoisted_17$5 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
	const _hoisted_18$5 = ["href"];
	const _hoisted_19$5 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
	const _hoisted_20$5 = [
	  _hoisted_19$5
	];

	function render$b(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_select_search = resolveComponent("select-search");
	  const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
	  const _component_modal_autolayout_confirm = resolveComponent("modal-autolayout-confirm");
	  const _component_network_map = resolveComponent("network-map");

	  return (openBlock(), createElementBlock("div", _hoisted_1$h, [
	    createBaseVNode("div", _hoisted_2$g, [
	      createBaseVNode("div", _hoisted_3$g, [
	        _hoisted_4$g,
	        createBaseVNode("div", _hoisted_5$g, [
	          createBaseVNode("div", _hoisted_6$g, [
	            createBaseVNode("div", _hoisted_7$f, [
	              createBaseVNode("button", {
	                id: "max-entries-reached",
	                type: "button",
	                class: "btn btn-link",
	                title: $data.max_entry_title,
	                disabled: "",
	                hidden: ""
	              }, _hoisted_10$9, 8 /* PROPS */, _hoisted_8$e),
	              createBaseVNode("div", _hoisted_11$9, [
	                (openBlock(true), createElementBlock(Fragment, null, renderList($data.filter_list, (_, index) => {
	                  return (openBlock(), createElementBlock("div", _hoisted_12$8, [
	                    createVNode(_component_select_search, {
	                      selected_option: $data.active_filter_list[index],
	                      "onUpdate:selected_option": $event => (($data.active_filter_list[index]) = $event),
	                      options: $data.filter_list[index],
	                      onSelect_option: $options.click_item
	                    }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options", "onSelect_option"])
	                  ]))
	                }), 256 /* UNKEYED_FRAGMENT */))
	              ]),
	              _hoisted_13$7,
	              _hoisted_14$6
	            ]),
	            createVNode(_component_modal_delete_confirm, {
	              ref: "modal_delete_all",
	              title: $data.title_delete,
	              body: $data.body_delete,
	              onDelete: $options.delete_all
	            }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
	            createVNode(_component_modal_autolayout_confirm, {
	              ref: "modal_autolayout",
	              title: $data.title_autolayout,
	              body: $data.body_autolayout,
	              onAutolayout: $options.reload_map
	            }, null, 8 /* PROPS */, ["title", "body", "onAutolayout"]),
	            createVNode(_component_network_map, {
	              ref: "service_map",
	              empty_message: $data.no_services_message,
	              event_listeners: $data.event_listeners,
	              page_csrf: $props.page_csrf,
	              url: $data.get_url,
	              url_params: $props.url_params,
	              map_id: $props.map_id
	            }, null, 8 /* PROPS */, ["empty_message", "event_listeners", "page_csrf", "url", "url_params", "map_id"])
	          ])
	        ]),
	        createBaseVNode("div", _hoisted_15$5, [
	          createBaseVNode("button", _hoisted_16$5, [
	            _hoisted_17$5,
	            createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
	          ]),
	          createBaseVNode("a", {
	            href: $data.download_url,
	            class: "btn btn-primary",
	            role: "button",
	            "aria-disabled": "true",
	            download: "service_map.json",
	            target: "_blank"
	          }, _hoisted_20$5, 8 /* PROPS */, _hoisted_18$5)
	        ])
	      ])
	    ])
	  ]))
	}

	script$i.render = render$b;
	script$i.__file = "http_src/vue/page-service-map.vue";

	const change_filter_event$1 = "change_filter_event";

	var script$h = {
	  components: {	  
	    'network-map': script$k,
	    'modal-delete-confirm': script$o,
	    'modal-autolayout-confirm': script$j,
	    'select-search': script$A,
	  },
	  props: {
	    page_csrf: String,
	    ifid: Number,
	    url_params: Object,
	    map_id: String,
	    is_admin: Boolean,
	    all_filter_list: Object,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    start_vis_network_map$1(this);
	  },
	  mounted() {
	    this.updated_url_params = this.$props.url_params;
	    /* Remove invalid filters */
	    let entries = ntopng_url_manager.get_url_entries();
	    for(const [key, value] of entries) {
	      this.updated_url_params[key] = value;
	    }

	    const max_entries_reached = this.max_entry_reached;
	    const reload_map = this.reload_map;
	    this.update_and_reload_map();
	    if(this.$props.url_params.host && this.$props.url_params.host != '') {
	      this.hide_dropdowns();
	    }

	    ntopng_events_manager$1.on_custom_event("page_periodicity_map", ntopng_custom_events.CHANGE_PAGE_TITLE, (node) => {
	      this.hide_dropdowns();
	    });

	    ntopng_events_manager$1.on_custom_event("change_filter_event", change_filter_event$1, (filter) => {
		    this.active_filter_list[filter.id] = filter;
	      ntopng_url_manager.set_key_to_url(filter.filter_name, filter.key);
	      this.url_params[filter.filter_name] = filter.key;
	      this.update_and_reload_map();
	    });

	    ntopng_events_manager$1.on_custom_event(this.get_map(), ntopng_custom_events.VIS_DATA_LOADED, (filter) => {
	      if(max_entries_reached()) {
	        $(`#max-entries-reached`).removeAttr('hidden');
	      } else {
	        $(`#max-entries-reached`).attr('hidden', 'hidden');
	      }
	    });
	    
	    $(`#reload-graph`).click(function(e){
	      reload_map();
	    });
	    
	    setTimeout(() => NtopUtils.hideOverlays(), 0);

	    $("#btn-delete-all").click(() => this.show_delete_all_dialog());
	    $("#autolayout").click(() => this.show_autolayout_dialog());
	  },    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      container: null,
	      update_view_state_id: null,
	      get_url: null,
	      download_url: null,
	      updated_url_params: {},
	      filter_list: [],
	      active_filter_list: [],
	      event_listeners: {},
	      title_delete: i18n('map_page.delete_services'),
	      body_delete: i18n('map_page.delete_services_message'),
	      title_autolayout: i18n('map_page.autolayout_services'),
	      body_autolayout: i18n('map_page.autolayout_services_message'),
	      no_services_message: i18n('map_page.no_services'),
	      max_entry_title: i18n('max_entries_reached'),
	    };
	  },
	  methods: { 
	    destroy: function() {
	      let map = this.get_map();
	      map.destroy();
	    },
	    /* Method used to switch active table tab */
	    click_item: function(filter) {
	      ntopng_events_manager$1.emit_custom_event(change_filter_event$1, filter);
	    },
	    get_map: function() {
	      return this.$refs[`periodicity_map`]
	    },
	    max_entry_reached: function() {
	      let map = this.get_map();
	      return map.is_max_entry_reached();
	    },
	    reload_map: async function() {
	      NtopUtils.showOverlays();
	      let map = this.get_map();
	      await map.reload();
	      NtopUtils.hideOverlays();
	    },
	    hide_dropdowns: function() {
	      $(`#network_dropdown`).attr('hidden', 'hidden');
	      $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
	    }, 
	    update_and_reload_map: async function() {
	      let map = this.get_map();
	      NtopUtils.showOverlays();
	      map.update_url_params(this.updated_url_params);
	      await map.reload();
	      NtopUtils.hideOverlays();
	    },
	    autolayout: function() {
	      let map = this.get_map();
	      map.autolayout();
	    },
	    show_delete_all_dialog: function() {
	      this.$refs["modal_delete_all"].show();
	    },  
	    show_autolayout_dialog: function() {
	      this.$refs["modal_autolayout"].show();
	    },  
	    delete_all: async function() {
	      let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
	      let params = {
	        ifid: this.updated_url_params.ifid,
	        action: 'reset',
	        csrf: this.$props.page_csrf,
	        map: this.updated_url_params.map
	      };
	      try {
	        let headers = {
	          'Content-Type': 'application/json'
	        };
	        await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	      } finally {
	        this.reload_map();
	      }      
	    },
	  },
	};  

	function start_vis_network_map$1(NetworkMapVue) {
	  /* Format the filter list, to add the dropdowns */
	  for (const filter_name in NetworkMapVue.$props.all_filter_list) {
	    NetworkMapVue.filter_list.push(NetworkMapVue.$props.all_filter_list[filter_name]);
	    const active_filter = ntopng_url_manager.get_url_entry(filter_name);
	    /* Put the filter name into the filters */
	    for(let [_, value] of Object.entries(NetworkMapVue.$props.all_filter_list[filter_name])) {
	      value['filter_name'] = filter_name;
	      if(active_filter) {
	        /* If there is a filter selected in the url push that as active */
	        if(value.id == active_filter) 
	          NetworkMapVue.active_filter_list.push(value);
	      } else {
	        /* push the default filter as active */
	        if(value.currently_active == true) 
	          NetworkMapVue.active_filter_list.push(value);
	      }
	    }
	  }

	  NetworkMapVue.get_url = `${http_prefix}/lua/pro/rest/v2/get/interface/map/data.lua`;
	  NetworkMapVue.download_url = NtopUtils.buildURL(NetworkMapVue.get_url, NetworkMapVue.updated_url_params);
	  NetworkMapVue.event_listeners = {};
	}

	const _hoisted_1$g = { class: "row" };
	const _hoisted_2$f = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$f = { class: "card card-shadow" };
	const _hoisted_4$f = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_5$f = { class: "card-body" };
	const _hoisted_6$f = { id: "table_periodicity" };
	const _hoisted_7$e = { class: "d-flex align-items-center justify-content-end mb-2" };
	const _hoisted_8$d = ["title"];
	const _hoisted_9$b = /*#__PURE__*/createBaseVNode("i", { class: "text-danger fa-solid fa-triangle-exclamation" }, null, -1 /* HOISTED */);
	const _hoisted_10$8 = [
	  _hoisted_9$b
	];
	const _hoisted_11$8 = { class: "d-flex ms-auto" };
	const _hoisted_12$7 = { class: "m-1" };
	const _hoisted_13$6 = /*#__PURE__*/createBaseVNode("button", {
	  type: "button",
	  id: "reload-graph",
	  class: "btn btn-link btn-reload-graph"
	}, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
	], -1 /* HOISTED */);
	const _hoisted_14$5 = /*#__PURE__*/createBaseVNode("button", {
	  type: "button",
	  id: "autolayout",
	  class: "btn btn-link btn-stabilize"
	}, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-magic" })
	], -1 /* HOISTED */);
	const _hoisted_15$4 = { class: "card-footer" };
	const _hoisted_16$4 = {
	  type: "button",
	  id: "btn-delete-all",
	  class: "btn btn-danger me-1"
	};
	const _hoisted_17$4 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
	const _hoisted_18$4 = ["href"];
	const _hoisted_19$4 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
	const _hoisted_20$4 = [
	  _hoisted_19$4
	];

	function render$a(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_select_search = resolveComponent("select-search");
	  const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
	  const _component_modal_autolayout_confirm = resolveComponent("modal-autolayout-confirm");
	  const _component_network_map = resolveComponent("network-map");

	  return (openBlock(), createElementBlock("div", _hoisted_1$g, [
	    createBaseVNode("div", _hoisted_2$f, [
	      createBaseVNode("div", _hoisted_3$f, [
	        _hoisted_4$f,
	        createBaseVNode("div", _hoisted_5$f, [
	          createBaseVNode("div", _hoisted_6$f, [
	            createBaseVNode("div", _hoisted_7$e, [
	              createBaseVNode("button", {
	                id: "max-entries-reached",
	                type: "button",
	                class: "btn btn-link",
	                title: $data.max_entry_title,
	                disabled: "",
	                hidden: ""
	              }, _hoisted_10$8, 8 /* PROPS */, _hoisted_8$d),
	              createBaseVNode("div", _hoisted_11$8, [
	                (openBlock(true), createElementBlock(Fragment, null, renderList($data.filter_list, (_, index) => {
	                  return (openBlock(), createElementBlock("div", _hoisted_12$7, [
	                    createVNode(_component_select_search, {
	                      selected_option: $data.active_filter_list[index],
	                      "onUpdate:selected_option": $event => (($data.active_filter_list[index]) = $event),
	                      options: $data.filter_list[index],
	                      onSelect_option: $options.click_item
	                    }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options", "onSelect_option"])
	                  ]))
	                }), 256 /* UNKEYED_FRAGMENT */))
	              ]),
	              _hoisted_13$6,
	              _hoisted_14$5
	            ]),
	            createVNode(_component_modal_delete_confirm, {
	              ref: "modal_delete_all",
	              title: $data.title_delete,
	              body: $data.body_delete,
	              onDelete: $options.delete_all
	            }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
	            createVNode(_component_modal_autolayout_confirm, {
	              ref: "modal_autolayout",
	              title: $data.title_autolayout,
	              body: $data.body_autolayout,
	              onAutolayout: $options.reload_map
	            }, null, 8 /* PROPS */, ["title", "body", "onAutolayout"]),
	            createVNode(_component_network_map, {
	              ref: "periodicity_map",
	              empty_message: $data.no_services_message,
	              event_listeners: $data.event_listeners,
	              page_csrf: $props.page_csrf,
	              url: $data.get_url,
	              url_params: $props.url_params,
	              map_id: $props.map_id
	            }, null, 8 /* PROPS */, ["empty_message", "event_listeners", "page_csrf", "url", "url_params", "map_id"])
	          ])
	        ]),
	        createBaseVNode("div", _hoisted_15$4, [
	          createBaseVNode("button", _hoisted_16$4, [
	            _hoisted_17$4,
	            createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
	          ]),
	          createBaseVNode("a", {
	            href: $data.download_url,
	            class: "btn btn-primary",
	            role: "button",
	            "aria-disabled": "true",
	            download: "periodicity_map.json",
	            target: "_blank"
	          }, _hoisted_20$4, 8 /* PROPS */, _hoisted_18$4)
	        ])
	      ])
	    ])
	  ]))
	}

	script$h.render = render$a;
	script$h.__file = "http_src/vue/page-periodicity-map.vue";

	const change_filter_event = "change_filter_event";

	var script$g = {
	  components: {	  
	    'network-map': script$k,
	    'modal-delete-confirm': script$o,
	    'modal-autolayout-confirm': script$j,
	    'select-search': script$A,
	  },
	  props: {
	    page_csrf: String,
	    ifid: Number,
	    url_params: Object,
	    map_id: String,
	    is_admin: Boolean,
	    all_filter_list: Object,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    start_vis_network_map(this);
	  },
	  mounted() {
	    const max_entries_reached = this.max_entry_reached;
	    const reload_map = this.reload_map;
	    if(this.$props.url_params.host && this.$props.url_params.host != '') {
	      this.hide_dropdowns();
	    }

	    ntopng_events_manager$1.on_custom_event("page_service_map", ntopng_custom_events.CHANGE_PAGE_TITLE, (node) => {
	      this.hide_dropdowns();
	    });

	    ntopng_events_manager$1.on_custom_event("change_filter_event", change_filter_event, (filter) => {
		    this.active_filter_list[filter.id] = filter;
	      ntopng_url_manager$1.set_key_to_url(filter.filter_name, filter.key);
	      this.url_params[filter.filter_name] = filter.key;
	      this.update_and_reload_map();
	    });

	    ntopng_events_manager$1.on_custom_event(this.get_map(), ntopng_custom_events.VIS_DATA_LOADED, (filter) => {
	      if(max_entries_reached()) {
	        $(`#max-entries-reached`).removeAttr('hidden');
	      } else {
	        $(`#max-entries-reached`).attr('hidden', 'hidden');
	      }
	    });

	    /* Remove invalid filters */
	    let entries = ntopng_url_manager$1.get_url_entries();
	    for(const [key, value] of entries) {
	      this.url_params[key] = value;
	    }

	    $(`#reload-graph`).click(function(e){
	      reload_map();
	    });
	    
	    NtopUtils.hideOverlays();

	    $("#btn-delete-all").click(() => this.show_delete_all_dialog());
	    $("#autolayout").click(() => this.show_autolayout_dialog());
	  },    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      container: null,
	      update_view_state_id: null,
	      get_url: null,
	      download_url: null,
	      filter_list: [],
	      active_filter_list: [],
	      event_listeners: {},
	      title_delete: i18n('map_page.delete_services'),
	      body_delete: i18n('map_page.delete_services_message'),
	      title_autolayout: i18n('map_page.autolayout_services'),
	      body_autolayout: i18n('map_page.autolayout_services_message'),
	      no_services_message: i18n('map_page.no_services'),
	      max_entry_title: i18n('max_entries_reached'),
	    };
	  },
	  methods: { 
	    destroy: function() {
	      let map = this.get_map();
	      map.destroy();
	    },
	    /* Method used to switch active table tab */
	    click_item: function(filter) {
	      ntopng_events_manager$1.emit_custom_event(change_filter_event, filter);
	    },
	    get_map: function() {
	      return this.$refs[`asset_map`];
	    },
	    hide_dropdowns: function() {
	      $(`#network_dropdown`).attr('hidden', 'hidden');
	      $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
	    }, 
	    max_entry_reached: function() {
	      let map = this.get_map();
	      return map.is_max_entry_reached();
	    },
	    reload_map: async function() {
	      NtopUtils.showOverlays();
	      let map = this.get_map();
	      await map.reload();
	      NtopUtils.hideOverlays();
	    },
	    update_and_reload_map: async function() {
	      let map = this.get_map();
	      NtopUtils.showOverlays();
	      map.update_url_params(this.url_params);
	      await map.reload();
	      NtopUtils.hideOverlays();
	    },
	    autolayout: function() {
	      let map = this.get_map();
	      map.autolayout();
	    },
	    show_delete_all_dialog: function() {
	      this.$refs["modal_delete_all"].show();
	    },  
	    show_autolayout_dialog: function() {
	      this.$refs["modal_autolayout"].show();
	    },  
	    delete_all: async function() {
	      let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
	      let params = {
	        ifid: this.url_params.ifid,
	        action: 'reset',
	        csrf: this.$props.page_csrf,
	        map: this.url_params.map
	      };
	      try {
	        let headers = {
	          'Content-Type': 'application/json'
	        };
	        await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	      } finally {
	        NtopUtils.showOverlays();
	        this.reload_map();
	        NtopUtils.hideOverlays();
	      }      
	    },
	  },
	};  

	function start_vis_network_map(NetworkMapVue) {
	  /* Format the filter list, to add the dropdowns */
	  for (const filter_name in NetworkMapVue.$props.all_filter_list) {
	    NetworkMapVue.filter_list.push(NetworkMapVue.$props.all_filter_list[filter_name]);
	    const active_filter = ntopng_url_manager$1.get_url_entry(filter_name);
	    /* Put the filter name into the filters */
	    for(let [_, value] of Object.entries(NetworkMapVue.$props.all_filter_list[filter_name])) {
	      value['filter_name'] = filter_name;
	      if(active_filter) {
	        /* If there is a filter selected in the url push that as active */
	        if(value.id == active_filter) 
	          NetworkMapVue.active_filter_list.push(value);
	      } else {
	        /* push the default filter as active */
	        if(value.currently_active == true) 
	          NetworkMapVue.active_filter_list.push(value);
	      }
	    }
	  }

	  NetworkMapVue.get_url = `${http_prefix}/lua/pro/rest/v2/get/interface/map/data.lua`;
	  NetworkMapVue.download_url = NtopUtils.buildURL(NetworkMapVue.get_url, NetworkMapVue.$props.url_params);
	  NetworkMapVue.event_listeners = {};
	}

	const _hoisted_1$f = { class: "row" };
	const _hoisted_2$e = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$e = { class: "card card-shadow" };
	const _hoisted_4$e = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_5$e = { class: "card-body" };
	const _hoisted_6$e = { id: "table_asset" };
	const _hoisted_7$d = { class: "d-flex align-items-center justify-content-end mb-2" };
	const _hoisted_8$c = ["title"];
	const _hoisted_9$a = /*#__PURE__*/createBaseVNode("i", { class: "text-danger fa-solid fa-triangle-exclamation" }, null, -1 /* HOISTED */);
	const _hoisted_10$7 = [
	  _hoisted_9$a
	];
	const _hoisted_11$7 = { class: "d-flex ms-auto" };
	const _hoisted_12$6 = { class: "m-1" };
	const _hoisted_13$5 = /*#__PURE__*/createBaseVNode("button", {
	  type: "button",
	  id: "reload-graph",
	  class: "btn btn-link btn-reload-graph"
	}, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
	], -1 /* HOISTED */);
	const _hoisted_14$4 = /*#__PURE__*/createBaseVNode("button", {
	  type: "button",
	  id: "autolayout",
	  class: "btn btn-link btn-stabilize"
	}, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-magic" })
	], -1 /* HOISTED */);
	const _hoisted_15$3 = { class: "card-footer" };
	const _hoisted_16$3 = {
	  type: "button",
	  id: "btn-delete-all",
	  class: "btn btn-danger me-1"
	};
	const _hoisted_17$3 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
	const _hoisted_18$3 = ["href"];
	const _hoisted_19$3 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
	const _hoisted_20$3 = [
	  _hoisted_19$3
	];

	function render$9(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_select_search = resolveComponent("select-search");
	  const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
	  const _component_modal_autolayout_confirm = resolveComponent("modal-autolayout-confirm");
	  const _component_network_map = resolveComponent("network-map");

	  return (openBlock(), createElementBlock("div", _hoisted_1$f, [
	    createBaseVNode("div", _hoisted_2$e, [
	      createBaseVNode("div", _hoisted_3$e, [
	        _hoisted_4$e,
	        createBaseVNode("div", _hoisted_5$e, [
	          createBaseVNode("div", _hoisted_6$e, [
	            createBaseVNode("div", _hoisted_7$d, [
	              createBaseVNode("button", {
	                id: "max-entries-reached",
	                type: "button",
	                class: "btn btn-link",
	                title: $data.max_entry_title,
	                disabled: "",
	                hidden: ""
	              }, _hoisted_10$7, 8 /* PROPS */, _hoisted_8$c),
	              createBaseVNode("div", _hoisted_11$7, [
	                (openBlock(true), createElementBlock(Fragment, null, renderList($data.filter_list, (_, index) => {
	                  return (openBlock(), createElementBlock("div", _hoisted_12$6, [
	                    createVNode(_component_select_search, {
	                      selected_option: $data.active_filter_list[index],
	                      "onUpdate:selected_option": $event => (($data.active_filter_list[index]) = $event),
	                      options: $data.filter_list[index],
	                      onSelect_option: $options.click_item
	                    }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options", "onSelect_option"])
	                  ]))
	                }), 256 /* UNKEYED_FRAGMENT */))
	              ]),
	              _hoisted_13$5,
	              _hoisted_14$4
	            ]),
	            createVNode(_component_modal_delete_confirm, {
	              ref: "modal_delete_all",
	              title: $data.title_delete,
	              body: $data.body_delete,
	              onDelete: $options.delete_all
	            }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
	            createVNode(_component_modal_autolayout_confirm, {
	              ref: "modal_autolayout",
	              title: $data.title_autolayout,
	              body: $data.body_autolayout,
	              onAutolayout: $options.reload_map
	            }, null, 8 /* PROPS */, ["title", "body", "onAutolayout"]),
	            createVNode(_component_network_map, {
	              ref: "asset_map",
	              empty_message: $data.no_services_message,
	              event_listeners: $data.event_listeners,
	              page_csrf: $props.page_csrf,
	              url: $data.get_url,
	              url_params: $props.url_params,
	              map_id: $props.map_id
	            }, null, 8 /* PROPS */, ["empty_message", "event_listeners", "page_csrf", "url", "url_params", "map_id"])
	          ])
	        ]),
	        createBaseVNode("div", _hoisted_15$3, [
	          createBaseVNode("button", _hoisted_16$3, [
	            _hoisted_17$3,
	            createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
	          ]),
	          createBaseVNode("a", {
	            href: $data.download_url,
	            class: "btn btn-primary",
	            role: "button",
	            "aria-disabled": "true",
	            download: "asset_map.json",
	            target: "_blank"
	          }, _hoisted_20$3, 8 /* PROPS */, _hoisted_18$3)
	        ])
	      ])
	    ])
	  ]))
	}

	script$g.render = render$9;
	script$g.__file = "http_src/vue/page-asset-map.vue";

	var script$f = defineComponent({
	    components: {
	    },
	    props: {
		id: String,
		main_title: Object,
	  secondary_title_list: Array,
		help_link: String,
		items_table: Array,
	    },
	    emits: ["click_item"],
	    /** This method is the first method of the component called, it's called before html template creation. */
	    created() {
	      },
	    data() {
		return {
		    //i18n: (t) => i18n(t),
		};
	    },
	    /** This method is the first method called after html template creation. */
	    mounted() {
		ntopng_sync.ready(this.$props["id"]);
	    },
	    methods: {
	    },
	});

	const _hoisted_1$e = { class: "navbar navbar-shadow navbar-expand-lg navbar-light bg-light px-2 mb-2" };
	const _hoisted_2$d = {
	  class: "me-1 text-nowrap",
	  style: {"font-size":"1.1rem"}
	};
	const _hoisted_3$d = ["href", "title"];
	const _hoisted_4$d = ["title"];
	const _hoisted_5$d = /*#__PURE__*/createTextVNode(" / ");
	const _hoisted_6$d = ["href", "title"];
	const _hoisted_7$c = ["title"];
	const _hoisted_8$b = /*#__PURE__*/createBaseVNode("span", { class: "text-muted ms-1 d-none d-lg-inline d-md-none" }, "|", -1 /* HOISTED */);
	const _hoisted_9$9 = /*#__PURE__*/createBaseVNode("button", {
	  class: "navbar-toggler",
	  type: "button"
	}, [
	  /*#__PURE__*/createBaseVNode("span", { class: "navbar-toggler-icon" })
	], -1 /* HOISTED */);
	const _hoisted_10$6 = {
	  class: "collapse navbar-collapse scroll-x",
	  id: "navbarNav"
	};
	const _hoisted_11$6 = { class: "navbar-nav" };
	const _hoisted_12$5 = ["onClick"];
	const _hoisted_13$4 = {
	  key: 0,
	  class: "badge rounded-pill bg-dark",
	  style: {"float":"right","margin-bottom":"-10px"}
	};
	const _hoisted_14$3 = ["onClick"];
	const _hoisted_15$2 = {
	  key: 0,
	  class: "badge rounded-pill bg-dark",
	  style: {"float":"right","margin-bottom":"-10px"}
	};
	const _hoisted_16$2 = { class: "navbar-nav ms-auto" };
	const _hoisted_17$2 = /*#__PURE__*/createBaseVNode("a", {
	  href: "javascript:history.back()",
	  class: "nav-item nav-link text-muted"
	}, [
	  /*#__PURE__*/createBaseVNode("i", { class: "fas fa-arrow-left" })
	], -1 /* HOISTED */);
	const _hoisted_18$2 = ["href"];
	const _hoisted_19$2 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-question-circle" }, null, -1 /* HOISTED */);
	const _hoisted_20$2 = [
	  _hoisted_19$2
	];

	function render$8(_ctx, _cache, $props, $setup, $data, $options) {
	  return (openBlock(), createElementBlock("nav", _hoisted_1$e, [
	    createBaseVNode("span", _hoisted_2$d, [
	      createBaseVNode("i", {
	        class: normalizeClass(_ctx.main_title.icon)
	      }, null, 2 /* CLASS */),
	      (_ctx.main_title.href)
	        ? (openBlock(), createElementBlock("a", {
	            key: 0,
	            href: _ctx.main_title.href,
	            title: _ctx.main_title.title
	          }, toDisplayString(_ctx.main_title.label), 9 /* TEXT, PROPS */, _hoisted_3$d))
	        : (openBlock(), createElementBlock("span", {
	            key: 1,
	            title: _ctx.main_title.title
	          }, toDisplayString(_ctx.main_title.label), 9 /* TEXT, PROPS */, _hoisted_4$d)),
	      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.secondary_title_list, (item) => {
	        return (openBlock(), createElementBlock(Fragment, null, [
	          _hoisted_5$d,
	          (item.href)
	            ? (openBlock(), createElementBlock("a", {
	                key: 0,
	                href: item.href,
	                title: item.title
	              }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_6$d))
	            : (openBlock(), createElementBlock("span", {
	                key: 1,
	                title: item.title
	              }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_7$c))
	        ], 64 /* STABLE_FRAGMENT */))
	      }), 256 /* UNKEYED_FRAGMENT */))
	    ]),
	    _hoisted_8$b,
	    _hoisted_9$9,
	    createBaseVNode("div", _hoisted_10$6, [
	      createBaseVNode("ul", _hoisted_11$6, [
	        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items_table, (item) => {
	          return (openBlock(), createElementBlock(Fragment, null, [
	            (item.active)
	              ? (openBlock(), createElementBlock("li", {
	                  key: 0,
	                  onClick: $event => (this.$emit('click_item', item)),
	                  class: normalizeClass([{ 'active': item.active }, "nav-item nav-link"])
	                }, [
	                  (item.badge_num > 0)
	                    ? (openBlock(), createElementBlock("span", _hoisted_13$4, toDisplayString(item.badge_num), 1 /* TEXT */))
	                    : createCommentVNode("v-if", true),
	                  createBaseVNode("b", null, [
	                    createBaseVNode("i", {
	                      class: normalizeClass(item.icon)
	                    }, null, 2 /* CLASS */),
	                    createTextVNode(" " + toDisplayString(item.label), 1 /* TEXT */)
	                  ])
	                ], 10 /* CLASS, PROPS */, _hoisted_12$5))
	              : (openBlock(), createElementBlock("a", {
	                  key: 1,
	                  onClick: $event => (this.$emit('click_item', item)),
	                  href: "#",
	                  class: "nav-item nav-link"
	                }, [
	                  (item.badge_num > 0)
	                    ? (openBlock(), createElementBlock("span", _hoisted_15$2, toDisplayString(item.badge_num), 1 /* TEXT */))
	                    : createCommentVNode("v-if", true),
	                  createBaseVNode("i", {
	                    class: normalizeClass(item.icon)
	                  }, null, 2 /* CLASS */),
	                  createTextVNode(" " + toDisplayString(item.label), 1 /* TEXT */)
	                ], 8 /* PROPS */, _hoisted_14$3))
	          ], 64 /* STABLE_FRAGMENT */))
	        }), 256 /* UNKEYED_FRAGMENT */))
	      ]),
	      createBaseVNode("ul", _hoisted_16$2, [
	        _hoisted_17$2,
	        createBaseVNode("a", {
	          target: "_newtab",
	          href: _ctx.help_link,
	          class: "nav-item nav-link text-muted"
	        }, _hoisted_20$2, 8 /* PROPS */, _hoisted_18$2)
	      ])
	    ])
	  ]))
	}

	script$f.render = render$8;
	script$f.__file = "http_src/vue/page-navbar.vue";

	const _hoisted_1$d = { class: "form-group mb-3 row" };
	const _hoisted_2$c = { class: "col-form-label col-sm-4" };
	const _hoisted_3$c = { class: "col-sm-7" };
	const _hoisted_4$c = /*#__PURE__*/createBaseVNode("div", { class: "invalid-feedback" }, null, -1 /* HOISTED */);
	const _hoisted_5$c = { class: "form-group mb-3 row" };
	const _hoisted_6$c = { class: "col-form-label col-sm-4 pt-2" };
	const _hoisted_7$b = { class: "form-switch col-sm-7 pt-2 ps-3" };
	const _hoisted_8$a = { class: "col-form-label" };


	var script$e = {
	  __name: 'modal-add-device-exclusion',
	  props: {
	    body: String,
	    title: String,
	    footer: String,
	    list_notes: String,
	},
	  emits: ['add'],
	  setup(__props, { expose, emit }) {

	const input_mac_list = ref("");
	const input_trigger_alerts = ref("");

	const modal_id = ref(null);


	const showed = () => {};



	const show = () => {
	    input_mac_list.value = "";
	    modal_id.value.show();
	};

	const add_ = () => {
	    emit('add', { mac_list: input_mac_list.value, trigger_alerts: input_trigger_alerts.value });
	    close();
	};

	const close = () => {
	    modal_id.value.close();
	};


	expose({ show, close });

	onMounted(() => {
	});

	const _i18n = (t) => i18n(t);


	return (_ctx, _cache) => {
	  return (openBlock(), createBlock(script$y, {
	    onShowed: _cache[2] || (_cache[2] = $event => (showed())),
	    ref_key: "modal_id",
	    ref: modal_id
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
	    ]),
	    body: withCtx(() => [
	      createBaseVNode("div", _hoisted_1$d, [
	        createBaseVNode("label", _hoisted_2$c, toDisplayString(__props.body), 1 /* TEXT */),
	        createBaseVNode("div", _hoisted_3$c, [
	          withDirectives(createBaseVNode("textarea", {
	            name: "items-list",
	            id: "itemslist-textarea",
	            class: "w-100 form-control",
	            rows: "6",
	            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((input_mac_list).value = $event))
	          }, null, 512 /* NEED_PATCH */), [
	            [vModelText, input_mac_list.value]
	          ]),
	          createBaseVNode("small", null, toDisplayString(__props.list_notes), 1 /* TEXT */),
	          _hoisted_4$c
	        ])
	      ]),
	      createBaseVNode("div", _hoisted_5$c, [
	        createBaseVNode("label", _hoisted_6$c, toDisplayString(_i18n('edit_check.trigger_device_disconnected_alert')), 1 /* TEXT */),
	        createBaseVNode("div", _hoisted_7$b, [
	          withDirectives(createBaseVNode("input", {
	            type: "checkbox",
	            class: "form-check-input ms-0",
	            "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((input_trigger_alerts).value = $event))
	          }, null, 512 /* NEED_PATCH */), [
	            [vModelCheckbox, input_trigger_alerts.value]
	          ])
	        ]),
	        createBaseVNode("small", _hoisted_8$a, toDisplayString(_i18n('edit_check.trigger_device_disconnected_alert_descr')), 1 /* TEXT */)
	      ])
	    ]),
	    footer: withCtx(() => [
	      createTextVNode(toDisplayString(_i18n('host_details.notes')) + ": " + toDisplayString(__props.footer) + " ", 1 /* TEXT */),
	      createBaseVNode("button", {
	        type: "button",
	        onClick: add_,
	        class: "btn btn-primary"
	      }, toDisplayString(_i18n('add')), 1 /* TEXT */)
	    ]),
	    _: 1 /* STABLE */
	  }, 512 /* NEED_PATCH */))
	}
	}

	};

	script$e.__file = "http_src/vue/modal-add-device-exclusion.vue";

	const _hoisted_1$c = { class: "form-group mb-3 row" };
	const _hoisted_2$b = { class: "col-form-label col-sm-4" };
	const _hoisted_3$b = { class: "col-sm-7" };
	const _hoisted_4$b = { class: "form-group mb-3 row" };
	const _hoisted_5$b = { class: "col-form-label col-sm-4" };
	const _hoisted_6$b = { class: "col-sm-7" };
	const _hoisted_7$a = { value: "allowed" };
	const _hoisted_8$9 = { value: "denied" };
	const _hoisted_9$8 = { class: "form-group mb-3 row" };
	const _hoisted_10$5 = { class: "col-form-label col-sm-4 pt-2" };
	const _hoisted_11$5 = { class: "form-switch col-sm-7 pt-2 ps-3" };
	const _hoisted_12$4 = { class: "col-form-label" };


	var script$d = {
	  __name: 'modal-edit-device-exclusion',
	  props: {
	    title: String,
	},
	  emits: ['edit'],
	  setup(__props, { expose, emit }) {

	const input_mac_address_name = ref("");
	const input_device_status = ref("");
	const input_trigger_alerts = ref("");

	const modal_id = ref(null);


	const showed = () => {};



	const show = (row) => {
	    input_device_status.value = row.status;
	    input_mac_address_name.value = row.mac_address_label.label;
	    input_trigger_alerts.value = row.trigger_alert || false;
	    modal_id.value.show();
	};

	const edit_ = () => {
	    emit('edit', { mac_alias: input_mac_address_name.value, mac_status: input_device_status.value, trigger_alerts: input_trigger_alerts.value });
	    close();
	};

	const close = () => {
	    modal_id.value.close();
	};


	expose({ show, close });

	onMounted(() => {
	});

	const _i18n = (t) => i18n(t);


	return (_ctx, _cache) => {
	  return (openBlock(), createBlock(script$y, {
	    onShowed: _cache[3] || (_cache[3] = $event => (showed())),
	    ref_key: "modal_id",
	    ref: modal_id
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
	    ]),
	    body: withCtx(() => [
	      createBaseVNode("div", _hoisted_1$c, [
	        createBaseVNode("label", _hoisted_2$b, toDisplayString(_i18n('edit_check.device_alias')), 1 /* TEXT */),
	        createBaseVNode("div", _hoisted_3$b, [
	          withDirectives(createBaseVNode("input", {
	            type: "text",
	            name: "custom_name",
	            class: "form-control",
	            placeholder: "{{_i18n('custom_name')}}",
	            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((input_mac_address_name).value = $event))
	          }, null, 512 /* NEED_PATCH */), [
	            [vModelText, input_mac_address_name.value]
	          ])
	        ])
	      ]),
	      createBaseVNode("div", _hoisted_4$b, [
	        createBaseVNode("label", _hoisted_5$b, toDisplayString(_i18n('edit_check.device_status')), 1 /* TEXT */),
	        createBaseVNode("div", _hoisted_6$b, [
	          withDirectives(createBaseVNode("select", {
	            name: "device_status",
	            class: "form-select",
	            "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((input_device_status).value = $event))
	          }, [
	            createBaseVNode("option", _hoisted_7$a, toDisplayString(_i18n('allowed')), 1 /* TEXT */),
	            createBaseVNode("option", _hoisted_8$9, toDisplayString(_i18n('denied')), 1 /* TEXT */)
	          ], 512 /* NEED_PATCH */), [
	            [vModelSelect, input_device_status.value]
	          ])
	        ])
	      ]),
	      createBaseVNode("div", _hoisted_9$8, [
	        createBaseVNode("label", _hoisted_10$5, toDisplayString(_i18n('edit_check.trigger_device_disconnected_alert')), 1 /* TEXT */),
	        createBaseVNode("div", _hoisted_11$5, [
	          withDirectives(createBaseVNode("input", {
	            type: "checkbox",
	            class: "form-check-input ms-0",
	            "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((input_trigger_alerts).value = $event))
	          }, null, 512 /* NEED_PATCH */), [
	            [vModelCheckbox, input_trigger_alerts.value]
	          ])
	        ]),
	        createBaseVNode("small", _hoisted_12$4, toDisplayString(_i18n('edit_check.trigger_device_disconnected_alert_descr')), 1 /* TEXT */)
	      ])
	    ]),
	    footer: withCtx(() => [
	      createBaseVNode("button", {
	        type: "button",
	        onClick: edit_,
	        class: "btn btn-primary"
	      }, toDisplayString(_i18n('edit')), 1 /* TEXT */)
	    ]),
	    _: 1 /* STABLE */
	  }, 512 /* NEED_PATCH */))
	}
	}

	};

	script$d.__file = "http_src/vue/modal-edit-device-exclusion.vue";

	var script$c = {
	    components: {	  
	        'page-navbar': script$f,	      
	        'datatable': script$s,
	        'modal-delete-confirm': script$o,
	        'modal-add-device-exclusion': script$e,
	        'modal-edit-device-exclusion': script$d,
	    },
	    props: {
		page_csrf: String,
		is_clickhouse_enabled: Boolean,
	    },
	    /**
	     * First method called when the component is created.
	     */
	    created() {
		start_datatable$3(this);
	    },
	    mounted() {
	      this.learning_status();
	      $("#btn-delete-all-devices").click(() => this.show_delete_all_dialog());
	    },    
	    data() {
		return {
		    i18n: (t) => i18n(t),
		    config_devices: null,
	            navbar_context: {
			main_title: {
	      label: i18n("edit_check.device_exclusion_list"),
	      icon: "fas fa-bell-slash",
	    },
			base_url: "#",
			// help_link: "https://www.ntop.org/guides/ntopng/web_gui/checks.html",
			items_table: [
			    { active: true, label: i18n('devices'), id: "devices" },
			],
	            },
		    
	            title_delete: '',
	            body_delete: '',
	            title_delete_all: i18n('edit_check.delete_all_device_exclusions'),
	            body_delete_all: i18n('edit_check.delete_all_device_exclusions_message'),
	            title_add: i18n('edit_check.add_device_exclusion'),
	            body_add: i18n('edit_check.add_device_exclusion_message'),
	            footer_add: i18n('edit_check.add_device_exclusion_notes'),
	            list_notes_add: i18n('edit_check.add_device_exclusion_list_notes'),
	            title_edit: i18n('edit_check.edit_device_exclusion'),
	            learning_message: i18n('edit_check.learning'),
	            row_to_delete: null,
	            row_to_edit: null,
	        };
	    },
	    methods: {
	        add_device: async function(params) {
	          params.mac_list = params.mac_list.replace(/(?:\t| )/g,'');
	          params.mac_list = params.mac_list.replace(/(?:\r\n|\r|\n)/g, ',');
	          params.csrf = this.$props.page_csrf;
	          let url = `${http_prefix}/lua/pro/rest/v2/add/device/exclusion.lua`;
	          try {
	            let headers = {
	              'Content-Type': 'application/json'
	            };
	            await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	            this.reload_table();
	          } catch(err) {
	            console.error(err);
	          }
	        },
	        delete_all: async function() {
	          let url = `${http_prefix}/lua/pro/rest/v2/delete/device/exclusion.lua`;
	          let params = {
	            device: 'all',
	            csrf: this.$props.page_csrf,
	          };
	          try {
	            let headers = {
	              'Content-Type': 'application/json'
	            };
	            await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	            this.reload_table();
	          } catch(err) {
	            console.error(err);
	          }      
	        },
	        delete_row: async function() {      
	          let row = this.row_to_delete;
	          let params = { device: row.mac_address, csrf: this.$props.page_csrf };
	          let url = `${http_prefix}/lua/pro/rest/v2/delete/device/exclusion.lua`;
	          try {
	            let headers = {
	              'Content-Type': 'application/json'
	            };
	            await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	            setTimeout(() => this.reload_table(), 300);
	          } catch(err) {
	            console.error(err);
	          }
	        },
	        edit_row: async function(params) {    
	          let row = this.row_to_edit;
	          params.mac_alias = params.mac_alias.replace(/(?:\t| )/g,'');   
	          params.csrf = this.$props.page_csrf;
	          params.mac = row.mac_address;
	          let url = `${http_prefix}/lua/pro/rest/v2/edit/device/exclusion.lua`;
	          try {
	            let headers = {
	              'Content-Type': 'application/json'
	            };
	            await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
	            setTimeout(() => this.reload_table(), 300);
	          } catch(err) {
	            console.error(err);
	          }
	        },
	        learning_status: async function() {
	          let url = `${http_prefix}/lua/pro/rest/v2/get/device/learning_status.lua`;
	          try {
	            let headers = {
	              'Content-Type': 'application/json'
	            };
	            const rsp = await ntopng_utility.http_request(url, { method: 'get', headers });
	            if(rsp.learning_done) {
	              $(`#devices-learning-status`).attr('hidden', 'hidden');
	            } else {
	              $(`#devices-learning-status`).removeAttr('hidden');  
	            }
	          } catch(err) {
	            console.error(err);
	          }      
	        },
	        reload_table: function() {
	          let table = this.get_active_table();
	          table.reload();
	          this.learning_status();
	        },
	        get_active_table: function() {
	          return this.$refs[`table_devices_exclusion`];
	        },
	        show_add_device_dialog: function() {
	          this.$refs["modal_add_device"].show();
	        },
	        show_edit_device_dialog: function(row) {
	          this.row_to_edit = row;
	          this.$refs["modal_edit_device"].show(row);
	        },
	        show_delete_all_dialog: function() {
	          this.$refs["modal_delete_all"].show();
	        },
	        show_delete_dialog: function(title, body, row) {
	          this.row_to_delete = row;
	          this.title_delete = title;
	          this.body_delete = body;
	          this.$refs["modal_delete_confirm"].show();
	        }
	      },
	    };  

	    function start_datatable$3(DatatableVue) {
	    const datatableButton = [];

	    /* Manage the buttons close to the search box */
	    datatableButton.push({
	      text: '<i class="fas fa-plus"></i>',
	      className: 'btn-link',
	      action: function (e, dt, node, config) {
	        DatatableVue.show_add_device_dialog();
	      }
	    });

	      datatableButton.push({
	      text: '<i class="fas fa-sync"></i>',
	      className: 'btn-link',
	      action: function (e, dt, node, config) {
	        DatatableVue.reload_table();
	      }
	    });

	    let defaultDatatableConfig = {
	      table_buttons: datatableButton,
	      columns_config: [],
	      data_url: `${http_prefix}/lua/pro/rest/v2/get/device/exclusion.lua`,
	      enable_search: true,
	    };

	    let configDevices = ntopng_utility.clone(defaultDatatableConfig);
	    configDevices.table_buttons = defaultDatatableConfig.table_buttons;
	    configDevices.data_url = `${configDevices.data_url}`;
	    configDevices.columns_config = [
	      {
	        sortable: false,
	        searchable: false,
	        visible: false,
	        data: 'mac_address',
	        type: 'mac-address',
	        responsivePriority: 1,
	      }, {
	        columnName: i18n('edit_check.excluded_device'),
	        data: 'mac_address_label',
	        type: 'mac-address',
	        className: 'text-nowrap',
	        sortable: true,
	        searchable: true,
	        createdCell: DataTableRenders.applyCellStyle,
	        responsivePriority: 1,
	        render: function(rowData, type, script) {
	          let label = rowData.label;
	          if(rowData.label !== rowData.mac)
	            label = label + ' [' + rowData.mac + ']';

	          if(rowData.url)
	            label = `<a href='${rowData.url}' title='${rowData.mac}'>${label}</a>`;

	          return label
	        }
	      }, {
	        columnName: i18n('first_seen'),
	        data: 'first_seen',
	        type: 'time',
	        sortable: true,
	        searchable: true,
	        className: 'text-nowrap text-center',
	        responsivePriority: 1,
	        render: function(rowData, type, script) {
	          return rowData.data
	        }
	      }, {
	        columnName: i18n('last_seen'),
	        data: 'last_seen',
	        type: 'time',
	        sortable: true,
	        searchable: true,
	        className: 'text-nowrap text-center',
	        responsivePriority: 1,
	        render: function(rowData, type, script) {
	          return rowData.data
	        }
	      }, {
	        columnName: i18n('edit_check.device_status'),
	        data: 'status',
	        type: 'status',
	        sortable: true,
	        searchable: true,
	        className: 'text-nowrap text-center',
	        responsivePriority: 1,
	        render: function(rowData, type, script) {
	          return i18n(rowData)
	        }
	      }, {
	        columnName: i18n('edit_check.trigger_alert'),
	        data: 'trigger_alert',
	        type: 'boolean',
	        sortable: true,
	        searchable: true,
	        className: 'text-nowrap text-center',
	        responsivePriority: 1,
	        render: function(rowData, type, script) {
	          return rowData ? `<i class="fas fa-check text-success"></i>` : `<i class="fas fa-times text-danger"></i>`
	        }
	      }, {
	        targets: -1,
	        columnName: i18n("action"),
	        data: null,
	        name: 'actions',
	        className: 'text-center text-nowrap',
	        sortable: false,
	        responsivePriority: 1,
	        render: function (rowData, type, script) {
	          let delete_handler = {
	            handlerId: "delete_device",	  
	            onClick: () => {
	              let body = `${i18n('edit_check.delete_device_exclusion')} ${rowData.mac_address_label.label}`;
	              DatatableVue.show_delete_dialog(i18n('edit_check.device_exclusion'), body, rowData);
	            },
	          };
	          let edit_handler = {
	            handlerId: "edit_device",	  
	            onClick: () => {
	              DatatableVue.show_edit_device_dialog(rowData);
	            },
	          };
	          let jump_to_historical_flow = {
	            onClick: () => {
	              const url = `${http_prefix}/lua/pro/db_search.lua?epoch_begin=${rowData.first_seen.timestamp}&epoch_end=${rowData.last_seen.timestamp}&mac=${rowData.mac_address};eq`;
	              window.open(url, '_blank');
	            },
	          };
	          
	          return DataTableUtils.createActionButtons([
	            { class: `pointer`, handler: jump_to_historical_flow, icon: 'fa-stream', title: i18n('db_explorer.historical_data'), hidden: !isClickhouseEnabled },
	            { class: `btn-secondary`, handler: edit_handler, icon: 'fa-edit', title: i18n('edit'), class: "pointer" },
	            { class: `btn-danger`, handler: delete_handler, icon: 'fa-trash', title: i18n('delete'), class: "pointer" },
	          ]);
	        },
	      }
	    ];
	    DatatableVue.config_devices = configDevices;
	}

	const _hoisted_1$b = { id: "navbar" };
	const _hoisted_2$a = { class: "row" };
	const _hoisted_3$a = { class: "col-md-12 col-lg-12" };
	const _hoisted_4$a = /*#__PURE__*/createBaseVNode("div", {
	  class: "alert alert-danger d-none",
	  id: "alert-row-buttons",
	  role: "alert"
	}, null, -1 /* HOISTED */);
	const _hoisted_5$a = { class: "card" };
	const _hoisted_6$a = { class: "card-body" };
	const _hoisted_7$9 = {
	  id: "devices-learning-status",
	  class: "alert alert-info",
	  hidden: ""
	};
	const _hoisted_8$8 = { id: "table_devices_vue" };
	const _hoisted_9$7 = { class: "card-footer" };
	const _hoisted_10$4 = {
	  type: "button",
	  id: "btn-delete-all-devices",
	  class: "btn btn-danger"
	};
	const _hoisted_11$4 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);

	function render$7(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_page_navbar = resolveComponent("page-navbar");
	  const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
	  const _component_modal_add_device_exclusion = resolveComponent("modal-add-device-exclusion");
	  const _component_modal_edit_device_exclusion = resolveComponent("modal-edit-device-exclusion");
	  const _component_datatable = resolveComponent("datatable");

	  return (openBlock(), createElementBlock(Fragment, null, [
	    createBaseVNode("div", _hoisted_1$b, [
	      createVNode(_component_page_navbar, {
	        id: "page_navbar",
	        main_title: $data.navbar_context.main_title,
	        base_url: $data.navbar_context.base_url,
	        help_link: $data.navbar_context.help_link,
	        items_table: $data.navbar_context.items_table,
	        onClick_item: _ctx.click_item
	      }, null, 8 /* PROPS */, ["main_title", "base_url", "help_link", "items_table", "onClick_item"])
	    ]),
	    createBaseVNode("div", _hoisted_2$a, [
	      createBaseVNode("div", _hoisted_3$a, [
	        _hoisted_4$a,
	        createBaseVNode("div", _hoisted_5$a, [
	          createBaseVNode("div", _hoisted_6$a, [
	            createBaseVNode("div", _hoisted_7$9, toDisplayString($data.learning_message), 1 /* TEXT */),
	            createBaseVNode("div", _hoisted_8$8, [
	              createVNode(_component_modal_delete_confirm, {
	                ref: "modal_delete_confirm",
	                title: $data.title_delete,
	                body: $data.body_delete,
	                onDelete: $options.delete_row
	              }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
	              createVNode(_component_modal_delete_confirm, {
	                ref: "modal_delete_all",
	                title: $data.title_delete_all,
	                body: $data.body_delete_all,
	                onDelete: $options.delete_all
	              }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
	              createVNode(_component_modal_add_device_exclusion, {
	                ref: "modal_add_device",
	                title: $data.title_add,
	                body: $data.body_add,
	                footer: $data.footer_add,
	                list_notes: $data.list_notes_add,
	                onAdd: $options.add_device
	              }, null, 8 /* PROPS */, ["title", "body", "footer", "list_notes", "onAdd"]),
	              createVNode(_component_modal_edit_device_exclusion, {
	                ref: "modal_edit_device",
	                title: $data.title_edit,
	                onEdit: $options.edit_row
	              }, null, 8 /* PROPS */, ["title", "onEdit"]),
	              createVNode(_component_datatable, {
	                ref: "table_devices_exclusion",
	                table_buttons: $data.config_devices.table_buttons,
	                columns_config: $data.config_devices.columns_config,
	                data_url: $data.config_devices.data_url,
	                enable_search: $data.config_devices.enable_search
	              }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search"])
	            ])
	          ]),
	          createBaseVNode("div", _hoisted_9$7, [
	            createBaseVNode("button", _hoisted_10$4, [
	              _hoisted_11$4,
	              createTextVNode(" " + toDisplayString($data.i18n("edit_check.delete_all_device_exclusions")), 1 /* TEXT */)
	            ])
	          ])
	        ])
	      ])
	    ])
	  ], 64 /* STABLE_FRAGMENT */))
	}

	script$c.render = render$7;
	script$c.__file = "http_src/vue/page-device-exclusions.vue";

	var script$b = {
	  components: {	  
	    'datatable': script$s,
	  },
	  props: {
	    page_csrf: String,
	    url_params: Object,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    start_datatable$2(this);
	  },
	  mounted() {},    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      config_devices_standard: null,
	      config_devices_centrality: null,
	    };
	  },
	  methods: { 
	    /* Method used to switch active table tab */
	    reload_table: function() {
	      let table = this.get_active_table();
	      table.reload();
	    },
	    get_active_table: function() {
	      return this.$refs[`table_fingerprint`];
	    },
	  },
	};  

	function start_datatable$2(DatatableVue) {
	  const datatableButton = [];
	  let columns = [];
	  let default_sorting_columns = 3 /* Contacts column */;
	  
	  /* Manage the buttons close to the search box */
	  datatableButton.push({
	    text: '<i class="fas fa-sync"></i>',
	    className: 'btn-link',
	    action: function (e, dt, node, config) {
	      DatatableVue.reload_table();
	    }
	  });
	  
	  let defaultDatatableConfig = {
	    table_buttons: datatableButton,
	    columns_config: [],
	    data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/fingerprint/data.lua`, url_params),
	    enable_search: true,
	  };

	  /* Standard table configuration */  

	  columns = [
	    { columnName: i18n("ja3_client_fingerprint"), name: 'ja3', data: 'ja3', className: 'text-nowrap', render: (data, type) => {
	        return `<a class="ntopng-external-link" href="https://sslbl.abuse.ch/ja3-fingerprints/${data}">${data} <i class="fas fa-external-link-alt"></i></a>`;
	      }, responsivePriority: 0, createdCell: DataTableRenders.applyCellStyle },
	    { columnName: i18n("status"), name: 'is_malicious', data: 'is_malicious', className: 'text-nowrap text-center', responsivePriority: 0, render: (data, type) => {
	        return (data ? `<i class="fa-solid fa-face-frown text-danger" title="${i18n('malicious')}"></i>` : `<i class="fa-solid fa-face-smile text-success" title="${i18n('ok')}"></i>`);
	      }
	    },
	    { columnName: i18n("app_name"), name: 'app_name', data: 'app_name', className: 'text-nowrap text-right', responsivePriority: 1 },
	    { columnName: i18n("num_uses"), name: 'num_uses', data: 'num_uses', className: 'text-nowrap text-right', responsivePriority: 1, render: (data) => { return NtopUtils.formatValue(data); } },
	  ];

	  /* Extra table configuration */
	  let table_config = {
	    serverSide: false,
	    order: [[ default_sorting_columns, 'desc' ]]
	  };
	  
	  let configDevices = ntopng_utility.clone(defaultDatatableConfig);
	  configDevices.table_buttons = defaultDatatableConfig.table_buttons;
	  configDevices.data_url = `${configDevices.data_url}`;
	  configDevices.columns_config = columns;
	  configDevices.table_config = ntopng_utility.clone(table_config);
	  DatatableVue.config_devices_standard = configDevices;
	}

	const _hoisted_1$a = { class: "row" };
	const _hoisted_2$9 = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$9 = /*#__PURE__*/createBaseVNode("div", {
	  class: "alert alert-danger d-none",
	  id: "alert-row-buttons",
	  role: "alert"
	}, null, -1 /* HOISTED */);
	const _hoisted_4$9 = { class: "card" };
	const _hoisted_5$9 = { class: "card-body" };
	const _hoisted_6$9 = { id: "table_host_tls" };
	const _hoisted_7$8 = { class: "card-footer" };

	function render$6(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_datatable = resolveComponent("datatable");

	  return (openBlock(), createElementBlock("div", _hoisted_1$a, [
	    createBaseVNode("div", _hoisted_2$9, [
	      _hoisted_3$9,
	      createBaseVNode("div", _hoisted_4$9, [
	        createBaseVNode("div", _hoisted_5$9, [
	          createBaseVNode("div", _hoisted_6$9, [
	            createVNode(_component_datatable, {
	              ref: "table_fingerprint",
	              table_buttons: $data.config_devices_standard.table_buttons,
	              columns_config: $data.config_devices_standard.columns_config,
	              data_url: $data.config_devices_standard.data_url,
	              enable_search: $data.config_devices_standard.enable_search,
	              table_config: $data.config_devices_standard.table_config
	            }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
	          ])
	        ]),
	        createBaseVNode("div", _hoisted_7$8, [
	          createBaseVNode("b", null, toDisplayString($data.i18n('fingerprint_note')), 1 /* TEXT */)
	        ])
	      ])
	    ])
	  ]))
	}

	script$b.render = render$6;
	script$b.__file = "http_src/vue/page-host-tls.vue";

	var script$a = {
	  components: {	  
	    'datatable': script$s,
	  },
	  props: {
	    page_csrf: String,
	    url_params: Object,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    start_datatable$1(this);
	  },
	  mounted() {},    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      config_devices_standard: null,
	      config_devices_centrality: null,
	    };
	  },
	  methods: { 
	    /* Method used to switch active table tab */
	    reload_table: function() {
	      let table = this.get_active_table();
	      table.reload();
	    },
	    get_active_table: function() {
	      return this.$refs[`table_hassh`];
	    },
	  },
	};  

	function start_datatable$1(DatatableVue) {
	  const datatableButton = [];
	  let columns = [];
	  let default_sorting_columns = 3 /* Contacts column */;
	  
	  /* Manage the buttons close to the search box */
	  datatableButton.push({
	    text: '<i class="fas fa-sync"></i>',
	    className: 'btn-link',
	    action: function (e, dt, node, config) {
	      DatatableVue.reload_table();
	    }
	  });
	  
	  let defaultDatatableConfig = {
	    table_buttons: datatableButton,
	    columns_config: [],
	    data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/fingerprint/data.lua`, url_params),
	    enable_search: true,
	  };

	  /* Standard table configuration */  

	  columns = [
	    { columnName: i18n("hassh_fingerprint"), name: 'ja3', data: 'ja3', className: 'text-nowrap', render: (data, type) => {
	        return `<a class="ntopng-external-link" href="https://sslbl.abuse.ch/ja3-fingerprints/${data}">${data} <i class="fas fa-external-link-alt"></i></a>`;
	      }, responsivePriority: 0, createdCell: DataTableRenders.applyCellStyle },
	    { columnName: i18n("status"), name: 'is_malicious', data: 'is_malicious', className: 'text-nowrap text-center', responsivePriority: 0, render: (data, type) => {
	        return (data ? `<i class="fa-solid fa-face-frown text-danger" title="${i18n('malicious')}"></i>` : `<i class="fa-solid fa-face-smile text-success" title="${i18n('ok')}"></i>`);
	      }
	    },
	    { columnName: i18n("app_name"), name: 'app_name', data: 'app_name', className: 'text-nowrap text-right', responsivePriority: 1 },
	    { columnName: i18n("num_uses"), name: 'num_uses', data: 'num_uses', className: 'text-nowrap text-right', responsivePriority: 1, render: (data) => { return NtopUtils.formatValue(data); } },
	  ];

	  /* Extra table configuration */
	  let table_config = {
	    serverSide: false,
	    order: [[ default_sorting_columns, 'desc' ]]
	  };
	  
	  let configDevices = ntopng_utility.clone(defaultDatatableConfig);
	  configDevices.table_buttons = defaultDatatableConfig.table_buttons;
	  configDevices.data_url = `${configDevices.data_url}`;
	  configDevices.columns_config = columns;
	  configDevices.table_config = ntopng_utility.clone(table_config);
	  DatatableVue.config_devices_standard = configDevices;
	}

	const _hoisted_1$9 = { class: "row" };
	const _hoisted_2$8 = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$8 = /*#__PURE__*/createBaseVNode("div", {
	  class: "alert alert-danger d-none",
	  id: "alert-row-buttons",
	  role: "alert"
	}, null, -1 /* HOISTED */);
	const _hoisted_4$8 = { class: "card" };
	const _hoisted_5$8 = { class: "card-body" };
	const _hoisted_6$8 = { id: "table_host_ssh" };

	function render$5(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_datatable = resolveComponent("datatable");

	  return (openBlock(), createElementBlock("div", _hoisted_1$9, [
	    createBaseVNode("div", _hoisted_2$8, [
	      _hoisted_3$8,
	      createBaseVNode("div", _hoisted_4$8, [
	        createBaseVNode("div", _hoisted_5$8, [
	          createBaseVNode("div", _hoisted_6$8, [
	            createVNode(_component_datatable, {
	              ref: "table_hassh",
	              table_buttons: $data.config_devices_standard.table_buttons,
	              columns_config: $data.config_devices_standard.columns_config,
	              data_url: $data.config_devices_standard.data_url,
	              enable_search: $data.config_devices_standard.enable_search,
	              table_config: $data.config_devices_standard.table_config
	            }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
	          ])
	        ])
	      ])
	    ])
	  ]))
	}

	script$a.render = render$5;
	script$a.__file = "http_src/vue/page-host-ssh.vue";

	const change_map_event = "change_map_event";

	  var script$9 = {
	    components: {	  
	      'page-periodicity-map': script$h,
	      'page-periodicity-table': script$m,
	      'page-asset-map': script$g,
	      'page-asset-table': script$n,
	      'page-service-map': script$i,
	      'page-service-table': script$l,
	      'page-navbar': script$f,
	    },
	    props: {
	      page_csrf: String,
	      base_url_params: Object,
	      ifid: Number,
	      is_admin: Boolean,
	      map_id: String,
	      view: String,
	      navbar_info: Object,
	      service_acceptance: Array,
	      service_map_filter_list: Object,
	      service_table_filter_list: Array,
	      periodicity_map_filter_list: Object,
	      periodicity_table_filter_list: Array,
	      asset_map_filter_list: Object,
	      asset_table_filter_list: Array,
	    },
	    /**
	     * First method called when the component is created.
	     */
	    created() {
	      this.url_params = this.$props.base_url_params;
	      this.active_tab = this.$props.map_id;
	      this.page = this.url_params.page;
	      this.updated_view = this.$props.view;

	      if(asset_map_filter_list && asset_table_filter_list) {
	        this.navbar_context.items_table.push({ active: false, label: i18n('asset_map'), id: "asset_map", page: "graph" });
	        this.navbar_context.items_table.push({ active: false, label: i18n('asset_table'), id: "asset_map", page: "table" });
	      }

	      this.navbar_context.items_table.forEach((i) => {
	        (i.id == this.active_tab && i.page == this.page) ? i.active = true : i.active = false;
	      });
	    },
	    mounted() {
	      
	      const format_navbar = this.format_navbar_title;
	      format_navbar(this.$props.navbar_info);

	      ntopng_events_manager.on_custom_event("page_navbar", ntopng_custom_events.CHANGE_PAGE_TITLE, (node) => {
	        format_navbar({ selected_iface: this.$props.navbar_info.selected_iface, selected_host: node });
	      });

	      ntopng_events_manager.on_custom_event("change_service_table_tab", change_map_event, (tab) => {
	        ntopng_url_manager$1.set_key_to_url('map', tab.id);
	        ntopng_url_manager$1.set_key_to_url('page', tab.page);
	        if(tab.page == 'table')
	          this.destroy();
	        
	        this.active_tab = tab.id;
	        this.page = tab.page;
	        this.url_params.map = tab.id;
	        this.url_params.page = tab.page;
	        this.updated_view = ntopng_url_manager$1.get_url_entry('view');
	        format_navbar();
	     });
	    },    
	    data() {
	      return {
	        i18n: (t) => i18n(t),
	        active_tab: null,
	        page: null,
	        url_params: {},
	        updated_view: null,
	        navbar_node: {},
	        navbar_context: {
	          main_title: {
	            label: ' ' + i18n("maps"),
	            icon: "fas fa-map",
	          },
	          secondary_title_list: [],
	          items_table: [
	            { active: true, label: i18n('service_map'), id: "service_map", page: "graph" },
	            { active: false, label: i18n('service_table'), id: "service_map", page: "table" },
	            { active: false, label: i18n('periodicity_map'), id: "periodicity_map", page: "graph" },
	            { active: false, label: i18n('periodicity_table'), id: "periodicity_map", page: "table" },
	          ],
	        },
	      };
	    },
	    methods: { 
	      destroy: function() {
	        let current_tab = this.get_active_tab();
	        current_tab.destroy();
	      },
	      format_navbar_title: function(data) {
	        if(data) {
	          this.navbar_node = data; /* Update navbar node */
	        } else {
	          data = this.navbar_node; /* Use the old navbar node */
	        } 

	        this.navbar_context.secondary_title_list = [
	          { label: data.selected_iface.label, title: NtopUtils.shortenLabel(`${data.selected_iface.label}`, 16) }
	        ];

	        if(data.selected_host && data.selected_host.id != '') {
	          this.navbar_context.secondary_title_list[0]['href'] = `${http_prefix}/lua/pro/enterprise/network_maps.lua?map=${this.active_tab}&page=${this.page}&ifid=${this.$props.ifid}`;
	          this.navbar_context.secondary_title_list.push({
	            label: NtopUtils.shortenLabel(`${data.selected_host.label}`, 16, '.'),
	            title: `${data.selected_host.label}`,
	            href: data.selected_host.is_active ? `${http_prefix}/lua/host_details.lua?host=${data.selected_host.id}` : null,
	            target_blank: "true",
	          });
	        }  
	      },
	      get_active_tab: function() {
	        return this.$refs[this.active_tab + "_" + this.page];
	      },
	      /* Method used to switch active table tab */
	      click_item: function(item) {
	        this.navbar_context.items_table.forEach((i) => i.active = false);
	        item.active = true;
	        ntopng_events_manager.emit_custom_event(change_map_event, item);
	      },
	    },
	  };

	function render$4(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_page_navbar = resolveComponent("page-navbar");
	  const _component_page_service_map = resolveComponent("page-service-map");
	  const _component_page_service_table = resolveComponent("page-service-table");
	  const _component_page_periodicity_map = resolveComponent("page-periodicity-map");
	  const _component_page_periodicity_table = resolveComponent("page-periodicity-table");
	  const _component_page_asset_map = resolveComponent("page-asset-map");
	  const _component_page_asset_table = resolveComponent("page-asset-table");

	  return (openBlock(), createElementBlock(Fragment, null, [
	    createVNode(_component_page_navbar, {
	      id: "page_navbar",
	      main_title: $data.navbar_context.main_title,
	      secondary_title_list: $data.navbar_context.secondary_title_list,
	      help_link: $data.navbar_context.help_link,
	      items_table: $data.navbar_context.items_table,
	      onClick_item: $options.click_item
	    }, null, 8 /* PROPS */, ["main_title", "secondary_title_list", "help_link", "items_table", "onClick_item"]),
	    ($data.active_tab == 'service_map' && $data.page == 'graph')
	      ? (openBlock(), createBlock(_component_page_service_map, {
	          key: 0,
	          ref: "service_map_graph",
	          page_csrf: $props.page_csrf,
	          url_params: $data.url_params,
	          ifid: $props.ifid,
	          is_admin: $props.is_admin,
	          map_id: $props.map_id,
	          all_filter_list: $props.service_map_filter_list
	        }, null, 8 /* PROPS */, ["page_csrf", "url_params", "ifid", "is_admin", "map_id", "all_filter_list"]))
	      : createCommentVNode("v-if", true),
	    ($data.active_tab == 'service_map' && $data.page == 'table')
	      ? (openBlock(), createBlock(_component_page_service_table, {
	          key: 1,
	          ref: "service_map_table",
	          page_csrf: $props.page_csrf,
	          url_params: $data.url_params,
	          view: $data.updated_view,
	          table_filters: $props.service_table_filter_list,
	          is_admin: $props.is_admin,
	          service_acceptance: $props.service_acceptance
	        }, null, 8 /* PROPS */, ["page_csrf", "url_params", "view", "table_filters", "is_admin", "service_acceptance"]))
	      : createCommentVNode("v-if", true),
	    ($data.active_tab == 'periodicity_map' && $data.page == 'graph')
	      ? (openBlock(), createBlock(_component_page_periodicity_map, {
	          key: 2,
	          ref: "periodicity_map_graph",
	          page_csrf: $props.page_csrf,
	          url_params: $data.url_params,
	          ifid: $props.ifid,
	          is_admin: $props.is_admin,
	          map_id: $props.map_id,
	          all_filter_list: $props.periodicity_map_filter_list
	        }, null, 8 /* PROPS */, ["page_csrf", "url_params", "ifid", "is_admin", "map_id", "all_filter_list"]))
	      : createCommentVNode("v-if", true),
	    ($data.active_tab == 'periodicity_map' && $data.page == 'table')
	      ? (openBlock(), createBlock(_component_page_periodicity_table, {
	          key: 3,
	          ref: "periodicity_map_table",
	          page_csrf: $props.page_csrf,
	          url_params: $data.url_params,
	          view: $data.updated_view,
	          table_filters: $props.periodicity_table_filter_list,
	          is_admin: $props.is_admin
	        }, null, 8 /* PROPS */, ["page_csrf", "url_params", "view", "table_filters", "is_admin"]))
	      : createCommentVNode("v-if", true),
	    ($props.asset_map_filter_list && $props.asset_table_filter_list)
	      ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
	          ($data.active_tab == 'asset_map' && $data.page == 'graph')
	            ? (openBlock(), createBlock(_component_page_asset_map, {
	                key: 0,
	                ref: "asset_map_graph",
	                page_csrf: $props.page_csrf,
	                url_params: $data.url_params,
	                ifid: $props.ifid,
	                is_admin: $props.is_admin,
	                map_id: $props.map_id,
	                all_filter_list: $props.asset_map_filter_list
	              }, null, 8 /* PROPS */, ["page_csrf", "url_params", "ifid", "is_admin", "map_id", "all_filter_list"]))
	            : createCommentVNode("v-if", true),
	          ($data.active_tab == 'asset_map' && $data.page == 'table')
	            ? (openBlock(), createBlock(_component_page_asset_table, {
	                key: 1,
	                ref: "asset_map_table",
	                page_csrf: $props.page_csrf,
	                url_params: $data.url_params,
	                view: $data.updated_view,
	                table_filters: $props.asset_table_filter_list
	              }, null, 8 /* PROPS */, ["page_csrf", "url_params", "view", "table_filters"]))
	            : createCommentVNode("v-if", true)
	        ], 64 /* STABLE_FRAGMENT */))
	      : createCommentVNode("v-if", true)
	  ], 64 /* STABLE_FRAGMENT */))
	}

	script$9.render = render$4;
	script$9.__file = "http_src/vue/page-home-map.vue";

	const _hoisted_1$8 = { id: "my_dataviz" };


	var script$8 = {
	  __name: 'page-sankey',
	  props: {
	},
	  setup(__props) {



	onBeforeMount(async() => {
	    
	    
	});

	let d3 = d3v7;
	onMounted(async () => {
	    // set the dimensions and margins of the graph
	    var margin = {top: 10, right: 10, bottom: 10, left: 10},
		width = 450 - margin.left - margin.right,
		height = 480 - margin.top - margin.bottom;
	    
	    // append the svg object to the body of the page
	    var svg = d3.select("#my_dataviz").append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + margin.top + margin.bottom)
		.append("g")
		.attr("transform",
	              "translate(" + margin.left + "," + margin.top + ")");
	    
	    let graph = {
		"nodes":[
		    {"node":0,"name":"node0"},
		    {"node":1,"name":"node1"},
		    {"node":2,"name":"node2"},
		    {"node":3,"name":"node3"},
		    {"node":4,"name":"node4"}
		],
		"links":[
		    {"source":0,"target":2,"value":2},
		    {"source":1,"target":2,"value":2},
		    {"source":1,"target":3,"value":2},
		    {"source":0,"target":4,"value":2},
		    {"source":2,"target":3,"value":2},
		    {"source":2,"target":4,"value":2},
		    {"source":3,"target":4,"value":4}
		]
	    };
	    console.log(graph);    
	    
	    // svg.append("g")
	    // 	.attr("fill", "none")
	    // 	.attr("stroke", "#000")
	    // 	.attr("stroke-opacity", 0.2)
	    // 	.selectAll("path")
	    // 	.data(graph.links)
	    // 	.join("path")
	    // 	.attr("d", d3.sankeyLinkHorizontal())
	    // 	.attr("stroke-width", function(d) { return d.width; });
	    // return;


	    // Color scale used
	    var color = d3.scaleOrdinal(d3.schemeCategory10);
	    
	    // Set the sankey diagram properties
	    var sankey = d3.sankey()
		.nodeWidth(36)
		.nodePadding(290)
		.size([width, height]);
	    
	    // load the data
	    // let graph = await ntopng_utility.http_request("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/data_sankey.json");
	    // return;
	    // Constructs a new Sankey generator with the default settings.
	    sankey
		.nodes(graph.nodes)
		.links(graph.links);
	    // .extent([0,0], [1000, 1000]);
	    
	    
	    // add in the links
	    var link = svg.append("g")
		.selectAll(".link")
		.data(graph.links)
		.enter()
		.append("path")
		.attr("class", "link")
		// .attr("d", sankey.link() )
		.style("stroke-width", function(d) { return Math.max(1, d.dy); })
		.sort(function(a, b) { return b.dy - a.dy; });
	    
	    // add in the nodes
	    var node = svg.append("g")
		.selectAll(".node")
		.data(graph.nodes)
		.enter().append("g")
		.attr("class", "node")
		.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
		.call(d3.drag()
		      .subject(function(d) { return d; })
		      .on("start", function() { this.parentNode.appendChild(this); })
		      .on("drag", dragmove));
	    
	    // add the rectangles for the nodes
	    node
		.append("rect")
		.attr("height", function(d) { return d.dy; })
		.attr("width", sankey.nodeWidth())
		.style("fill", function(d) { return d.color = color(d.name.replace(/ .*/, "")); })
		.style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
	    // Add hover text
		.append("title")
		.text(function(d) { return d.name + "\n" + "There is " + d.value + " stuff in this node"; });
	    
	    // add in the title for the nodes
	    node
		.append("text")
	        .attr("x", -6)
	        .attr("y", function(d) { return d.dy / 2; })
	        .attr("dy", ".35em")
	        .attr("text-anchor", "end")
	        .attr("transform", null)
	        .text(function(d) { return d.name; })
		.filter(function(d) { return d.x < width / 2; })
	        .attr("x", 6 + sankey.nodeWidth())
	        .attr("text-anchor", "start");
	    
	    // the function for moving the nodes
	    function dragmove(d) {
		d3.select(this)
		    .attr("transform",
			  "translate("
			  + d.x + ","
			  + (d.y = Math.max(
			      0, Math.min(height - d.dy, d3.event.y))
			    ) + ")");
		sankey.relayout();
		link.attr("d", sankey.link() );
	    }	
	});


	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock("div", _hoisted_1$8))
	}
	}

	};

	var css_248z$4 = "\n.node rect {\n  fill-opacity: 0.9;\n  shape-rendering: crispEdges;\n}\n.node text {\n  pointer-events: none;\n  text-shadow: 0 1px 0 #fff;\n}\n.link {\n  fill: none;\n  stroke: #000;\n  stroke-opacity: 0.2;\n}\n.link:hover {\n  stroke-opacity: 0.5;\n}\n";
	styleInject(css_248z$4);

	script$8.__file = "http_src/vue/page-sankey.vue";

	const change_applications_tab_event = "change_applications_tab_event";

	var script$7 = {
	  components: {	  
	    'chart': script$B,
	    'datatable': script$s,
	    'modal-delete-confirm': script$o,
	    'tab-list': script$p,
	  },
	  props: {
	    page_csrf: String,
	    url_params: Object,
	    view: String,
	    is_ch_enabled: Boolean,
	  },
	  /**
	   * First method called when the component is created.
	   */
	  created() {
	    this.applications_tab = ntopng_url_manager$1.get_url_entry("view") || this.$props.view;
	    this.tab_list.forEach((i) => {
	      this.applications_tab == i.id ? i.active = true : i.active = false;
	    });
	    start_datatable(this);
	  },
	  mounted() {
	    ntopng_events_manager$1.on_custom_event("change_applications_tab_event", change_applications_tab_event, (tab) => {
		    let table = this.get_active_table();
	      ntopng_url_manager$1.set_key_to_url('view', tab.id);
	      table.destroy_table();
	      this.applications_tab = tab.id;
	    });
	  },    
	  data() {
	    return {
	      i18n: (t) => i18n(t),
	      applications_tab: null,
	      config_devices_applications: null,
	      config_devices_categories: null,
	      chart_options: [
	        {
	          title: i18n('graphs.top_10_ndpi_protocols'),
	          type: ntopChartApex.typeChart.PIE,
	          url: `${http_prefix}/lua/rest/v2/get/host/l7/proto_data.lua`,
	          tab: `applications`,
	          id: `top_applications`,
	        },
	        {
	          title: i18n('graphs.top_breed'),
	          type: ntopChartApex.typeChart.PIE,
	          url: `${http_prefix}/lua/rest/v2/get/host/l7/breed_data.lua`,
	          tab: `applications`,
	          id: `top_breed`,
	        },
	        {
	          title: i18n('graphs.top_10_ndpi_categories'),
	          type: ntopChartApex.typeChart.PIE,
	          url: `${http_prefix}/lua/rest/v2/get/host/l7/cat_data.lua`,
	          tab: `categories`,
	          id: `top_categories`,
	        },
	        {
	          title: i18n('graphs.top_breed'),
	          type: ntopChartApex.typeChart.PIE,
	          url: `${http_prefix}/lua/rest/v2/get/host/l7/breed_data.lua`,
	          tab: `categories`,
	          id: `top_breed`,
	        },
	      ],
	      tab_list: [
	        { 
	          title: i18n('host_details.applications_tab'),
	          active: (this.$props.view == 'applications'),
	          id: 'applications'
	        },
	        { 
	          title: i18n('host_details.categories_tab'),
	          active: (this.$props.view == 'categories'),
	          id: 'categories'
	        },
	      ]
	    };
	  },
	  methods: {
	    add_action_column: function(columns, name, value) {
	      const host = `${this.$props.url_params.host}`;
	      const vlan = `${this.$props.url_params.vlan}`;
	      const ifid = `${this.$props.url_params.ifid}`;
	      let handlerId = "page-stats-action-jump-historical";
	      columns.push({ columnName: i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, handlerId, render: (data, type, service) => {
	        const jump_to_historical = {
	          handlerId,
	          onClick: () => {
	            let url = `${http_prefix}/lua/pro/db_search.lua?ifid=${ifid}&${name}=${service[value].id};eq&ip=${host};eq`;
	            if(vlan != 0)
	              url = `${url}&vlan_id=${vlan};eq`;
	            window.open(url);
	          }
	        };
	        return DataTableUtils.createActionButtons([{ class: 'dropdown-item', href: '#', title: i18n('db_explorer.historical_data'), handler: jump_to_historical }])
	      }});
	    },
	    destroy: function() {
	      let table = this.get_active_table();
	      table.destroy_table();
	    },
	    /* Method used to switch active table tab */
	    click_item: function(item) {
	      this.tab_list.forEach((i) => i.active = false);
	      item.active = true;
	      ntopng_events_manager$1.emit_custom_event(change_applications_tab_event, item);
	    }, 
	    reload_table: function() {
	      let table = this.get_active_table();
	      NtopUtils.showOverlays();
	      table.reload();
	      NtopUtils.hideOverlays();
	    },
	    get_active_table: function() {
	      return this.$refs[`table_host_${this.applications_tab}`];
	    },
	    get_f_get_custom_chart_options() {
	      console.log("get_f_");
	      return async (url) => {
	        return charts_options_items.value[chart_index].chart_options;
	      }
	    }
	  },
	};  

	function start_datatable(PageVue) {
	  const datatableButton = [];

	  /* Manage the buttons close to the search box */
	  datatableButton.push({
	    text: '<i class="fas fa-sync"></i>',
	    className: 'btn-link',
	    action: function (e, dt, node, config) {
	      PageVue.reload_table();
	    }
	  });
	  
	  let tmp_params = url_params;
	  tmp_params['view'] = 'applications';
	  
	  let defaultDatatableConfig = {
	    table_buttons: datatableButton,
	    data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/l7/data.lua`, tmp_params),
	    enable_search: true,
	    table_config: { 
	      serverSide: false, 
	      order: [[ 6 /* percentage column */, 'desc' ]],
	      columnDefs: [
	        { type: "time-uni", targets: 1 },
	        { type: "file-size", targets: 2 },
	        { type: "file-size", targets: 3 },
	        { type: "file-size", targets: 5 },
	      ]
	    }
	  };
	  
	  /* Applications table configuration */  

	  let columns = [
	    { columnName: i18n("host_details.application"), targets: 0, width: '20', name: 'application', data: 'application', className: 'text-nowrap', responsivePriority: 1, render: (data) => {
	        return `<a href="${http_prefix}/lua/host_details.lua?host=${PageVue.$props.url_params.host}@${PageVue.$props.url_params.vlan}&ts_schema=host:ndpi&page=historical&protocol=${data.label}" target="_blank">${data.label}</a>`
	      } 
	    },
	    { columnName: i18n("host_details.duration"), targets: 1, width: '10', name: 'duration', data: 'duration', className: 'text-nowrap', responsivePriority: 1, render: (data) => {
	        return NtopUtils.secondsToTime(data);
	      }  
	    },
	    { columnName: i18n("host_details.sent"), targets: 2, width: '10', name: 'sent', data: 'bytes_sent', className: 'text-nowrap', responsivePriority: 2, render: (data) => {
	        return NtopUtils.bytesToSize(data);
	      }  
	    },
	    { columnName: i18n("host_details.rcvd"), targets: 3, width: '10', name: 'rcvd', data: 'bytes_rcvd',  className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
	        return NtopUtils.bytesToSize(data);
	      }  
	    },
	    { columnName: i18n("host_details.breakdown"), targets: 4, width: '10', name: 'breakdown', data: 'breakdown', orderable: false, className: 'text-center text-nowrap', responsivePriority: 2, render: (data, type, row) => {
	        const percentage_sent = (row.bytes_sent * 100) / row.tot_bytes;
	        const percentage_rcvd = (row.bytes_rcvd * 100) / row.tot_bytes;
	        return NtopUtils.createBreakdown(percentage_sent, percentage_rcvd, i18n('host_details.sent'), i18n('host_details.rcvd'));
	      }  
	    },
	    { columnName: i18n("host_details.tot_bytes"), targets: 5, width: '20', name: 'tot_bytes', data: 'tot_bytes', className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
	        return NtopUtils.bytesToSize(data);
	      }   
	    },
	    { columnName: i18n("host_details.tot_percentage"), targets: 6, width: '20', name: 'percentage', data: 'percentage',  className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
	        const percentage = data.toFixed(1);
	        return NtopUtils.createProgressBar(percentage);
	      }  
	    },
	  ];

	  if(is_ch_enabled)
	    PageVue.add_action_column(columns, 'l7proto', 'application');
	  
	  let applicationsConfig = ntopng_utility.clone(defaultDatatableConfig);
	  applicationsConfig.columns_config = columns;
	  PageVue.config_devices_applications = applicationsConfig;


	  /* Categories table configuration */

	  tmp_params['view'] = 'categories';  
	  defaultDatatableConfig.data_url = NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/l7/data.lua`, tmp_params);


	  columns = [
	    { columnName: i18n("host_details.category"), targets: 0, width: '20', name: 'category', data: 'category', className: 'text-nowrap', responsivePriority: 1, render: (data) => {
	        return `<a href="${http_prefix}/lua/host_details.lua?host=${PageVue.$props.url_params.host}@${PageVue.$props.url_params.vlan}&ts_schema=host:ndpi_categories&page=historical&category=${data.label}" target="_blank">${data.label}</a>`
	      } 
	    },
	    { columnName: i18n("host_details.applications"), targets: 0, width: '20', name: 'applications', data: 'applications', orderable: false, className: 'text-nowrap', responsivePriority: 1, render: (data) => {
	        return `${data.label || ''} <a href="${http_prefix}/${data.href}${data.category_id}">${data.more_protos || ''}</a>`
	      } 
	    },
	    { columnName: i18n("host_details.duration"), targets: 0, width: '15', name: 'duration', data: 'duration', className: 'text-nowrap', responsivePriority: 1, render: (data) => {
	        return NtopUtils.secondsToTime(data);
	      }  
	    },
	    { columnName: i18n("host_details.tot_bytes"), targets: 0, width: '20', name: 'tot_bytes', data: 'tot_bytes', className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
	        return NtopUtils.bytesToSize(data);
	      }  
	    },
	    { columnName: i18n("host_details.tot_percentage"), targets: 0, width: '25', name: 'percentage', data: 'percentage', width: '20%', className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
	        const percentage = data.toFixed(1);
	        return NtopUtils.createProgressBar(percentage);
	      }  
	    },
	  ];

	  if(is_ch_enabled)
	    PageVue.add_action_column(columns, 'l7cat', 'category');
	  
	  let categoriesConfig = ntopng_utility.clone(defaultDatatableConfig);
	  categoriesConfig.columns_config = columns;
	  categoriesConfig.table_config.order = [[ 4 /* percentage column */, 'desc' ]];
	  categoriesConfig.table_config.columnDefs = [
	    { type: "time-uni", targets: 2 },
	    { type: "file-size", targets: 3 },
	  ];
	  
	  PageVue.config_devices_categories = categoriesConfig;
	}

	const _hoisted_1$7 = { class: "row" };
	const _hoisted_2$7 = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$7 = { class: "card" };
	const _hoisted_4$7 = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_5$7 = { class: "card-body" };
	const _hoisted_6$7 = { id: "host_details_applications" };
	const _hoisted_7$7 = {
	  class: "row mb-4 mt-4",
	  id: "host_details_applications"
	};
	const _hoisted_8$7 = { class: "col-6" };
	const _hoisted_9$6 = {
	  key: 0,
	  class: "widget-name"
	};

	function render$3(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_tab_list = resolveComponent("tab-list");
	  const _component_chart = resolveComponent("chart");
	  const _component_datatable = resolveComponent("datatable");

	  return (openBlock(), createElementBlock("div", _hoisted_1$7, [
	    createBaseVNode("div", _hoisted_2$7, [
	      createBaseVNode("div", _hoisted_3$7, [
	        _hoisted_4$7,
	        createBaseVNode("div", _hoisted_5$7, [
	          createBaseVNode("div", _hoisted_6$7, [
	            createVNode(_component_tab_list, {
	              ref: "host_details_applications_tab_list",
	              id: "host_details_applications_tab_list",
	              tab_list: $data.tab_list,
	              onClick_item: $options.click_item
	            }, null, 8 /* PROPS */, ["tab_list", "onClick_item"]),
	            createBaseVNode("div", _hoisted_7$7, [
	              (openBlock(true), createElementBlock(Fragment, null, renderList($data.chart_options, (chart_option) => {
	                return (openBlock(), createElementBlock("div", _hoisted_8$7, [
	                  (chart_option.tab == $data.applications_tab)
	                    ? (openBlock(), createElementBlock("h3", _hoisted_9$6, toDisplayString(chart_option.title), 1 /* TEXT */))
	                    : createCommentVNode("v-if", true),
	                  (chart_option.tab == $data.applications_tab)
	                    ? (openBlock(), createBlock(_component_chart, {
	                        key: 1,
	                        id: chart_option.id,
	                        chart_type: chart_option.type,
	                        base_url_request: chart_option.url,
	                        register_on_status_change: false
	                      }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"]))
	                    : createCommentVNode("v-if", true)
	                ]))
	              }), 256 /* UNKEYED_FRAGMENT */))
	            ]),
	            ($data.applications_tab == 'applications')
	              ? (openBlock(), createBlock(_component_datatable, {
	                  key: 0,
	                  ref: "table_host_applications",
	                  table_buttons: $data.config_devices_applications.table_buttons,
	                  columns_config: $data.config_devices_applications.columns_config,
	                  data_url: $data.config_devices_applications.data_url,
	                  enable_search: $data.config_devices_applications.enable_search,
	                  table_config: $data.config_devices_applications.table_config
	                }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"]))
	              : createCommentVNode("v-if", true),
	            ($data.applications_tab == 'categories')
	              ? (openBlock(), createBlock(_component_datatable, {
	                  key: 1,
	                  ref: "table_host_categories",
	                  table_buttons: $data.config_devices_categories.table_buttons,
	                  columns_config: $data.config_devices_categories.columns_config,
	                  data_url: $data.config_devices_categories.data_url,
	                  enable_search: $data.config_devices_categories.enable_search,
	                  table_config: $data.config_devices_categories.table_config
	                }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"]))
	              : createCommentVNode("v-if", true)
	          ])
	        ])
	      ])
	    ])
	  ]))
	}

	script$7.render = render$3;
	script$7.__file = "http_src/vue/page-host-details-applications.vue";

	const _hoisted_1$6 = { class: "row" };
	const _hoisted_2$6 = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$6 = { class: "card" };
	const _hoisted_4$6 = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_5$6 = { class: "card-body" };
	const _hoisted_6$6 = { id: "host_details_traffic" };
	const _hoisted_7$6 = {
	  class: "row mb-4 mt-4",
	  id: "host_details_traffic"
	};
	const _hoisted_8$6 = { class: "col-4" };
	const _hoisted_9$5 = { class: "widget-name" };


	var script$6 = {
	  __name: 'page-host-details-traffic',
	  props: {
	  page_csrf: String,
	},
	  setup(__props) {

	const traffic_table = ref(null);
	ref([]);
	const config_traffic_table = ref({});

	const destroy = () => {
	  traffic_table.value.destroy_table();
	};

	const reload_table = () => {
	  traffic_table.value.reload();
	};
	    
	onBeforeMount(async () => {
	  start_datatable();
	});

	onUnmounted(async () => {
	  destroy();
	});

	const chart_options = [
	  {
	    title: i18n('graphs.l4_proto'),
	    type: ntopChartApex.typeChart.PIE,
	    url: `${http_prefix}/lua/rest/v2/get/host/l4/proto_data.lua`,
	    id: `traffic_protos`,
	  },
	  {
	    title: i18n('graphs.contacted_hosts'),
	    type: ntopChartApex.typeChart.PIE,
	    url: `${http_prefix}/lua/rest/v2/get/host/l4/contacted_hosts_data.lua`,
	    id: `contacted_hosts`,
	  },
	  {
	    title: i18n('graphs.traffic'),
	    type: ntopChartApex.typeChart.PIE,
	    url: `${http_prefix}/lua/rest/v2/get/host/l4/traffic_data.lua`,
	    id: `traffic`,
	  },
	];

	function start_datatable(PageVue) {
	  const datatableButton = [];
	  let url_params = {};
	  
	  url_params["host"] = ntopng_url_manager$1.get_url_entry("host");
	  url_params["vlan"] = ntopng_url_manager$1.get_url_entry("vlan");
	  url_params["ifid"] = ntopng_url_manager$1.get_url_entry("ifid");

	  /* Manage the buttons close to the search box */
	  datatableButton.push({
	    text: '<i class="fas fa-sync"></i>',
	    className: 'btn-link',
	    action: function (e, dt, node, config) {
	      reload_table();
	    }
	  });
	    
	  let defaultDatatableConfig = {
	    table_buttons: datatableButton,
	    data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/l4/data.lua`, url_params),
	    enable_search: true,
	    table_config: { 
	      serverSide: false, 
	      order: [[ 6 /* percentage column */, 'desc' ]],
	      columnDefs: [
	        { type: "time-uni", targets: 1 },
	        { type: "file-size", targets: 2 },
	        { type: "file-size", targets: 3 },
	        { type: "file-size", targets: 5 },
	      ]
	    }
	  };
	  
	  /* Applications table configuration */  

	  let columns = [
	    { columnName: i18n("protocol"), targets: 0, width: '10', name: 'protocol', data: 'protocol', className: 'text-nowrap', responsivePriority: 1 },
	    { columnName: i18n("chart"), targets: 1, width: '10', name: 'historical', data: 'historical', className: 'text-nowrap', responsivePriority: 1 },
	    { columnName: i18n("traffic_labels.bytes_sent"), targets: 2, width: '10', name: 'sent', data: 'bytes_sent', className: 'text-nowrap', responsivePriority: 2, render: (data) => {
	        return NtopUtils.bytesToSize(data);
	      }  
	    },
	    { columnName: i18n("traffic_labels.bytes_rcvd"), targets: 3, width: '10', name: 'rcvd', data: 'bytes_rcvd',  className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
	        return NtopUtils.bytesToSize(data);
	      }  
	    },
	    { columnName: i18n("traffic_labels.breakdown"), targets: 4, width: '20', name: 'breakdown', data: 'breakdown', orderable: false, className: 'text-center text-nowrap', responsivePriority: 2, render: (data, type, row) => {
	        const percentage_sent = (row.bytes_sent * 100) / row.total_bytes;
	        const percentage_rcvd = (row.bytes_rcvd * 100) / row.total_bytes;
	        return NtopUtils.createBreakdown(percentage_sent, percentage_rcvd, i18n('host_details.sent'), i18n('host_details.rcvd'));
	      }  
	    },
	    { columnName: i18n("traffic_labels.total_bytes"), targets: 5, width: '20', name: 'tot_bytes', data: 'total_bytes', className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
	        return NtopUtils.bytesToSize(data);
	      }   
	    },
	    { columnName: i18n("traffic_labels.total_percentage"), targets: 6, width: '20', name: 'percentage', data: 'total_percentage',  className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
	        const percentage = data.toFixed(1);
	        return NtopUtils.createProgressBar(percentage);
	      }  
	    },
	  ];

	  let trafficConfig = ntopng_utility.clone(defaultDatatableConfig);
	  trafficConfig.columns_config = columns;
	  config_traffic_table.value = trafficConfig;
	}

	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock("div", _hoisted_1$6, [
	    createBaseVNode("div", _hoisted_2$6, [
	      createBaseVNode("div", _hoisted_3$6, [
	        _hoisted_4$6,
	        createBaseVNode("div", _hoisted_5$6, [
	          createBaseVNode("div", _hoisted_6$6, [
	            createBaseVNode("div", _hoisted_7$6, [
	              (openBlock(), createElementBlock(Fragment, null, renderList(chart_options, (chart_option) => {
	                return createBaseVNode("div", _hoisted_8$6, [
	                  createBaseVNode("h3", _hoisted_9$5, toDisplayString(chart_option.title), 1 /* TEXT */),
	                  createVNode(script$B, {
	                    id: chart_option.id,
	                    chart_type: chart_option.type,
	                    base_url_request: chart_option.url,
	                    register_on_status_change: false
	                  }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"])
	                ])
	              }), 64 /* STABLE_FRAGMENT */))
	            ]),
	            createVNode(script$s, {
	              ref_key: "traffic_table",
	              ref: traffic_table,
	              table_buttons: config_traffic_table.value.table_buttons,
	              columns_config: config_traffic_table.value.columns_config,
	              data_url: config_traffic_table.value.data_url,
	              enable_search: config_traffic_table.value.enable_search,
	              table_config: config_traffic_table.value.table_config
	            }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
	          ])
	        ])
	      ])
	    ])
	  ]))
	}
	}

	};

	script$6.__file = "http_src/vue/page-host-details-traffic.vue";

	const _hoisted_1$5 = { class: "row" };
	const _hoisted_2$5 = { class: "col-md-12 col-lg-12" };
	const _hoisted_3$5 = { class: "card" };
	const _hoisted_4$5 = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
	  /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
	    /*#__PURE__*/createBaseVNode("div", {
	      class: "spinner-border text-primary mt-5",
	      role: "status"
	    }, [
	      /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
	    ])
	  ])
	], -1 /* HOISTED */);
	const _hoisted_5$5 = { class: "card-body" };
	const _hoisted_6$5 = { class: "row" };
	const _hoisted_7$5 = { class: "col-6 mb-4 mt-4" };
	const _hoisted_8$5 = { class: "widget-name" };


	var script$5 = {
	  __name: 'page-host-details-packets',
	  props: {
	  page_csrf: String,
	  url_params: Object,
	},
	  setup(__props) {
	const chart_options = [
	  {
	    title: i18n('graphs.packets_sent'),
	    type: ntopChartApex.typeChart.PIE,
	    url: `${http_prefix}/lua/rest/v2/get/host/packets/sent_data.lua`,
	    id: `packets_sent`,
	  },
	  {
	    title: i18n('graphs.packets_rcvd'),
	    type: ntopChartApex.typeChart.PIE,
	    url: `${http_prefix}/lua/rest/v2/get/host/packets/rcvd_data.lua`,
	    id: `packets_rcvd`,
	  },
	  {
	    title: i18n('graphs.tcp_flags'),
	    type: ntopChartApex.typeChart.PIE,
	    url: `${http_prefix}/lua/rest/v2/get/host/packets/tcp_flags_data.lua`,
	    id: `tcp_flags`,
	  },
	  {
	    title: i18n('graphs.arp_distribution'),
	    type: ntopChartApex.typeChart.PIE,
	    url: `${http_prefix}/lua/rest/v2/get/host/packets/arp_data.lua`,
	    id: `arp_requests`,
	  },
	];

	function chart_done(data, tmp, tmp2) {
	  NtopUtils$1.hideOverlays();
	}

	onMounted(() => {});


	return (_ctx, _cache) => {
	  return (openBlock(), createElementBlock("div", _hoisted_1$5, [
	    createBaseVNode("div", _hoisted_2$5, [
	      createBaseVNode("div", _hoisted_3$5, [
	        _hoisted_4$5,
	        createBaseVNode("div", _hoisted_5$5, [
	          createBaseVNode("div", _hoisted_6$5, [
	            (openBlock(), createElementBlock(Fragment, null, renderList(chart_options, (chart_option) => {
	              return createBaseVNode("div", _hoisted_7$5, [
	                createBaseVNode("h3", _hoisted_8$5, toDisplayString(chart_option.title), 1 /* TEXT */),
	                createVNode(script$B, {
	                  id: chart_option.id,
	                  chart_type: chart_option.type,
	                  base_url_request: chart_option.url,
	                  register_on_status_change: false,
	                  onChart_reloaded: chart_done
	                }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"])
	              ])
	            }), 64 /* STABLE_FRAGMENT */))
	          ])
	        ])
	      ])
	    ])
	  ]))
	}
	}

	};

	script$5.__file = "http_src/vue/page-host-details-packets.vue";

	var script$4 = {
	    components: {
		'modal': script$y,
	  'select-search': script$A,
	    }, 
	    props: {
		id: String,
		filters_options: Array,
	    },
	    updated() {
	    },
	    data() {
		return {
		    i18n: (t) => i18n(t),
		    jQuery: $,
		    id_modal: `${this.$props.id}_modal`,
		    filter_type_selected: [],
		    filter_type_label_selected: null,
		    operator_selected: [],
		    option_selected: [],
		    input_value: null,
		    data_pattern_selected: null,
		    input_required: false,
		    options_to_show: null,
		    operators_to_show: [],
		};
	    },
	    emits: ["apply"],
	    created() {},
	    /** This method is the first method called after html template creation. */
	    async mounted() {
	      await ntopng_sync.on_ready(this.id_modal);
	      ntopng_events_manager.on_custom_event(this.$props["id"], ntopng_custom_events.SHOW_MODAL_FILTERS, (filter) => this.show(filter));	
	      // notifies that component is ready
	      ntopng_sync.ready(this.$props["id"]);
	    },
	    methods: {
		show: function(filter) {
	    if (this.$props.filters_options == null || this.$props.filters_options.length == 0) { 
	      return; 
	    }
	    if (filter != null) {
		  	this.filter_type_selected = filter;
			  this.change_filter(filter);		
	    } else {
	      this.filter_type_selected = this.$props.filters_options[0];
	      this.change_filter();
	    }
	    this.$refs["modal"].show();
		},
	  post_change: function(filter) {
	    if (filter.id && this.$props.filters_options) {
	      /* Filter type selected, e.g. Alert Type, Application, ecc. */
				this.filter_type_selected = this.$props.filters_options.find((fo) => fo.id == filter.id);
	    }
	    if (filter.value) {
	      /* Filter selected for the type, e.g. DNS, ICMP, ecc. */
	      if (this.options_to_show) {
				  this.option_selected = this.options_to_show.find((fo) => fo.value == filter.value);
	      } else {
			    this.option_selected = [];
	        this.input_value = filter.value;
	        this.data_pattern_selected = this.get_data_pattern(filter.value_type);
	      }
	    }
	    if (filter.operator && this.operators_to_show) {
	      /* Operator filter selected, e.g. =, !=, ecc. */
				this.operator_selected = this.operators_to_show.find((fo) => fo.id == filter.operator);
	    }
	  },
	  change_operator_type: function(selected_operator_type) {
	    if(selected_operator_type != []) {
	      this.operator_selected = selected_operator_type;
	    }
	  },  
	  change_data_filter: function(selected_filter) {
	    if(selected_filter != []) {
	      this.option_selected = selected_filter;
	    }
	  },  
	  change_filter: function(selected_filter) {
	    this.options_to_show = null;
	    this.option_selected = null;
	    this.input_value = null;
	    let filters_options = this.$props.filters_options;
	    /* Search the filter selected */
	    let filter = filters_options.find((fo) => fo.id == this.filter_type_selected.id);
	    if (filter == null) { 
	      return; 
	    }
	    /* Set the correct filters to display */
	    this.operators_to_show = filter.operators;
	    this.filter_type_label_selected = filter.label;
	    if (filter.options != null) {
	      this.options_to_show = filter.options.sort((a, b) => {
	        if (a == null || a.label == null) { return -1; }
	        if (b == null || b.label == null) { return 1; }
	        return a.label.toString().localeCompare(b.label.toString());
	      });
	      if(!this.option_selected)
	        this.option_selected = this.options_to_show[0];
	    } else {
	      this.options_to_show = null;
	      this.data_pattern_selected = this.get_data_pattern(filter.value_type);
	    }

	    if(filter.operators && this.operator_selected.length == 0) {
	      this.operator_selected = filter.operators[0];
	    }

	    if (selected_filter != null) { 
	      this.post_change(selected_filter); 
	    }
		},
		get_data_pattern: function(value_type) {
		    this.input_required = true;
		    if (value_type == "text") {
			this.input_required = false;
			return `.*`;
		    } else if (value_type == "ip") {
			let r_ipv4 = NtopUtils.REGEXES.ipv4;
			let r_ipv4_vlan = r_ipv4.replace("$", "@[0-9]{0,5}$");
			let r_ipv6 = NtopUtils.REGEXES.ipv6;
			let r_ipv6_vlan = r_ipv6.replaceAll("$", "@[0-9]{0,5}$");
			return `(${r_ipv4})|(${r_ipv4_vlan})|(${r_ipv6})|(${r_ipv6_vlan})`;
		    }
		    return NtopUtils.REGEXES[value_type];
		},
		check_disable_apply: function() {
	      let regex = new RegExp(this.data_pattern_selected);
		    let disable_apply = !this.options_to_show && (
			(this.input_required && (this.input_value == null || this.input_value == ""))
			    || (regex.test(this.input_value) == false)
			);
		    return disable_apply;
		},
		apply: function() {
	    let value = this.input_value;
	    let value_label = this.input_value;
	    if (value == null || (this.option_selected != undefined && this.option_selected.length != 0)) {
	      let filter = this.filters_options.find((fo) => fo.id == this.filter_type_selected.id);
	      let option = filter.options.find((o) => o.value == this.option_selected.value);
	      value = option.value;
	      value_label = option.value_label || option.label;
	    } else if (value == null) {
	      value = "";
	    }
	    let params = {
	      id: this.filter_type_selected.id,
	      label: this.filter_type_label_selected,
	      operator: this.operator_selected.id,
	      value: value,
	      value_label: value_label,
	    };
	    this.$emit("apply", params);
	    ntopng_events_manager.emit_custom_event(ntopng_custom_events.MODAL_FILTERS_APPLY, params);
	    this.close();
		},
		close: function() {
		    this.$refs["modal"].close();
		},
	    },
	};

	const _withScopeId$3 = n => (pushScopeId("data-v-3119c83e"),n=n(),popScopeId(),n);
	const _hoisted_1$4 = { autocomplete: "off" };
	const _hoisted_2$4 = { class: "form-group row" };
	const _hoisted_3$4 = /*#__PURE__*/ _withScopeId$3(() => /*#__PURE__*/createBaseVNode("label", {
	  class: "col-form-label col-sm-3",
	  for: "dt-filter-type-select"
	}, [
	  /*#__PURE__*/createBaseVNode("b", null, "Filter")
	], -1 /* HOISTED */));
	const _hoisted_4$4 = { class: "col-sm-8" };
	const _hoisted_5$4 = /*#__PURE__*/ _withScopeId$3(() => /*#__PURE__*/createBaseVNode("hr", null, null, -1 /* HOISTED */));
	const _hoisted_6$4 = { class: "dt-filter-template-container form-group row" };
	const _hoisted_7$4 = { class: "col-form-label col-sm-3" };
	const _hoisted_8$4 = { class: "col-sm-8" };
	const _hoisted_9$4 = { class: "input-group mb-3" };
	const _hoisted_10$3 = { class: "input-group-prepend col-sm-3" };
	const _hoisted_11$3 = {
	  key: 0,
	  class: "col-sm-9"
	};
	const _hoisted_12$3 = ["pattern", "required"];
	const _hoisted_13$3 = {
	  style: {"margin":"0px","padding":"0"},
	  class: "alert invalid-feedback"
	};
	const _hoisted_14$2 = ["disabled"];

	function render$2(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_select_search = resolveComponent("select-search");
	  const _component_modal = resolveComponent("modal");

	  return (openBlock(), createBlock(_component_modal, {
	    id: $data.id_modal,
	    ref: "modal"
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString($data.i18n('alerts_dashboard.add_filter')), 1 /* TEXT */)
	    ]),
	    body: withCtx(() => [
	      createBaseVNode("form", _hoisted_1$4, [
	        createBaseVNode("div", _hoisted_2$4, [
	          _hoisted_3$4,
	          createBaseVNode("div", _hoisted_4$4, [
	            createVNode(_component_select_search, {
	              selected_option: $data.filter_type_selected,
	              "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => (($data.filter_type_selected) = $event)),
	              id: 'filter_type',
	              options: $props.filters_options,
	              onSelect_option: _cache[1] || (_cache[1] = $event => ($options.change_filter()))
	            }, null, 8 /* PROPS */, ["selected_option", "options"])
	          ])
	        ]),
	        _hoisted_5$4,
	        createBaseVNode("div", _hoisted_6$4, [
	          createBaseVNode("label", _hoisted_7$4, [
	            createBaseVNode("b", null, toDisplayString($data.filter_type_label_selected), 1 /* TEXT */)
	          ]),
	          createBaseVNode("div", _hoisted_8$4, [
	            createBaseVNode("div", _hoisted_9$4, [
	              createBaseVNode("div", _hoisted_10$3, [
	                createVNode(_component_select_search, {
	                  selected_option: $data.operator_selected,
	                  "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => (($data.operator_selected) = $event)),
	                  id: 'operator_filter',
	                  options: $data.operators_to_show,
	                  onSelect_option: $options.change_operator_type
	                }, null, 8 /* PROPS */, ["selected_option", "options", "onSelect_option"])
	              ]),
	              ($data.options_to_show)
	                ? (openBlock(), createElementBlock("div", _hoisted_11$3, [
	                    createVNode(_component_select_search, {
	                      selected_option: $data.option_selected,
	                      "onUpdate:selected_option": _cache[3] || (_cache[3] = $event => (($data.option_selected) = $event)),
	                      id: 'data_filter',
	                      options: $data.options_to_show,
	                      onSelect_option: $options.change_data_filter
	                    }, null, 8 /* PROPS */, ["selected_option", "options", "onSelect_option"])
	                  ]))
	                : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
	                    withDirectives(createBaseVNode("input", {
	                      "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => (($data.input_value) = $event)),
	                      pattern: $data.data_pattern_selected,
	                      name: "value",
	                      required: $data.input_required,
	                      type: "text",
	                      class: "form-control"
	                    }, null, 8 /* PROPS */, _hoisted_12$3), [
	                      [vModelText, $data.input_value]
	                    ]),
	                    createBaseVNode("span", _hoisted_13$3, toDisplayString($data.i18n('invalid_value')), 1 /* TEXT */)
	                  ], 64 /* STABLE_FRAGMENT */))
	            ]),
	            createCommentVNode(" end div input-group mb-3 ")
	          ]),
	          createCommentVNode(" end div form-group-row ")
	        ])
	      ])
	    ]),
	    footer: withCtx(() => [
	      createBaseVNode("button", {
	        type: "button",
	        disabled: $options.check_disable_apply(),
	        onClick: _cache[5] || (_cache[5] = (...args) => ($options.apply && $options.apply(...args))),
	        class: "btn btn-primary"
	      }, toDisplayString($data.i18n('apply')), 9 /* TEXT, PROPS */, _hoisted_14$2)
	    ]),
	    _: 1 /* STABLE */
	  }, 8 /* PROPS */, ["id"]))
	}

	var css_248z$3 = "\ninput ~ .alert[data-v-3119c83e] {\n  display: none;\n}\ninput:invalid ~ .alert[data-v-3119c83e] {\n  display: block;\n}\n";
	styleInject(css_248z$3);

	script$4.render = render$2;
	script$4.__scopeId = "data-v-3119c83e";
	script$4.__file = "http_src/vue/modal-filters.vue";

	function get_page(alert_stats_page) {
	    let page = ntopng_url_manager.get_url_entry("page");
	    if (page == null) {
		if (alert_stats_page) {
		    page = "all";
		} else {
		    page = "overview";
		}
	    }
	    return page;
	}

	async function get_filter_const(is_alert_stats_url, page) {
	    let url_request;
	    if (is_alert_stats_url) {
		url_request = `${base_path}/lua/rest/v2/get/alert/filter/consts.lua?page=${page}`;
	    } else {
		let query_preset = ntopng_url_manager.get_url_entry("query_preset");
		if (query_preset == null) { query_preset = ""; }
		url_request = `${base_path}/lua/pro/rest/v2/get/db/filter/consts.lua?page=${page}&query_preset=${query_preset}`;
	    }
	    let filter_consts = await ntopng_utility.http_request(url_request);
	    return filter_consts;
	}

	let FILTERS_CONST = [];
	let TAG_OPERATORS;
	let DEFINED_TAGS;
	const VIEW_ONLY_TAGS = true;
	/* Initial Tags */
	let initialTags; 
	//let pageHandle = {};
	let TAGIFY;
	let IS_ALERT_STATS_URL = window.location.toString().match(/alert_stats.lua/) != null;
	let QUERY_PRESET = { 
	  value: ntopng_url_manager.get_url_entry("query_preset"),
	  count: ntopng_url_manager.get_url_entry("count"),
	};
	if (QUERY_PRESET.value == null) {
	    QUERY_PRESET.value = "";
	}
	let STATUS_VIEW = ntopng_url_manager.get_url_entry("status");
	if (STATUS_VIEW == null || STATUS_VIEW == "") {
	    STATUS_VIEW = "historical";
	}
	const ENABLE_QUERY_PRESETS = !IS_ALERT_STATS_URL;

	let PAGE = get_page(IS_ALERT_STATS_URL);

	const create_tag_from_filter = function(filter) {
	    let f_const = FILTERS_CONST.find((f) => f.id == filter.id);
	    if (f_const == null) { console.error("create_tag_from_filter: filter const not found;"); }
	    
	    let value_label = filter.value;
	    if (f_const.options != null) {
		let opt = f_const.options.find((o) => o.value == filter.value);
		if (opt != null) {
		    value_label = opt.label;
		}
	    }
	    const tag = {
		label: f_const.label,
		key: f_const.id,
		value: value_label,
		realValue: filter.value,
		title: `${f_const.label}${filter.operator}${value_label}`,
		selectedOperator: filter.operator,
	    };
	    if (tag.value == "") { tag.value = "''"; }
	    if (tag.realValue == null || tag.selectedOperator == null || tag.selectedOperator == "") {
		return null;
	    }
	    return tag;
	};  

	const load_filters_data = async function() {    
	    FILTERS_CONST = await get_filter_const(IS_ALERT_STATS_URL, PAGE);
	    FILTERS_CONST.filter((x) => x.label == null).forEach((x) => { console.error(`label not defined for filter ${JSON.stringify(x)}`); x.label = ""; });
	    FILTERS_CONST.sort((a, b) => a.label.localeCompare(b.label));
	    i18n_ext.tags = {};
	    TAG_OPERATORS = {};
	    DEFINED_TAGS = {};
	    FILTERS_CONST.forEach((f_def) => {
		i18n_ext.tags[f_def.id] = f_def.label;
		f_def.operators.forEach((op) => TAG_OPERATORS[op.id] = op.label);
		DEFINED_TAGS[f_def.id] = f_def.operators.map((op) => op.id);
	    });
	    let entries = ntopng_url_manager.get_url_entries();
	    let filters = [];
	    for (const [key, value] of entries) {
	    	let filter_def = FILTERS_CONST.find((fc) => fc.id == key);
	    	if (filter_def != null) {
	    	    let options_string = value.split(",");
		    options_string.forEach((opt_stirng) => {
	    		let [value, operator] = opt_stirng.split(";");
			if (
			    operator == null || value == null || operator == ""
			    || (filter_def.options != null && filter_def.options.find((opt) => opt.value == value) == null)
			   ) {
			    return;
			}
			filters.push({id: filter_def.id, operator: operator, value: value});
		    });
	    	}	
	    }
	    return filters;
	    // "l7proto=XXX;eq"
	};

	function get_filters_object(filters) {
	    if (filters == null) { return {}; }
	    let filters_groups = {};
	    filters.forEach((f) => {
		let group = filters_groups[f.id];
		if (group == null) {
		    group = [];
		    filters_groups[f.id] = group;
		}
		group.push(f);
	    });
	    let filters_object = {};
	    for (let f_id in filters_groups) {
		let group = filters_groups[f_id];
		let filter_values = group.filter((f) => f.value != null && f.operator != null && f.operator != "").map((f) => `${f.value};${f.operator}`).join(",");
		filters_object[f_id] = filter_values;
	    }
	    return filters_object;
	}

	async function set_query_preset(range_picker_vue) {
	    let page = range_picker_vue.page;
	    let url_request = `${base_path}/lua/pro/rest/v2/get/db/preset/consts.lua?page=${page}`;
	    let res = await ntopng_utility.http_request(url_request);
	    let query_presets = res[0].list.map((el) => {
		return {
		    value: el.id, //== null ? "flow" : el.id,
		    name: el.name,
		    count: el.count,
		    builtin: true,
		};
	    });
	    if (res.length > 1) {
		res[1].list.forEach((el) => {
	    	    let query = {
	    		value: el.id,
	    		name: el.name,
		        count: el.count,
	    	    };
	    	    query_presets.push(query);
		});
	    }
	    if (range_picker_vue.query_preset == null || range_picker_vue.query_preset.value == "") {
		range_picker_vue.query_preset = query_presets[0];
	    } else {
		let q = query_presets.find((i) => i.value == range_picker_vue.query_preset.value);
	       range_picker_vue.query_preset = q;
	    }
	    ntopng_url_manager.set_key_to_url("query_preset", range_picker_vue.query_preset.value);
	    ntopng_url_manager.set_key_to_url("count", range_picker_vue.query_preset.count);
	    range_picker_vue.query_presets = query_presets;
	    return res;
	}

	var script$3 = {
	    props: {
		id: String,
	    },
	    components: {	  
	   	'data-time-range-picker': script$z,
		'modal-filters': script$4,
	    },
	    /**
	     * First method called when the component is created.
	     */
	    created() {
	    },
	    async mounted() {
		let dt_range_picker_mounted = ntopng_sync.on_ready(this.id_data_time_range_picker);
		ntopng_sync.on_ready(this.id_modal_filters);
		await dt_range_picker_mounted;

		if (this.enable_query_presets) {
		    await set_query_preset(this);
		}
		if (this.page != 'all') {
		    let filters = await load_filters_data();
		    
		    TAGIFY = create_tagify(this);
		    ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, {filters});
		    ntopng_events_manager.on_event_change(this.$props["id"], ntopng_events.FILTERS_CHANGE, (status) => this.reload_status(status), true);
		}
		this.modal_data = FILTERS_CONST;
		
		//await modal_filters_mounted;
		ntopng_sync.ready(this.$props["id"]);
	    },
	    data() {
		return {
		    i18n: i18n,
		    id_modal_filters: `${this.$props.id}_modal_filters`,
		    id_data_time_range_picker: `${this.$props.id}_data-time-range-picker`,
		    show_filters: false,
		    edit_tag: null,
		    is_alert_stats_url: IS_ALERT_STATS_URL,
		    query_presets: [],
		    query_preset: QUERY_PRESET,
		    status_view: STATUS_VIEW,
		    enable_query_presets: ENABLE_QUERY_PRESETS,
		    page: PAGE,
		    modal_data: [],
		    last_filters: [],
		};
	    },
	    methods: {
		is_filter_defined: function(filter) {
		    return DEFINED_TAGS[filter.id] != null;
		},
		update_status_view: function(status) {
		    ntopng_url_manager.set_key_to_url("status", status);
		    ntopng_url_manager.reload_url();	    
		},
		update_select_query_presets: function() {
		    ntopng_url_manager.get_url_params();
		    ntopng_url_manager.set_key_to_url("query_preset", this.query_preset.value);
		    ntopng_url_manager.set_key_to_url("count", this.query_preset.count);
		    ntopng_url_manager.reload_url();
		},
		show_modal_filters: function() {
		    this.$refs["modal_filters"].show();
		},
		remove_filters: function() {
		    let filters = [];
		    ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, {filters});
		},
		reload_status: function(status) {
		    let filters = status.filters;
		    if (filters == null) { return; }
		    // delete all previous filter
		    ntopng_url_manager.delete_params(FILTERS_CONST.map((f) => f.id));
		    TAGIFY.tagify.removeAllTags();
		    let filters_object = get_filters_object(filters);
		    ntopng_url_manager.add_obj_to_url(filters_object);
		    filters.forEach((f) => {
			let tag = create_tag_from_filter(f);
			if (tag == null) { return; }
			TAGIFY.addFilterTag(tag);
		    });
		    this.last_filters = filters;
		},
		apply_modal: function(params) {
		    let status = ntopng_status_manager.get_status();
		    let filters = status.filters;
		    if (filters == null) { filters = []; }
		    if (this.edit_tag != null) {
			filters = filters.filter((f) => f.id != this.edit_tag.key || f.value != this.edit_tag.realValue);
			this.edit_tag = null;
		    }
		    filters.push(params);
		    // trigger event and then call reload_status
		    ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, {filters});
		},
	    },
	};

	function create_tagify(range_picker_vue) {
	    // create tagify
	    const tagify = new Tagify(range_picker_vue.$refs["tagify"], {
		duplicates: true,
		delimiters : null,
		dropdown : {
	            enabled: 1, // suggest tags after a single character input
	            classname : 'extra-properties' // custom class for the suggestions dropdown
		},
		autoComplete: { enabled: false },
		templates : {
	            tag : function(tagData){
			try{
	                    return `<tag title='${tagData.value}' contenteditable='false' spellcheck="false" class='tagify__tag ${tagData.class ? tagData.class : ""}' ${this.getAttributes(tagData)}>
                        <x title='remove tag' class='tagify__tag__removeBtn'></x>
                        <div>
                            ${tagData.label ? `<b>${tagData.label}</b>&nbsp;` : ``}
                            ${!VIEW_ONLY_TAGS && tagData.operators ? `<select class='operator'>${tagData.operators.map(op => `<option ${tagData.selectedOperator === op ? 'selected' : ''} value='${op}'>${TAG_OPERATORS[op]}</option>`).join()}</select>` : `<b class='operator'>${tagData.selectedOperator ? TAG_OPERATORS[tagData.selectedOperator] : '='}</b>`}&nbsp;
                            <span class='tagify__tag-text'>${tagData.value}</span>
                        </div>
                    </tag>`
			}
			catch(err){
	                    console.error(`An error occured when creating a new tag: ${err}`);
			}
	            },
		},
		validate: function(tagData) {
		    return (typeof tagData.key !== 'undefined' &&
			    typeof tagData.selectedOperator !== 'undefined' &&
			    typeof tagData.value !== 'undefined');
		}
	    });
	    
	    $(document).ready(function() {
		// add existing tags
		tagify.addTags(initialTags);
	    }); /* $(document).ready() */
	    
	    const addFilterTag = async function(tag) {
	        /* Convert values to string (this avoids issues e.g. with 0) */
	        if (typeof tag.realValue == 'number') { tag.realValue = ''+tag.realValue; }
	        if (typeof tag.value == 'number') { tag.value = ''+tag.value; }
		
	        const existingTagElms = tagify.getTagElms();
		
	        /* Lookup by key, value and operator (do not add the same key and value multiple times) */
	        let existingTagElement = existingTagElms.find(htmlTag => 
							      htmlTag.getAttribute('key') === tag.key
							      && htmlTag.getAttribute('realValue') === tag.realValue 
							      //&& htmlTag.getAttribute('selectedOperator') === tag.selectedOperator
							     );
	        let existingTag = tagify.tagData(existingTagElement);
	        if (existingTag !== undefined) {
	            return;
	        }
		
	        // has the tag an operator object?
	        if (DEFINED_TAGS[tag.key] && !Array.isArray(DEFINED_TAGS[tag.key])) {
	            tag.operators = DEFINED_TAGS[tag.key].operators;
	        }
		
	        if (!tag.selectedOperator) {
	            tag.selectedOperator = 'eq';
	        }
	        // add filter!
	        tagify.addTags([tag]);
	    };
	    
	    // when an user remove the tag
	    tagify.on('remove', async function(e) {
	      const key = e.detail.data.key;
	      const value = e.detail.data.realValue;
	      const status = ntopng_status_manager.get_status();
	      
	      if (key === undefined) { return; }
	      if (status.filters == null) { return; }

	      const filters = status.filters.filter((f) => (f.id != key || (f.id == key && f.value != value)));
	      ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, {filters});	
	    });
	    
	    tagify.on('add', async function(e) {
	        const detail = e.detail;
	        if (detail.data === undefined) { return; }	
	        const tag = detail.data;	
	        // let's check if the tag has a key field
	        if (!tag.key) {
	            tagify.removeTags([e.detail.tag]);
	            e.preventDefault();
	            e.stopPropagation();
	            return;
	        }	
	    });
	    
	    // Tag 'click' event handler to open the 'Edit' modal. Note: this prevents
	    // inline editing of the tag ('edit:updated' is never called as a consequence)
	    tagify.on('click', async function(e) {
	        const detail = e.detail;	
	        if (detail.data === undefined) { return; }
	        if (detail.data.key === undefined) {return;}
	        const tag = detail.data;
		// remember that this tag already exixts
		range_picker_vue.edit_tag = tag;
		// show modal-filters
		ntopng_events_manager.emit_custom_event(ntopng_custom_events.SHOW_MODAL_FILTERS, {id: tag.key, operator: tag.selectedOperator, value: tag.realValue});
	    });
	    
	    tagify.on('edit:updated', async function(e) {
		console.warn("UPDATED");
		return;
	    });
	    
	    $(`tags`).on('change', 'select.operator', async function(e) {
		console.warn("TAGS change");
		return;
	    });
	    return {
		tagify,
		addFilterTag,
	    };
	}

	const _withScopeId$2 = n => (pushScopeId("data-v-aaee59ea"),n=n(),popScopeId(),n);
	const _hoisted_1$3 = { style: {"width":"100%"} };
	const _hoisted_2$3 = { class: "mb-1" };
	const _hoisted_3$3 = {
	  key: 0,
	  class: "d-flex align-items-center me-2"
	};
	const _hoisted_4$3 = {
	  class: "btn-group",
	  id: "statusSwitch",
	  role: "group"
	};
	const _hoisted_5$3 = ["value"];
	const _hoisted_6$3 = ["label"];
	const _hoisted_7$3 = ["value"];
	const _hoisted_8$3 = {
	  key: 0,
	  class: "d-flex mt-1",
	  style: {"width":"100%"}
	};
	const _hoisted_9$3 = ["placeholder"];
	const _hoisted_10$2 = /*#__PURE__*/ _withScopeId$2(() => /*#__PURE__*/createBaseVNode("span", null, [
	  /*#__PURE__*/createBaseVNode("i", {
	    class: "fas fa-plus",
	    "data-original-title": "",
	    title: "Add Filter"
	  })
	], -1 /* HOISTED */));
	const _hoisted_11$2 = [
	  _hoisted_10$2
	];
	const _hoisted_12$2 = /*#__PURE__*/ _withScopeId$2(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-times" }, null, -1 /* HOISTED */));
	const _hoisted_13$2 = [
	  _hoisted_12$2
	];

	function render$1(_ctx, _cache, $props, $setup, $data, $options) {
	  const _component_modal_filters = resolveComponent("modal-filters");
	  const _component_data_time_range_picker = resolveComponent("data-time-range-picker");

	  return (openBlock(), createElementBlock("div", _hoisted_1$3, [
	    createBaseVNode("div", _hoisted_2$3, [
	      createVNode(_component_modal_filters, {
	        filters_options: $data.modal_data,
	        onApply: $options.apply_modal,
	        ref: "modal_filters",
	        id: $data.id_modal_filters
	      }, null, 8 /* PROPS */, ["filters_options", "onApply", "id"]),
	      createVNode(_component_data_time_range_picker, { id: $data.id_data_time_range_picker }, {
	        begin: withCtx(() => [
	          ($data.is_alert_stats_url)
	            ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
	                createBaseVNode("div", _hoisted_4$3, [
	                  createBaseVNode("a", {
	                    href: "#",
	                    onClick: _cache[0] || (_cache[0] = $event => ($options.update_status_view('historical'))),
	                    class: normalizeClass(["btn btn-sm", {'active': $data.status_view == 'historical', 'btn-seconday': $data.status_view != 'historical', 'btn-primary': $data.status_view == 'historical'}])
	                  }, "Past", 2 /* CLASS */),
	                  createBaseVNode("a", {
	                    href: "#",
	                    onClick: _cache[1] || (_cache[1] = $event => ($options.update_status_view('acknowledged'))),
	                    class: normalizeClass(["btn btn-sm", {'active': $data.status_view == 'acknowledged', 'btn-seconday': $data.status_view != 'acknowledged', 'btn-primary': $data.status_view == 'acknowledged'}])
	                  }, "Ack", 2 /* CLASS */),
	                  ($data.page != 'flow')
	                    ? (openBlock(), createElementBlock("a", {
	                        key: 0,
	                        href: "#",
	                        onClick: _cache[2] || (_cache[2] = $event => ($options.update_status_view('engaged'))),
	                        class: normalizeClass(["btn btn-sm", {'active': $data.status_view == 'engaged', 'btn-seconday': $data.status_view != 'engaged', 'btn-primary': $data.status_view == 'engaged'}])
	                      }, "Engaged", 2 /* CLASS */))
	                    : createCommentVNode("v-if", true)
	                ])
	              ]))
	            : createCommentVNode("v-if", true),
	          ($data.enable_query_presets)
	            ? withDirectives((openBlock(), createElementBlock("select", {
	                key: 1,
	                class: "me-2 form-select",
	                "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => (($data.query_preset) = $event)),
	                onChange: _cache[4] || (_cache[4] = $event => ($options.update_select_query_presets()))
	              }, [
	                (openBlock(true), createElementBlock(Fragment, null, renderList($data.query_presets, (item) => {
	                  return (openBlock(), createElementBlock(Fragment, null, [
	                    (item.builtin == true)
	                      ? (openBlock(), createElementBlock("option", {
	                          key: 0,
	                          value: item
	                        }, toDisplayString(item.name), 9 /* TEXT, PROPS */, _hoisted_5$3))
	                      : createCommentVNode("v-if", true)
	                  ], 64 /* STABLE_FRAGMENT */))
	                }), 256 /* UNKEYED_FRAGMENT */)),
	                ($data.page != 'analysis')
	                  ? (openBlock(), createElementBlock("optgroup", {
	                      key: 0,
	                      label: $data.i18n('queries.queries')
	                    }, [
	                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.query_presets, (item) => {
	                        return (openBlock(), createElementBlock(Fragment, null, [
	                          (!item.builtin)
	                            ? (openBlock(), createElementBlock("option", {
	                                key: 0,
	                                value: item
	                              }, toDisplayString(item.name), 9 /* TEXT, PROPS */, _hoisted_7$3))
	                            : createCommentVNode("v-if", true)
	                        ], 64 /* STABLE_FRAGMENT */))
	                      }), 256 /* UNKEYED_FRAGMENT */))
	                    ], 8 /* PROPS */, _hoisted_6$3))
	                  : createCommentVNode("v-if", true)
	              ], 544 /* HYDRATE_EVENTS, NEED_PATCH */)), [
	                [vModelSelect, $data.query_preset]
	              ])
	            : createCommentVNode("v-if", true)
	        ]),
	        extra_buttons: withCtx(() => [
	          renderSlot(_ctx.$slots, "extra_range_buttons")
	        ]),
	        _: 3 /* FORWARDED */
	      }, 8 /* PROPS */, ["id"])
	    ]),
	    createCommentVNode(" tagify "),
	    ($data.page != 'all')
	      ? (openBlock(), createElementBlock("div", _hoisted_8$3, [
	          createBaseVNode("input", {
	            class: "w-100 form-control h-auto",
	            name: "tags",
	            ref: "tagify",
	            placeholder: $data.i18n('show_alerts.filters')
	          }, null, 8 /* PROPS */, _hoisted_9$3),
	          withDirectives(createBaseVNode("button", {
	            class: "btn btn-link",
	            "aria-controls": "flow-alerts-table",
	            type: "button",
	            id: "btn-add-alert-filter",
	            onClick: _cache[5] || (_cache[5] = (...args) => ($options.show_modal_filters && $options.show_modal_filters(...args)))
	          }, _hoisted_11$2, 512 /* NEED_PATCH */), [
	            [vShow, $data.modal_data && $data.modal_data.length > 0]
	          ]),
	          withDirectives(createBaseVNode("button", {
	            "data-bs-toggle": "tooltip",
	            "data-placement": "bottom",
	            title: "{{ i18n('show_alerts.remove_filters') }}",
	            onClick: _cache[6] || (_cache[6] = (...args) => ($options.remove_filters && $options.remove_filters(...args))),
	            class: "btn ms-1 my-auto btn-sm btn-remove-tags"
	          }, _hoisted_13$2, 512 /* NEED_PATCH */), [
	            [vShow, $data.modal_data && $data.modal_data.length > 0]
	          ])
	        ]))
	      : createCommentVNode("v-if", true),
	    createCommentVNode(" end tagify ")
	  ]))
	}

	var css_248z$2 = "\n.tagify__input[data-v-aaee59ea] {\n  min-width: 175px;\n}\n.tagify__tag[data-v-aaee59ea] {\n  white-space: nowrap;\n  margin: 3px 0px 5px 5px;\n}\n.tagify__tag select.operator[data-v-aaee59ea] {\n  margin: 0px 4px;\n  border: 1px solid #c4c4c4;\n  border-radius: 4px;\n}\n.tagify__tag b.operator[data-v-aaee59ea] {\n  margin: 0px 4px;\n  background-color: white;\n  border: 1px solid #c4c4c4;\n  border-radius: 4px;\n  padding: 0.05em 0.2em;\n}\n.tagify__tag > div[data-v-aaee59ea] {\n  display: flex;\n  align-items: center;\n}\n";
	styleInject(css_248z$2);

	script$3.render = render$1;
	script$3.__scopeId = "data-v-aaee59ea";
	script$3.__file = "http_src/vue/range-picker.vue";

	var script$2 = {
	    components: {
	    },
	    props: {
		chart_options: Object,
	    },
	    watch: {
		"chart_options": function(val, oldVal) {
		    this.reloaded_table();
		}
	    },
	    emits: [],
	    /** This method is the first method of the component called, it's called before html template creation. */
	    created() {
	    },
	    data() {
		return {
	        total:0,
	        percentile_sent:0,
	        percentile_rcvd:0,
	        avg_sent:0,
	        avg_rcvd:0,
		    max_sent: 0,
		    max_rcvd: 0,

		};
	    },
	    /** This method is the first method called after html template creation. */
	    async mounted() {
		console.log("Mounted Simple table");
	    },
	    methods: {
		reloaded_table: function() {
	        let fBit =  ntopChartApex.chartOptionsUtility.getApexYFormatter(ntopChartApex.chartOptionsUtility.apexYFormatterTypes.bps.id);
	        let fBytes = ntopChartApex.chartOptionsUtility.getApexYFormatter(ntopChartApex.chartOptionsUtility.apexYFormatterTypes.bytes.id);
		    console.log("reloaded table called");
		    //console.log(Object.keys(this.chart_options.statistics));
	        console.log(this.chart_options.statistics.by_serie);
	        console.log("OBJECT KEYS");
	        let total = this.chart_options.statistics.total;
	        let max_sent = this.chart_options.statistics.by_serie[0].max_val;
	        let max_rcvd = this.chart_options.statistics.by_serie[1].max_val;
	        let avg_sent = this.chart_options.statistics.by_serie[0].average;
	        let avg_rcvd = this.chart_options.statistics.by_serie[1].average;
	        let percentile_sent = this.chart_options.statistics.by_serie[0]["95th_percentile"];
	        let percentile_rcvd = this.chart_options.statistics.by_serie[1]["95th_percentile"];
	        this.max_sent = fBit(max_sent*8);
	        this.max_rcvd = fBit(max_rcvd*8);
	        this.avg_sent = fBit(avg_sent*8);
	        this.avg_rcvd = fBit(avg_rcvd*8);
	        this.percentile_sent = fBit(percentile_sent*8);
	        this.percentile_rcvd = fBit(percentile_rcvd*8);
	        this.total = fBytes(total);

		},
	    },
	};

	const _hoisted_1$2 = {
	  class: "table table-borderless graph-statistics mb-2",
	  style: {}
	};
	const _hoisted_2$2 = /*#__PURE__*/createBaseVNode("thead", { class: "text-center" }, [
	  /*#__PURE__*/createBaseVNode("tr", null, [
	    /*#__PURE__*/createBaseVNode("th", {
	      class: "graph-val-total-title fs-6",
	      style: {"border-left-width":"1px","border-top-width":"1px"}
	    }, " Total:"),
	    /*#__PURE__*/createBaseVNode("th", {
	      class: "graph-val-95percentile-title fs-6",
	      style: {"border-left-width":"1px","border-top-width":"1px"}
	    }, [
	      /*#__PURE__*/createTextVNode("95th "),
	      /*#__PURE__*/createBaseVNode("a", { href: "https://en.wikipedia.org/wiki/Percentile" }, "Percentile"),
	      /*#__PURE__*/createTextVNode(":")
	    ]),
	    /*#__PURE__*/createBaseVNode("th", {
	      class: "graph-val-average-title fs-6",
	      style: {"border-left-width":"1px","border-top-width":"1px"}
	    }, "Average:"),
	    /*#__PURE__*/createBaseVNode("th", {
	      class: "graph-val-max-title fs-6",
	      style: {"border-left-width":"1px","border-top-width":"1px","border-right-width":"1px"}
	    }, "Max:")
	  ])
	], -1 /* HOISTED */);
	const _hoisted_3$2 = {
	  class: "graph-val-total text-center",
	  style: {"border-width":"1px"}
	};
	const _hoisted_4$2 = {
	  class: "graph-val-95percentile text-center",
	  style: {"border-top-width":"1px","border-right-width":"1px","border-bottom-width":"1px"}
	};
	const _hoisted_5$2 = /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */);
	const _hoisted_6$2 = {
	  class: "graph-val-average text-center",
	  style: {"border-top-width":"1px","border-right-width":"1px","border-bottom-width":"1px"}
	};
	const _hoisted_7$2 = /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */);
	const _hoisted_8$2 = {
	  class: "graph-val-max text-center",
	  style: {"border-bottom-width":"1px","border-top-width":"1px","border-right-width":"1px"}
	};
	const _hoisted_9$2 = /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */);

	function render(_ctx, _cache, $props, $setup, $data, $options) {
	  return (openBlock(), createElementBlock("div", null, [
	    createBaseVNode("table", _hoisted_1$2, [
	      _hoisted_2$2,
	      createBaseVNode("tbody", null, [
	        createBaseVNode("tr", null, [
	          createBaseVNode("td", _hoisted_3$2, [
	            createBaseVNode("span", null, toDisplayString($data.total), 1 /* TEXT */)
	          ]),
	          createBaseVNode("td", _hoisted_4$2, [
	            createBaseVNode("span", null, [
	              createTextVNode(toDisplayString($data.percentile_sent) + " [Sent]", 1 /* TEXT */),
	              _hoisted_5$2,
	              createTextVNode(toDisplayString($data.percentile_rcvd) + " [Rcvd]", 1 /* TEXT */)
	            ])
	          ]),
	          createBaseVNode("td", _hoisted_6$2, [
	            createBaseVNode("span", null, [
	              createTextVNode(toDisplayString($data.avg_sent) + " Kbit/s [Sent]", 1 /* TEXT */),
	              _hoisted_7$2,
	              createTextVNode(toDisplayString($data.avg_rcvd) + " [Rcvd]", 1 /* TEXT */)
	            ])
	          ]),
	          createCommentVNode(" <td class=\"graph-val-min\" style=\"display:none;border-bottom-width: 1px;border-top-width: 1px;border-right-width: 1px;\">nil: <span></span></td> "),
	          createBaseVNode("td", _hoisted_8$2, [
	            createBaseVNode("span", null, [
	              createTextVNode(toDisplayString($data.max_sent) + " [Sent]", 1 /* TEXT */),
	              _hoisted_9$2,
	              createTextVNode(toDisplayString($data.max_rcvd) + " [Rcvd]", 1 /* TEXT */)
	            ])
	          ])
	        ])
	      ])
	    ])
	  ]))
	}

	script$2.render = render;
	script$2.__file = "http_src/vue/simple-table.vue";

	const _withScopeId$1 = n => (pushScopeId("data-v-7e5acce0"),n=n(),popScopeId(),n);
	const _hoisted_1$1 = { class: "mb-3 row" };
	const _hoisted_2$1 = { class: "col-form-label col-sm-4" };
	const _hoisted_3$1 = { class: "col-sm-6" };
	const _hoisted_4$1 = {
	  class: "btn-group btn-group-toggle",
	  "data-bs-toggle": "buttons"
	};
	const _hoisted_5$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("hr", null, null, -1 /* HOISTED */));
	const _hoisted_6$1 = { class: "host-alert-fields" };
	const _hoisted_7$1 = { class: "mb-3 row" };
	const _hoisted_8$1 = { class: "col-form-label col-sm-4" };
	const _hoisted_9$1 = { class: "col-sm-6" };
	const _hoisted_10$1 = { value: "" };
	const _hoisted_11$1 = { value: "0" };
	const _hoisted_12$1 = { disabled: "" };
	const _hoisted_13$1 = ["value"];
	const _hoisted_14$1 = { class: "flow-alert-fields" };
	const _hoisted_15$1 = { class: "mb-3 row" };
	const _hoisted_16$1 = { class: "col-form-label col-sm-4" };
	const _hoisted_17$1 = { class: "col-sm-6" };
	const _hoisted_18$1 = { value: "" };
	const _hoisted_19$1 = { value: "0" };
	const _hoisted_20$1 = { disabled: "" };
	const _hoisted_21$1 = ["value"];
	const _hoisted_22$1 = {
	  key: 0,
	  class: "ip-fields"
	};
	const _hoisted_23$1 = { class: "mb-3 row" };
	const _hoisted_24$1 = { class: "col-form-label col-sm-4" };
	const _hoisted_25$1 = { class: "col-sm-6" };
	const _hoisted_26$1 = ["pattern"];
	const _hoisted_27$1 = {
	  key: 1,
	  class: "network-fields"
	};
	const _hoisted_28 = { class: "mb-3 row" };
	const _hoisted_29 = { class: "col-form-label col-sm-4" };
	const _hoisted_30 = { class: "col-sm-4 pr-0" };
	const _hoisted_31 = ["pattern"];
	const _hoisted_32 = { class: "col-sm-2 ps-4 pe-0" };
	const _hoisted_33 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("span", { class: "me-2" }, "/", -1 /* HOISTED */));
	const _hoisted_34 = { class: "mb-3 row" };
	const _hoisted_35 = { class: "col-form-label col-sm-4" };
	const _hoisted_36 = { class: "col-sm-6" };
	const _hoisted_37 = { class: "mb-3 row" };
	const _hoisted_38 = { class: "col-form-label col-sm-4" };
	const _hoisted_39 = { key: 0 };
	const _hoisted_40 = { key: 1 };
	const _hoisted_41 = { class: "col-sm-6" };
	const _hoisted_42 = ["pattern"];
	const _hoisted_43 = ["pattern"];
	const _hoisted_44 = ["disabled"];


	var script$1 = {
	  __name: 'modal-add-check-exclusion',
	  props: {
	    alert_exclusions_page: String,
	    host_alert_types: Array,
	    flow_alert_types: Array,    
	},
	  emits: ['add'],
	  setup(__props, { expose, emit }) {

	const props = __props;

	const modal_id = ref(null);
	const exclude_type = ref("ip");
	const input_ip = ref("");
	const input_network = ref("");
	const input_vlan = ref(0);
	const input_text = ref("");
	const host_selected = ref("");
	const flow_selected = ref("");
	const netmask = ref("");


	//s.split(",").every((a) => {return /.+=.+/.test(a)})
	function get_data_pattern(value_type) {
	    if (value_type == "text") {
		return NtopUtils.REGEXES.non_quoted_text;
	    } else if (value_type == "ip") {
		let r_ipv4 = NtopUtils.REGEXES.ipv4;
		let r_ipv4_vlan = r_ipv4.replace("$", "@[0-9]{0,5}$");
		let r_ipv6 = NtopUtils.REGEXES.ipv6;
		let r_ipv6_vlan = r_ipv6.replaceAll("$", "@[0-9]{0,5}$");
		return `(${r_ipv4})|(${r_ipv4_vlan})|(${r_ipv6})|(${r_ipv6_vlan})`;
	    } else if (value_type == "hostname") {
		return `${NtopUtils.REGEXES.singleword}|[a-zA-Z0-9._\-]{3,250}@[0-9]{0,5}$`;
	    } else if (value_type == "certificate") {
		return NtopUtils.REGEXES.tls_certificate;
	    }
	    return NtopUtils.REGEXES[value_type];
	}



	let pattern_ip = get_data_pattern("ip");
	let pattern_text = get_data_pattern("text");
	let pattern_certificate = get_data_pattern("certificate");

	const set_exclude_type = (type) => {
	    exclude_type.value = type;
	};

	const check_disable_apply = () => {
	    let regex = null;
	    let disable_apply = true;
	    if (props.alert_exclusions_page == 'hosts') {
		regex = new RegExp(pattern_ip);
		if (exclude_type.value == "ip") {
		    disable_apply = (input_ip.value == null || input_ip.value == "") || (regex.test(input_ip.value) == false) || (host_selected.value == "" && flow_selected.value == "");
		} else {
		    disable_apply = (input_network.value == null || input_network.value == "")
			|| (regex.test(input_network.value) == false)
			|| (host_selected.value == "" && flow_selected.value == "")
			|| (netmask.value == null || netmask.value == "" || parseInt(netmask.value) < 1 || parseInt(netmask.value) > 127);
		}
	    } else if (props.alert_exclusions_page == 'domain_names') {
		regex = new RegExp(pattern_text);
		disable_apply = (input_text.value == null || input_text.value == "") || (regex.test(input_text.value) == false);
		
	    } else if (props.alert_exclusions_page == 'tls_certificate') {
		regex = new RegExp(pattern_certificate);
		disable_apply = (input_text.value == null || input_text.value == "") || (regex.test(input_text.value) == false);
	    }
	    return disable_apply;
	};

	const showed = () => {};

	const show = () => {
	    exclude_type.value = "ip";
	    input_ip.value = "";
	    input_network.value = "";
	    input_vlan.value = 0;
	    host_selected.value = "";
	    flow_selected.value = "";
	    netmask.value = "";
	    input_text.value = "";
	    modal_id.value.show();
	};

	const close = () => {
	    modal_id.value.close();
	};

	const add = () => {
	    let params;
	    let alert_addr = input_ip.value;
	    if (props.alert_exclusions_page == "hosts") {
		if (exclude_type.value == "network") {
		    alert_addr = `${input_network.value}/${netmask.value}`;
		}
	        if (input_vlan.value != null && input_vlan.value != 0) {
		    alert_addr = `${alert_addr}@${input_vlan.value}`;
	        }
		params = { alert_addr, host_alert_key: host_selected.value, flow_alert_key: flow_selected.value };
	    } else if (props.alert_exclusions_page == "domain_names") {
		params = { alert_domain: input_text.value };
	    } else if (props.alert_exclusions_page == "tls_certificate") {
		params = { alert_certificate: input_text.value };
	    }
	    emit('add', params);
	    close();
	};

	expose({ show, close });

	onMounted(() => {
	});

	const _i18n = (t) => i18n(t);


	return (_ctx, _cache) => {
	  return (openBlock(), createBlock(script$y, {
	    onShowed: _cache[10] || (_cache[10] = $event => (showed())),
	    ref_key: "modal_id",
	    ref: modal_id
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(_i18n("check_exclusion.add_exclusion")), 1 /* TEXT */)
	    ]),
	    body: withCtx(() => [
	      (__props.alert_exclusions_page == 'hosts')
	        ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
	            createCommentVNode(" modal hosts "),
	            createBaseVNode("div", _hoisted_1$1, [
	              createBaseVNode("label", _hoisted_2$1, [
	                createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.member_type")), 1 /* TEXT */)
	              ]),
	              createBaseVNode("div", _hoisted_3$1, [
	                createBaseVNode("div", _hoisted_4$1, [
	                  createBaseVNode("label", {
	                    class: normalizeClass([{'active': exclude_type.value == 'ip'}, "btn btn-secondary"])
	                  }, [
	                    createBaseVNode("input", {
	                      class: "btn-check",
	                      type: "radio",
	                      name: "member_type",
	                      value: "ip",
	                      onClick: _cache[0] || (_cache[0] = $event => (set_exclude_type('ip')))
	                    }),
	                    createTextVNode(" " + toDisplayString(_i18n("check_exclusion.ip_address")), 1 /* TEXT */)
	                  ], 2 /* CLASS */),
	                  createBaseVNode("label", {
	                    class: normalizeClass([{'active': exclude_type.value == 'network'}, "btn btn-secondary"])
	                  }, [
	                    createBaseVNode("input", {
	                      onClick: _cache[1] || (_cache[1] = $event => (set_exclude_type('network'))),
	                      class: "btn-check",
	                      type: "radio",
	                      name: "member_type",
	                      value: "network"
	                    }),
	                    createTextVNode(" " + toDisplayString(_i18n("check_exclusion.network")), 1 /* TEXT */)
	                  ], 2 /* CLASS */)
	                ])
	              ])
	            ]),
	            _hoisted_5$1,
	            createBaseVNode("div", _hoisted_6$1, [
	              createBaseVNode("div", _hoisted_7$1, [
	                createBaseVNode("label", _hoisted_8$1, [
	                  createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.host_alert_type")), 1 /* TEXT */)
	                ]),
	                createBaseVNode("div", _hoisted_9$1, [
	                  withDirectives(createBaseVNode("select", {
	                    name: "value",
	                    class: "form-select alert-select",
	                    "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((host_selected).value = $event))
	                  }, [
	                    createBaseVNode("option", _hoisted_10$1, toDisplayString(_i18n("check_exclusion.none")), 1 /* TEXT */),
	                    createBaseVNode("option", _hoisted_11$1, toDisplayString(_i18n("check_exclusion.exclude_all_alerts")), 1 /* TEXT */),
	                    createBaseVNode("option", _hoisted_12$1, toDisplayString(_i18n("check_exclusion.spacing_bar")), 1 /* TEXT */),
	                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.host_alert_types, (item) => {
	                      return (openBlock(), createElementBlock(Fragment, null, [
	                        (item != null)
	                          ? (openBlock(), createElementBlock("option", {
	                              key: 0,
	                              value: item.alert_id
	                            }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_13$1))
	                          : createCommentVNode("v-if", true)
	                      ], 64 /* STABLE_FRAGMENT */))
	                    }), 256 /* UNKEYED_FRAGMENT */))
	                  ], 512 /* NEED_PATCH */), [
	                    [vModelSelect, host_selected.value]
	                  ])
	                ])
	              ])
	            ]),
	            createBaseVNode("div", _hoisted_14$1, [
	              createBaseVNode("div", _hoisted_15$1, [
	                createBaseVNode("label", _hoisted_16$1, [
	                  createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.flow_alert_type")), 1 /* TEXT */)
	                ]),
	                createBaseVNode("div", _hoisted_17$1, [
	                  withDirectives(createBaseVNode("select", {
	                    id: "flow-alert-select",
	                    name: "value",
	                    class: "form-select alert-select",
	                    "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ((flow_selected).value = $event))
	                  }, [
	                    createBaseVNode("option", _hoisted_18$1, toDisplayString(_i18n("check_exclusion.none")), 1 /* TEXT */),
	                    createBaseVNode("option", _hoisted_19$1, toDisplayString(_i18n("check_exclusion.exclude_all_alerts")), 1 /* TEXT */),
	                    createBaseVNode("option", _hoisted_20$1, toDisplayString(_i18n("check_exclusion.spacing_bar")), 1 /* TEXT */),
	                    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.flow_alert_types, (item) => {
	                      return (openBlock(), createElementBlock(Fragment, null, [
	                        (item != null)
	                          ? (openBlock(), createElementBlock("option", {
	                              key: 0,
	                              value: item.alert_id
	                            }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_21$1))
	                          : createCommentVNode("v-if", true)
	                      ], 64 /* STABLE_FRAGMENT */))
	                    }), 256 /* UNKEYED_FRAGMENT */))
	                  ], 512 /* NEED_PATCH */), [
	                    [vModelSelect, flow_selected.value]
	                  ])
	                ])
	              ])
	            ]),
	            (exclude_type.value == 'ip')
	              ? (openBlock(), createElementBlock("div", _hoisted_22$1, [
	                  createBaseVNode("div", _hoisted_23$1, [
	                    createBaseVNode("label", _hoisted_24$1, [
	                      createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.ip_address")), 1 /* TEXT */)
	                    ]),
	                    createBaseVNode("div", _hoisted_25$1, [
	                      withDirectives(createBaseVNode("input", {
	                        pattern: unref(pattern_ip),
	                        placeholder: "192.168.1.1",
	                        required: "",
	                        type: "text",
	                        name: "ip_address",
	                        class: "form-control",
	                        "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((input_ip).value = $event))
	                      }, null, 8 /* PROPS */, _hoisted_26$1), [
	                        [vModelText, input_ip.value]
	                      ])
	                    ])
	                  ])
	                ]))
	              : createCommentVNode("v-if", true),
	            (exclude_type.value == 'network')
	              ? (openBlock(), createElementBlock("div", _hoisted_27$1, [
	                  createBaseVNode("div", _hoisted_28, [
	                    createBaseVNode("label", _hoisted_29, [
	                      createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.network")), 1 /* TEXT */)
	                    ]),
	                    createBaseVNode("div", _hoisted_30, [
	                      withDirectives(createBaseVNode("input", {
	                        required: "",
	                        style: {"width":"calc(100% - 10px)"},
	                        name: "network",
	                        class: "form-control d-inline",
	                        placeholder: "172.16.0.0",
	                        pattern: unref(pattern_ip),
	                        "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => ((input_network).value = $event))
	                      }, null, 8 /* PROPS */, _hoisted_31), [
	                        [vModelText, input_network.value]
	                      ])
	                    ]),
	                    createBaseVNode("div", _hoisted_32, [
	                      _hoisted_33,
	                      withDirectives(createBaseVNode("input", {
	                        placeholder: "24",
	                        required: "",
	                        class: "form-control d-inline w-75",
	                        min: "1",
	                        max: "127",
	                        type: "number",
	                        name: "cidr",
	                        "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((netmask).value = $event))
	                      }, null, 512 /* NEED_PATCH */), [
	                        [vModelText, netmask.value]
	                      ])
	                    ])
	                  ])
	                ]))
	              : createCommentVNode("v-if", true),
	            createBaseVNode("div", _hoisted_34, [
	              createBaseVNode("label", _hoisted_35, [
	                createBaseVNode("b", null, toDisplayString(_i18n('vlan')), 1 /* TEXT */)
	              ]),
	              createBaseVNode("div", _hoisted_36, [
	                withDirectives(createBaseVNode("input", {
	                  placeholder: "0",
	                  min: "0",
	                  type: "number",
	                  "onUpdate:modelValue": _cache[7] || (_cache[7] = $event => ((input_vlan).value = $event)),
	                  class: "form-control"
	                }, null, 512 /* NEED_PATCH */), [
	                  [vModelText, input_vlan.value]
	                ])
	              ])
	            ])
	          ], 64 /* STABLE_FRAGMENT */))
	        : createCommentVNode("v-if", true),
	      createCommentVNode(" mdoal hosts "),
	      (__props.alert_exclusions_page != 'hosts')
	        ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
	            createCommentVNode(" modal domain_names"),
	            createBaseVNode("div", null, [
	              createBaseVNode("div", _hoisted_37, [
	                createBaseVNode("label", _hoisted_38, [
	                  (__props.alert_exclusions_page == 'domain_names')
	                    ? (openBlock(), createElementBlock("b", _hoisted_39, toDisplayString(_i18n("check_exclusion.domain")), 1 /* TEXT */))
	                    : createCommentVNode("v-if", true),
	                  (__props.alert_exclusions_page == 'tls_certificate')
	                    ? (openBlock(), createElementBlock("b", _hoisted_40, toDisplayString(_i18n("check_exclusion.tls_certificate")), 1 /* TEXT */))
	                    : createCommentVNode("v-if", true)
	                ]),
	                createBaseVNode("div", _hoisted_41, [
	                  (__props.alert_exclusions_page == 'domain_names')
	                    ? withDirectives((openBlock(), createElementBlock("input", {
	                        key: 0,
	                        placeholder: "",
	                        pattern: unref(pattern_text),
	                        required: "",
	                        type: "text",
	                        name: "ip_address",
	                        class: "form-control",
	                        "onUpdate:modelValue": _cache[8] || (_cache[8] = $event => ((input_text).value = $event))
	                      }, null, 8 /* PROPS */, _hoisted_42)), [
	                        [vModelText, input_text.value]
	                      ])
	                    : createCommentVNode("v-if", true),
	                  (__props.alert_exclusions_page == 'tls_certificate')
	                    ? withDirectives((openBlock(), createElementBlock("input", {
	                        key: 1,
	                        placeholder: "CN=813845657003339838, O=Code42, OU=TEST, ST=MN, C=U",
	                        pattern: unref(pattern_certificate),
	                        required: "",
	                        type: "text",
	                        name: "ip_address",
	                        class: "form-control",
	                        "onUpdate:modelValue": _cache[9] || (_cache[9] = $event => ((input_text).value = $event))
	                      }, null, 8 /* PROPS */, _hoisted_43)), [
	                        [vModelText, input_text.value]
	                      ])
	                    : createCommentVNode("v-if", true)
	                ])
	              ])
	            ])
	          ], 64 /* STABLE_FRAGMENT */))
	        : createCommentVNode("v-if", true),
	      createCommentVNode(" modal domain_names")
	    ]),
	    footer: withCtx(() => [
	      createBaseVNode("button", {
	        type: "button",
	        disabled: check_disable_apply(),
	        onClick: add,
	        class: "btn btn-primary"
	      }, toDisplayString(_i18n('add')), 9 /* TEXT, PROPS */, _hoisted_44)
	    ]),
	    _: 1 /* STABLE */
	  }, 512 /* NEED_PATCH */))
	}
	}

	};

	var css_248z$1 = "\ninput[data-v-7e5acce0]:invalid {\n  border-color: #ff0000;\n}  \n";
	styleInject(css_248z$1);

	script$1.__scopeId = "data-v-7e5acce0";
	script$1.__file = "http_src/vue/modal-add-check-exclusion.vue";

	const _withScopeId = n => (pushScopeId("data-v-19c5b1f1"),n=n(),popScopeId(),n);
	const _hoisted_1 = ["innerHTML"];
	const _hoisted_2 = { class: "form-group mb-3" };
	const _hoisted_3 = ["innerHTML"];
	const _hoisted_4 = /*#__PURE__*/createTextVNode("\". ");
	const _hoisted_5 = { class: "alert_label" };
	const _hoisted_6 = { class: "form-check" };
	const _hoisted_7 = { class: "form-check-label" };
	const _hoisted_8 = {
	  key: 0,
	  class: "form-check"
	};
	const _hoisted_9 = { class: "form-check-label" };
	const _hoisted_10 = { class: "form-check" };
	const _hoisted_11 = { class: "form-check-label" };
	const _hoisted_12 = { class: "form-check" };
	const _hoisted_13 = { class: "form-check-label" };
	const _hoisted_14 = {
	  key: 0,
	  class: "exclude-domain-certificate"
	};
	const _hoisted_15 = { class: "alert_label" };
	const _hoisted_16 = {
	  key: 0,
	  class: "form-check"
	};
	const _hoisted_17 = { class: "form-check-label whitespace" };
	const _hoisted_18 = ["pattern", "disabled"];
	const _hoisted_19 = {
	  key: 1,
	  class: "form-check"
	};
	const _hoisted_20 = { class: "form-check-label whitespace" };
	const _hoisted_21 = ["disabled", "pattern"];
	const _hoisted_22 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/createBaseVNode("hr", { class: "separator" }, null, -1 /* HOISTED */));
	const _hoisted_23 = { class: "form-group mb-3" };
	const _hoisted_24 = { class: "custom-control custom-switch" };
	const _hoisted_25 = { class: "custom-control-label" };
	const _hoisted_26 = {
	  class: "alert alert-warning border",
	  role: "alert"
	};
	const _hoisted_27 = ["disabled"];


	var script = {
	  __name: 'modal-alerts-filter',
	  props: {
	    alert: Object,
	    page: String,
	},
	  emits: ['exclude'],
	  setup(__props, { expose, emit }) {

	const props = __props;

	const modal_id = ref(null);
	const radio_selected = ref("any");
	const disable_alerts = ref(true);
	const domain = ref(null);
	const tls_certificate = ref(null);



	const showed = () => {};



	watch(() => props.alert, (current_value, old_value) => {
	    if (current_value == null) { return; }
	    radio_selected.value = "any";
	    disable_alerts.value = true;
	    domain.value = current_value.info?.value == "" ? null : current_value.info?.value;
	    tls_certificate.value = current_value.info?.issuerdn == "" ? null : current_value.info?.issuerdn;
	});
	// const click_delete_disable_alerts = () => {
	// };

	const check_disable_apply = () => {
	    if (radio_selected.value == "domain") {
		let regex_domain = new RegExp(pattern_domain);
		return domain.value == null || regex_domain.test(domain.value) == false;
	    } else if (radio_selected.value == "certificate") {
		let regex_certificate = new RegExp(pattern_certificate);
		return tls_certificate.value == null || regex_certificate.test(tls_certificate.value) == false;
	    }
	    return false;
	};

	const alert_name = computed$1(() => props.alert?.alert_name);

	const host_addr = computed$1(() => {
	    let res = { value: "", label: "" };
	    if (props.page != "host" || props.alert == null) { return res; }
	    let alert = props.alert;
	    res.value = alert.ip.value;
	    if (alert.vlan != null && alert.vlan.value != null && alert.vlan.value != 0) {
		res.value = res.value + '@' + alert.vlan.value;
	    }
	    res.label = (alert.ip.label) ? `${alert.ip.label} (${alert.ip.value})` : alert.ip.value;
	    return res;
	});

	const flow_addr = computed$1(() => {
	    let res = { cli_value: "", cli_label: "", srv_value: "", srv_label: "" };
	    if (props.page != "flow" || props.alert == null) { return res; }
	    let alert = props.alert;
	    res.cli_value = alert.flow.cli_ip.value;
	    res.srv_value = alert.flow.srv_ip.value;
	    if(alert.flow.vlan != null && alert.flow.vlan.value != null && alert.flow.vlan.value != 0) {
	        res.cli_value = res.cli_value + '@' + alert.flow.vlan.value;
	        res.srv_value = res.srv_value + '@' + alert.flow.vlan.value;
	    }
	    
	    res.cli_label = (alert.flow.cli_ip.label) ? `${alert.flow.cli_ip.label} (${res.cli_value})` : res.cli_value;
	    res.srv_label = (alert.flow.srv_ip.label) ? `${alert.flow.srv_ip.label} (${res.srv_value})` : res.srv_value;
	    return res;
	});

	const show = () => {
	    modal_id.value.show();
	};

	function get_type() {
	    if (radio_selected.value == "domain" || radio_selected.value == "certificate") {
		return radio_selected.value;
	    }
	    return "host";
	}

	let pattern_domain = NtopUtils.REGEXES.non_quoted_text;
	let pattern_certificate = NtopUtils.REGEXES.tls_certificate;

	const exclude = () => {
	    let page = props.page;
	    let type = get_type();
	    let params = {
	    	delete_alerts: disable_alerts.value,
		type,	
	    };
	    let addr = null;
	    if (type == "host") {	
		if (radio_selected.value == "host") {
		    addr = host_addr.value.value;
		} else if (radio_selected.value == "server_host") {
		    addr = flow_addr.value.srv_value;
		} else if (radio_selected.value == "client_host") {
		    addr = flow_addr.value.cli_value;
		}
		params.alert_addr = addr;
		if (page == "flow") {
		    params.flow_alert_key = props.alert.alert_id.value;
		} else if (page == "host") {
		    params.host_alert_key = props.alert.alert_id.value;
		}
	    } else if (type == "domain") {
		params.delete_alerts = false;
		params.alert_domain = domain.value;
	    } else if (type == "certificate") {
		params.delete_alerts = false;
		params.alert_certificate = tls_certificate.value;
	    }
	    close();
	    emit('exclude', params);
	};

	const close = () => {
	    modal_id.value.close();
	};


	expose({ show, close });

	onMounted(() => {
	});

	const _i18n = (t) => i18n(t);


	return (_ctx, _cache) => {
	  return (openBlock(), createBlock(script$y, {
	    onShowed: _cache[9] || (_cache[9] = $event => (showed())),
	    ref_key: "modal_id",
	    ref: modal_id
	  }, {
	    title: withCtx(() => [
	      createTextVNode(toDisplayString(_i18n('exclude_check')) + ": ", 1 /* TEXT */),
	      createBaseVNode("span", { innerHTML: unref(alert_name) }, null, 8 /* PROPS */, _hoisted_1)
	    ]),
	    body: withCtx(() => [
	      createBaseVNode("div", _hoisted_2, [
	        createBaseVNode("div", null, [
	          createBaseVNode("label", null, [
	            createTextVNode(toDisplayString(_i18n('exclude_check')) + " \"", 1 /* TEXT */),
	            createBaseVNode("b", { innerHTML: unref(alert_name) }, null, 8 /* PROPS */, _hoisted_3),
	            _hoisted_4,
	            createBaseVNode("span", _hoisted_5, toDisplayString(_i18n('exclude_for')) + ":", 1 /* TEXT */)
	          ]),
	          createBaseVNode("div", _hoisted_6, [
	            withDirectives(createBaseVNode("input", {
	              class: "form-check-input",
	              type: "radio",
	              value: "any",
	              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((radio_selected).value = $event))
	            }, null, 512 /* NEED_PATCH */), [
	              [vModelRadio, radio_selected.value]
	            ]),
	            createBaseVNode("label", _hoisted_7, [
	              createBaseVNode("span", null, toDisplayString(_i18n('show_alerts.filter_disable_check')), 1 /* TEXT */)
	            ])
	          ]),
	          (__props.page == 'host')
	            ? (openBlock(), createElementBlock("div", _hoisted_8, [
	                withDirectives(createBaseVNode("input", {
	                  class: "form-check-input",
	                  type: "radio",
	                  value: "host",
	                  "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((radio_selected).value = $event))
	                }, null, 512 /* NEED_PATCH */), [
	                  [vModelRadio, radio_selected.value]
	                ]),
	                createBaseVNode("label", _hoisted_9, [
	                  createBaseVNode("span", null, toDisplayString(unref(host_addr).label), 1 /* TEXT */)
	                ])
	              ]))
	            : createCommentVNode("v-if", true),
	          (__props.page == 'flow')
	            ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
	                createBaseVNode("div", _hoisted_10, [
	                  withDirectives(createBaseVNode("input", {
	                    class: "form-check-input",
	                    type: "radio",
	                    value: "client_host",
	                    "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((radio_selected).value = $event))
	                  }, null, 512 /* NEED_PATCH */), [
	                    [vModelRadio, radio_selected.value]
	                  ]),
	                  createBaseVNode("label", _hoisted_11, [
	                    createBaseVNode("span", null, toDisplayString(_i18n('client')) + ": " + toDisplayString(unref(flow_addr).cli_label), 1 /* TEXT */)
	                  ])
	                ]),
	                createBaseVNode("div", _hoisted_12, [
	                  withDirectives(createBaseVNode("input", {
	                    class: "form-check-input",
	                    type: "radio",
	                    value: "server_host",
	                    "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ((radio_selected).value = $event))
	                  }, null, 512 /* NEED_PATCH */), [
	                    [vModelRadio, radio_selected.value]
	                  ]),
	                  createBaseVNode("label", _hoisted_13, [
	                    createBaseVNode("span", null, toDisplayString(_i18n('server')) + ": " + toDisplayString(unref(flow_addr).srv_label), 1 /* TEXT */)
	                  ])
	                ])
	              ], 64 /* STABLE_FRAGMENT */))
	            : createCommentVNode("v-if", true)
	        ]),
	        (domain.value != null || tls_certificate.value != null)
	          ? (openBlock(), createElementBlock("div", _hoisted_14, [
	              createBaseVNode("label", null, [
	                createBaseVNode("span", _hoisted_15, toDisplayString(_i18n('check_exclusion.exclude_all_checks_for')) + ":", 1 /* TEXT */)
	              ]),
	              (domain.value != null)
	                ? (openBlock(), createElementBlock("div", _hoisted_16, [
	                    withDirectives(createBaseVNode("input", {
	                      class: "form-check-input",
	                      type: "radio",
	                      value: "domain",
	                      "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((radio_selected).value = $event))
	                    }, null, 512 /* NEED_PATCH */), [
	                      [vModelRadio, radio_selected.value]
	                    ]),
	                    createBaseVNode("label", _hoisted_17, [
	                      createBaseVNode("span", null, toDisplayString(_i18n("check_exclusion.domain")) + ":", 1 /* TEXT */)
	                    ]),
	                    withDirectives(createBaseVNode("input", {
	                      type: "text",
	                      pattern: unref(pattern_domain),
	                      disabled: radio_selected.value != 'domain',
	                      required: "",
	                      "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => ((domain).value = $event)),
	                      class: "form-check-label custom-width"
	                    }, null, 8 /* PROPS */, _hoisted_18), [
	                      [vModelText, domain.value]
	                    ])
	                  ]))
	                : createCommentVNode("v-if", true),
	              (tls_certificate.value != null)
	                ? (openBlock(), createElementBlock("div", _hoisted_19, [
	                    withDirectives(createBaseVNode("input", {
	                      class: "form-check-input",
	                      type: "radio",
	                      value: "certificate",
	                      "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((radio_selected).value = $event))
	                    }, null, 512 /* NEED_PATCH */), [
	                      [vModelRadio, radio_selected.value]
	                    ]),
	                    createBaseVNode("label", _hoisted_20, [
	                      createBaseVNode("span", null, toDisplayString(_i18n("check_exclusion.tls_certificate")) + ":", 1 /* TEXT */)
	                    ]),
	                    withDirectives(createBaseVNode("input", {
	                      type: "text",
	                      disabled: radio_selected.value != 'certificate',
	                      "onUpdate:modelValue": _cache[7] || (_cache[7] = $event => ((tls_certificate).value = $event)),
	                      pattern: unref(pattern_certificate),
	                      required: "",
	                      class: "form-check-label custom-width"
	                    }, null, 8 /* PROPS */, _hoisted_21), [
	                      [vModelText, tls_certificate.value]
	                    ])
	                  ]))
	                : createCommentVNode("v-if", true)
	            ]))
	          : createCommentVNode("v-if", true)
	      ]),
	      (radio_selected.value != 'domain' && radio_selected.value != 'certificate')
	        ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
	            withDirectives(createBaseVNode("div", { class: "message alert alert-danger" }, toDisplayString(_i18n("show_alerts.confirm_delete_filtered_alerts")), 513 /* TEXT, NEED_PATCH */), [
	              [vShow, disable_alerts.value]
	            ]),
	            _hoisted_22,
	            createBaseVNode("div", _hoisted_23, [
	              createBaseVNode("div", _hoisted_24, [
	                withDirectives(createBaseVNode("input", {
	                  type: "checkbox",
	                  class: "custom-control-input whitespace",
	                  "onUpdate:modelValue": _cache[8] || (_cache[8] = $event => ((disable_alerts).value = $event))
	                }, null, 512 /* NEED_PATCH */), [
	                  [vModelCheckbox, disable_alerts.value]
	                ]),
	                createBaseVNode("label", _hoisted_25, toDisplayString(_i18n("delete_disabled_alerts")), 1 /* TEXT */)
	              ])
	            ])
	          ], 64 /* STABLE_FRAGMENT */))
	        : createCommentVNode("v-if", true),
	      createBaseVNode("div", _hoisted_26, toDisplayString(_i18n("show_alerts.confirm_filter_alert")), 1 /* TEXT */)
	    ]),
	    footer: withCtx(() => [
	      createBaseVNode("button", {
	        type: "button",
	        onClick: exclude,
	        disabled: check_disable_apply(),
	        class: "btn btn-warning"
	      }, toDisplayString(_i18n("filter")), 9 /* TEXT, PROPS */, _hoisted_27)
	    ]),
	    _: 1 /* STABLE */
	  }, 512 /* NEED_PATCH */))
	}
	}

	};

	var css_248z = "\n.whitespace[data-v-19c5b1f1] {\n  margin-right: 0.2rem;\n}\n.custom-width[data-v-19c5b1f1] {\n  display: block;\n  min-width: 100%;\n}\ninput[data-v-19c5b1f1]:invalid {\n  border-color: #ff0000;\n}\n.exclude-domain-certificate[data-v-19c5b1f1] {\n  margin-top: 0.4rem;\n}\n";
	styleInject(css_248z);

	script.__scopeId = "data-v-19c5b1f1";
	script.__file = "http_src/vue/modal-alerts-filter.vue";

	let ntopVue = {
	    // pages
	    PageStats: script$q,
	    PageAssetTable: script$n,
	    PagePeriodicityTable: script$m,
	    PageServiceTable: script$l,
	    PageServiceMap: script$i,
	    PagePeriodicityMap: script$h,
	    PageAssetMap: script$g,
	    PageDeviceExclusions: script$c,
	    PageHostTLS: script$b,
	    PageHostSSH: script$a,
	    PageHomeMap: script$9,
	    PageSankey: script$8,

	    // Host details pages
	    PageHostDetailsApplications: script$7,
	    PageHostDetailsTraffic: script$6,
	    PageHostDetailsPackets: script$5,

	    // components
	    AlertInfo: script$t,
	    Chart: script$B,
	    Datatable: script$s,
	    DateTimeRangePicker: script$z,
	    NetworkMap: script$k,
	    RangePicker: script$3,
	    PageNavbar: script$f,
	    SimpleTable: script$2,
	    SelectSearch: script$A,
	    TabList: script$p,
	    
	    // list
	    ListTimeseries: script$w,

	    // modals
	    Modal: script$y,
	    ModalAddCheckExclusion: script$1,
	    ModalAlertsFilter: script,
	    ModalFilters: script$4,
	    ModalTimeseries: script$v,
	    ModalTrafficExtraction: script$u,
	    ModalDeleteConfirm: script$o,
	    ModalSnapshot: script$x,
	    ModalAddDeviceExclusion: script$e,
	    ModalEditDeviceExclusion: script$d,

	    Vue: Vue,
	};
	window.ntopVue = ntopVue;

})();
